// Graph visualization for DeHashed data
let network = null;
let nodes = null;
let edges = null;
let nodeIdCounter = 0;
let searchCache = new Map(); // Cache for search results
let nodeExpansionCache = new Map(); // Track which nodes have been expanded
let valueToNodeMap = new Map(); // Map values to node IDs for deduplication
let breachConnections = new Map(); // Map breach names to node arrays
let focusedNode = null; // Currently focused node
let originalNodeColors = new Map(); // Store original colors during focus
let isGroupDrag = false; // Track if we're doing a group drag
let currentProfileNode = null; // Currently edited node
let includeHashedPasswords = false; // Option to include hashed passwords
let showArrows = false; // Option to show arrow direction on edges
let showImageSources = true; // Option to show/hide image source connections
let nodeSearchQueries = new Map(); // Map to store search relationships for query nodes
let anchoredNodes = new Set(); // Set of anchored node IDs
let selectedNodes = new Set(); // Currently selected nodes
let connectionMode = false; // Track if we're in connection mode
let connectionSourceNode = null; // Source node for creating connections
let connectionLine = null; // Visual line while dragging

// Universal Undo system - stores complete graph states
let undoStack = []; // Stack of complete graph states
const MAX_UNDO_STACK_SIZE = 20; // Limit undo history (fewer since we store full states)
let isRestoringFromUndo = false; // Prevent undo operations from creating new undo states

// Cluster system
let clusters = new Map(); // Map cluster IDs to cluster data
let clusterIdCounter = 0;
let showClusterContents = true; // Toggle to show/hide nodes inside clusters
let clusterConnections = new Map(); // Map cluster connections to simplified edges

// Load cache from disk on startup
async function loadCacheFromStorage() {
    try {
        const response = await fetch('/api/cache/load');
        const result = await response.json();
        
        if (result.data) {
            // Load search cache
            if (result.data.search_cache) {
                // Convert object back to Map
                searchCache = new Map(Object.entries(result.data.search_cache));
                console.log(`Loaded ${searchCache.size} cached searches from disk`);
            }
            
            // Return graph state for loading
            return result.data.graph_state;
        }
    } catch (e) {
        console.error('Error loading cache from disk:', e);
    }
    return null;
}

// Save cache to disk
async function saveCacheToStorage() {
    try {
        // Convert Map to object for serialization
        const cacheObj = {};
        searchCache.forEach((value, key) => {
            cacheObj[key] = value;
        });
        
        const data = {
            search_cache: cacheObj
        };
        
        const response = await fetch('/api/cache/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });
        
        const result = await response.json();
        if (result.success) {
            console.log(`Saved ${searchCache.size} searches to disk`);
        }
    } catch (e) {
        console.error('Error saving cache to disk:', e);
    }
}

// Save graph state to disk
async function saveGraphState() {
    try {
        const graphState = {
            nodes: nodes.get(),
            edges: edges.get(),
            nodeIdCounter: nodeIdCounter,
            valueToNodeMap: Array.from(valueToNodeMap.entries()),
            breachConnections: Array.from(breachConnections.entries()),
            nodeSearchQueries: Array.from(nodeSearchQueries.entries()),
            activeQueryNodes: Array.from(activeQueryNodes.entries()),
            autoShowQueries: autoShowQueries,
            anchoredNodes: Array.from(anchoredNodes)
        };
        
        const data = {
            graph_state: graphState
        };
        
        const response = await fetch('/api/cache/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });
        
        const result = await response.json();
        if (result.success) {
            console.log('Graph state saved to disk');
        }
    } catch (e) {
        console.error('Error saving graph state to disk:', e);
    }
}

// Load graph state from disk (now done via loadCacheFromStorage)
function loadGraphState(graphState) {
    try {
        if (graphState) {
            // Clear existing data first to avoid duplicates
            nodes.clear();
            edges.clear();
            
            // Restore nodes with their saved positions
            if (graphState.nodes) {
                // Ensure each node has its position
                graphState.nodes.forEach(node => {
                    // vis.js needs x and y at the top level
                    if (node.x === undefined || node.y === undefined) {
                        // If position is missing, give it a default
                        node.x = Math.random() * 1000 - 500;
                        node.y = Math.random() * 1000 - 500;
                    }
                });
                nodes.add(graphState.nodes);
            }
            
            // Restore edges and fix their colors
            if (graphState.edges) {
                // Fix green colors to gray
                graphState.edges.forEach(edge => {
                    if (edge.color) {
                        if (edge.color === '#00ff00' || edge.color === '#0f0') {
                            edge.color = '#666666';
                        } else if (edge.color.color === '#00ff00' || edge.color.color === '#0f0') {
                            edge.color.color = '#666666';
                        }
                    }
                });
                edges.add(graphState.edges);
            }
            
            // Restore counters
            if (graphState.nodeIdCounter) {
                nodeIdCounter = graphState.nodeIdCounter;
            }
            
            // Restore value map
            if (graphState.valueToNodeMap) {
                valueToNodeMap = new Map(graphState.valueToNodeMap);
            }
            
            // Restore breach connections
            if (graphState.breachConnections) {
                breachConnections = new Map(graphState.breachConnections);
                
                // Rebuild breach connections if edges are missing
                breachConnections.forEach((nodeIds, breachName) => {
                    console.log(`Checking breach ${breachName} with ${nodeIds.length} nodes`);
                    
                    // Check if connections exist
                    let hasConnections = false;
                    if (nodeIds.length >= 2) {
                        const testEdge = edges.get({
                            filter: edge => edge.title && edge.title.includes(breachName)
                        });
                        hasConnections = testEdge.length > 0;
                    }
                    
                    // Recreate connections if missing
                    if (!hasConnections && nodeIds.length >= 2) {
                        console.log(`Recreating connections for breach: ${breachName}`);
                        connectBreachNodes(nodeIds, breachName);
                    }
                });
            }
            
            // Restore search queries
            if (graphState.nodeSearchQueries) {
                nodeSearchQueries = new Map(graphState.nodeSearchQueries);
                console.log(`Loaded ${nodeSearchQueries.size} search queries`);
            }
            
            // Restore active query nodes
            if (graphState.activeQueryNodes) {
                activeQueryNodes = new Map(graphState.activeQueryNodes);
                console.log(`Loaded ${activeQueryNodes.size} active query nodes`);
            }
            
            // Restore autoShowQueries state and update checkbox
            if (graphState.autoShowQueries !== undefined) {
                autoShowQueries = graphState.autoShowQueries;
                const checkbox = document.getElementById('showQueries');
                if (checkbox) {
                    checkbox.checked = autoShowQueries;
                }
            }
            
            // Restore anchored nodes
            if (graphState.anchoredNodes) {
                anchoredNodes = new Set(graphState.anchoredNodes);
                console.log(`Loaded ${anchoredNodes.size} anchored nodes`);
            }
            
            // Restore clusters
            if (graphState.clusters) {
                clusters = new Map(graphState.clusters);
                console.log(`Loaded ${clusters.size} clusters`);
            }
            
            // Restore cluster ID counter
            if (graphState.clusterIdCounter !== undefined) {
                clusterIdCounter = graphState.clusterIdCounter;
            }
            
            // Update colors and physics for loaded nodes
            const allNodes = nodes.get();
            const updates = [];
            allNodes.forEach(node => {
                let needsUpdate = false;
                const update = { id: node.id };
                
                // Update password node colors
                if (node.type === 'password' || node.type === 'hashed_password') {
                    const newColor = getNodeColor(node.type);
                    update.color = {
                        background: '#000000',
                        border: newColor,
                        highlight: {
                            background: '#1a1a1a',
                            border: newColor
                        }
                    };
                    needsUpdate = true;
                }
                
                // Ensure check indicators have correct physics
                if (node.isCheckIndicator) {
                    update.physics = true;
                    update.mass = 0.1;
                    update.fixed = { x: false, y: false };
                    update.chosen = { node: true, label: true };
                    needsUpdate = true;
                }
                
                // Ensure query nodes have correct physics
                if (node.isQueryNode || node.id.startsWith('query_')) {
                    update.physics = true;
                    update.mass = 1;
                    update.fixed = { x: false, y: false };
                    update.chosen = { node: true, label: true };
                    needsUpdate = true;
                }
                
                // Ensure regular nodes have physics disabled
                if (!node.isCheckIndicator && !node.isQueryNode && !node.id.startsWith('query_') && !node.id.startsWith('check_')) {
                    update.physics = false;
                    needsUpdate = true;
                }
                
                // Apply anchored node styling - ONLY background color
                if (anchoredNodes.has(node.id)) {
                    const typeColor = getNodeColor(node.type);
                    update.borderWidth = 2;  // NORMAL border
                    update.borderWidthSelected = 3;  // NORMAL selected
                    update.size = undefined;  // DEFAULT size
                    update.color = {
                        background: '#000000',  // Black background
                        border: typeColor,
                        highlight: {
                            background: '#1a1a1a',
                            border: typeColor
                        }
                    };
                    update.font = {
                        color: '#FFFFFF'  // White text - ONLY CHANGE
                    };
                    needsUpdate = true;
                }
                
                if (needsUpdate) {
                    updates.push(update);
                }
            });
            if (updates.length > 0) {
                nodes.update(updates);
                console.log(`Updated ${updates.length} nodes with correct properties`);
            }
            
            console.log(`Loaded graph with ${nodes.get().length} nodes and ${edges.get().length} edges`);
            return true;
        }
        return false;
    } catch (e) {
        console.error('Error loading graph state:', e);
        return false;
    }
}

// Track active query nodes
let activeQueryNodes = new Map();
// Track visible search indicators
let visibleSearchIndicators = new Set();

// Draw search indicators on nodes
function drawSearchIndicators() {
    // COMPLETELY DISABLED - NO INDICATORS
    return;
}

// Remove all fucking indicator circles
function removeAllIndicators() {
    if (!nodes) return;
    
    const allNodes = nodes.get();
    const indicatorNodes = allNodes.filter(node => 
        node.isCheckIndicator || node.isMergeIndicator || 
        node.id.startsWith('check_') || node.id.startsWith('merge_')
    );
    
    indicatorNodes.forEach(node => {
        // Remove associated edges
        const connectedEdges = edges.get({
            filter: edge => edge.from === node.id || edge.to === node.id
        });
        connectedEdges.forEach(edge => edges.remove(edge.id));
        
        // Remove the node
        nodes.remove(node.id);
    });
    
    updateStatus(`Removed ${indicatorNodes.length} indicator circles`);
}

// Call this immediately to remove existing circles
if (typeof nodes !== 'undefined' && nodes) {
    removeAllIndicators();
}

// Function to call from console to remove circles
window.removeCircles = function() {
    if (nodes) {
        removeAllIndicators();
        console.log("All indicator circles removed!");
    }
}

// Toggle query node (transform check to query node and back)
function toggleQueryNode(searchKey) {
    const searchData = nodeSearchQueries.get(searchKey);
    if (!searchData) return;
    
    const sourceNode = nodes.get(searchData.sourceNode);
    if (!sourceNode) return;
    
    const queryNodeId = 'query_' + searchData.sourceNode;
    const existingQueryNode = nodes.get(queryNodeId);
    
    if (existingQueryNode) {
        // Query node exists - remove it and its edges
        hideQueryNode(queryNodeId);
    } else {
        // Create query node in place of the check
        const sourcePos = network.getPositions([searchData.sourceNode])[searchData.sourceNode];
        const canvasPos = network.canvasToDOM(sourcePos);
        
        // Remove the check node first
        const checkNodeId = 'check_' + searchData.sourceNode;
        if (nodes.get(checkNodeId)) {
            edges.remove('edge_' + searchData.sourceNode + '_' + checkNodeId);
            nodes.remove(checkNodeId);
        }
        
        const queryNode = {
            id: queryNodeId,
            label: searchData.query,
            title: `Query for: ${searchData.query}\nFound ${searchData.results.length} results\nDouble-click to minimize back to check`,
            color: {
                background: '#000000',
                border: '#ff0000',
                highlight: {
                    background: '#330000',
                    border: '#ff0000'
                }
            },
            borderWidth: 3,
            borderWidthSelected: 4,
            font: {
                color: '#ff0000',
                size: 12,
                face: 'monospace',
                bold: true
            },
            shape: 'box',
            x: sourcePos.x + 200 + Math.random() * 200,
            y: sourcePos.y - 200 - Math.random() * 200,
            isQueryNode: true,
            physics: true,
            mass: 1,
            fixed: {
                x: false,
                y: false
            },
            chosen: {
                node: true,
                label: true
            }
        };
        
        nodes.add(queryNode);
        activeQueryNodes.set(queryNodeId, searchData);
        
        // Add edge from source to query node
        if (searchData.sourceNode !== queryNodeId) {
            edges.add({
                id: 'edge_' + searchData.sourceNode + '_' + queryNodeId,
                from: searchData.sourceNode,
                to: queryNodeId,
                color: {
                    color: '#ff0000'
                },
                dashes: [5, 5],
                width: 1
            });
        }
        
        // Add edges from query node to all results
        searchData.results.forEach(resultId => {
            if (queryNodeId !== resultId) {
                edges.add({
                id: 'edge_' + queryNodeId + '_' + resultId,
                from: queryNodeId,
                to: resultId,
                color: {
                    color: '#ff6600'
                },
                dashes: [2, 2],
                width: 1,
                arrows: {
                    to: {
                        enabled: false
                    }
                }
            });
            }
        });
        
        // Redraw indicators to hide the check for this node
        drawSearchIndicators();
    }
}

// Hide query node and restore check indicator
function hideQueryNode(queryNodeId, showCheckBriefly = true) {
    // Remove all edges connected to this query node
    const connectedEdges = edges.get({
        filter: edge => edge.from === queryNodeId || edge.to === queryNodeId
    });
    connectedEdges.forEach(edge => edges.remove(edge.id));
    
    // Remove the query node
    nodes.remove(queryNodeId);
    activeQueryNodes.delete(queryNodeId);
    
    if (autoShowQueries) {
        // Show check briefly then hide it
        drawSearchIndicators();
        setTimeout(() => {
            drawSearchIndicators(); // This will hide the check for this specific node
        }, 500);
    } else {
        // Don't show checks at all when queries toggle is off
        clearSearchIndicators();
    }
}

// Add merge indicator outside node - DISABLED
function addMergeIndicator(nodeId, count) {
    // COMPLETELY DISABLED - NO INDICATORS
    return;
}

// Clear search indicators
function clearSearchIndicators() {
    // Remove DOM indicators if any
    const indicators = document.querySelectorAll('.search-indicator');
    indicators.forEach(indicator => indicator.remove());
    
    // Remove check nodes
    const checkNodes = nodes.get({
        filter: node => node.isCheckIndicator === true
    });
    
    checkNodes.forEach(node => {
        // Remove edge to check node
        edges.remove('edge_' + node.parentNodeId + '_' + node.id);
        // Remove check node
        nodes.remove(node.id);
    });
}

// Initialize the graph
function initializeGraph() {
    // Create empty datasets
    nodes = new vis.DataSet([]);
    edges = new vis.DataSet([]);
    
    // Container for the graph
    const container = document.getElementById('network');
    
    // Data for the graph
    const data = {
        nodes: nodes,
        edges: edges
    };
    
    // Options for the graph
    const options = {
        nodes: {
            shape: 'box',
            font: {
                size: 12,
                face: 'monospace',
                multi: true // Allow line breaks
            },
            borderWidth: 2,
            shadow: false,  // No shadow unless selected
            widthConstraint: {
                maximum: 400, // Increased max width
                minimum: 100  // Min width
            },
            margin: 10 // Add padding inside nodes
        },
        edges: {
            arrows: {
                to: {
                    enabled: showArrows,
                    scaleFactor: 0.8
                }
            },
            color: {
                color: '#666666',
                highlight: '#ff0000'
            },
            width: 2,
            smooth: {
                type: 'cubicBezier'
            },
            font: {
                color: '#666666',
                size: 10,
                face: 'monospace',
                align: 'middle'
            }
        },
        physics: {
            enabled: true, // Enable physics for check nodes to move with graph
            solver: 'barnesHut',
            barnesHut: {
                gravitationalConstant: -50,
                centralGravity: 0,
                springLength: 50,
                springConstant: 0.001,
                damping: 0.9,
                avoidOverlap: 0.5
            },
            stabilization: {
                enabled: false // Don't auto-stabilize
            }
        },
        interaction: {
            hover: true,
            tooltipDelay: 300,
            dragNodes: true,
            dragView: true,
            navigationButtons: false,
            multiselect: true,  // Enable multi-select with shift/ctrl
            selectConnectedEdges: false
        },
        manipulation: {
            enabled: false
        }
    };
    
    // Create the network
    network = new vis.Network(container, data, options);
    
    
    // Only update search indicators when needed, not constantly
    // This was causing performance issues and interfering with interactions
    
    // Remove anchor icon drawing - just use visual node properties
    
    // Save positions after network stabilizes (including after zoom/pan)
    let saveTimer = null;
    network.on("stabilized", function() {
        // Debounce saves
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
            // Update node positions
            const allNodeIds = nodes.getIds();
            const positions = network.getPositions(allNodeIds);
            const updates = [];
            
            for (let nodeId in positions) {
                if (positions[nodeId]) {
                    const node = nodes.get(nodeId);
                    if (node && (node.x !== positions[nodeId].x || node.y !== positions[nodeId].y)) {
                        updates.push({
                            id: nodeId,
                            x: positions[nodeId].x,
                            y: positions[nodeId].y
                        });
                    }
                }
            }
            
            if (updates.length > 0) {
                nodes.update(updates);
                saveGraphState();
            }
        }, 500); // Wait 500ms after stabilization to save
    });
    
    // Handle node clicks
    network.on("click", function(params) {
        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const node = nodes.get(nodeId);
            
            // Handle connection mode
            if (connectionMode && connectionSourceNode) {
                if (nodeId !== connectionSourceNode) {
                    // Create connection
                    const connectionName = prompt('Enter connection name/reason:') || 'Manual connection';
                    
                    edges.add({
                        from: connectionSourceNode,
                        to: nodeId,
                        color: {
                            color: '#ff00ff' // Magenta for manual connections
                        },
                        dashes: false,
                        width: 2,
                        title: connectionName,
                        arrows: showArrows ? 'to' : ''
                    });
                    
                    updateStatus(`Connected ${connectionSourceNode} to ${nodeId}`);
                    saveGraphState();
                }
                
                // Exit connection mode
                cancelConnectionMode();
                return;
            }
            
            // Handle hypothetical link mode
            if (window.hypotheticalLinkMode && window.hypotheticalLinkSourceNode) {
                handleHypotheticalLinkClick(nodeId);
                return;
            }
            
            // Special handling for query nodes
            if (nodeId.startsWith('query_')) {
                const searchData = activeQueryNodes.get(nodeId);
                if (searchData) {
                    // Show the exact search variations in the details panel
                    const detailsDiv = document.getElementById('node-details');
                    const sourceNode = nodes.get(searchData.sourceNode);
                    let html = `
                        <div style="background: #0a0a0a; padding: 10px; border: 2px solid #ff0000;">
                            <h3 style="color: #ff0000">Query Node Details</h3>
                            <table style="width: 100%; margin-top: 10px;">
                                <tr><td style="color: #ffff00; width: 40%;">Search Query:</td><td style="color: #00ff00;">${escapeHtml(searchData.query)}</td></tr>
                                <tr><td style="color: #ffff00;">Source Node:</td><td style="color: #00ff00;">${sourceNode ? sourceNode.type + ': ' + sourceNode.label : searchData.sourceNode}</td></tr>
                                <tr><td style="color: #ffff00;">Search Time:</td><td style="color: #00ff00;">${new Date(searchData.timestamp).toLocaleString()}</td></tr>
                                <tr><td style="color: #ffff00;">Results Found:</td><td style="color: #00ff00;">${searchData.results.length}</td></tr>
                            </table>
                            <hr style="border-color: #ff0000; margin: 15px 0;">
                            <h4 style="color: #ffff00">Search Results:</h4>
                            <ul style="color: #00ff00; list-style: none; padding: 0;">
                    `;
                    searchData.results.forEach(resultId => {
                        const resultNode = nodes.get(resultId);
                        if (resultNode) {
                            const typeColor = getNodeColor(resultNode.type);
                            html += `<li style="margin: 5px 0; padding: 5px; border-left: 3px solid ${typeColor};">
                                        <span style="color: ${typeColor};">${resultNode.type.toUpperCase()}</span>: 
                                        <span style="color: #00ff00;">${escapeHtml(resultNode.label)}</span>
                                     </li>`;
                        }
                    });
                    html += `
                            </ul>
                            <div style="margin-top: 20px; padding: 10px; background: #1a0000; border: 1px solid #660000;">
                                <p style="color: #ff6666; font-size: 11px; margin: 0;">ℹ️ Double-click the query node to minimize it back to a check indicator</p>
                            </div>
                        </div>
                    `;
                    detailsDiv.innerHTML = html;
                }
            } else if (node && node.isCheckIndicator) {
                // Show info for check indicators
                const searchKey = node.searchKey;
                const searchData = nodeSearchQueries.get(searchKey);
                if (searchData) {
                    const detailsDiv = document.getElementById('node-details');
                    detailsDiv.innerHTML = `
                        <div style="background: #0a0a0a; padding: 10px; border: 2px solid #ff0000;">
                            <h3 style="color: #ff0000">Search Indicator</h3>
                            <p style="color: #00ff00">This node has been searched</p>
                            <p style="color: #ffff00">Found ${searchData.results.length} results</p>
                            <p style="color: #ff6666; margin-top: 10px">Double-click to expand and see search results</p>
                        </div>
                    `;
                }
            } else {
                showNodeDetails(node);
            }
        }
    });
    
    // Update node list when nodes are added/removed
    nodes.on('add', function() {
        if (document.getElementById('panel-nodes').classList.contains('active')) {
            updateNodeList();
        }
    });
    
    nodes.on('remove', function() {
        if (document.getElementById('panel-nodes').classList.contains('active')) {
            updateNodeList();
        }
    });
    
    // Handle double clicks
    network.on("doubleClick", function(params) {
        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const node = nodes.get(nodeId);
            
            // Check if it's a query node
            if (nodeId.startsWith('query_')) {
                console.log('Double-clicked query node:', nodeId);
                hideQueryNode(nodeId);
                return;
            } 
            // Check if it's a check indicator
            else if (node && node.isCheckIndicator) {
                // Transform check to query node
                const searchKey = node.searchKey;
                toggleQueryNode(searchKey);
                return;
            } 
            else {
                console.log('About to call expandNode with node:', node);
                expandNode(node);
            }
        }
    });
    
    // Handle right clicks
    network.on("oncontext", function(params) {
        params.event.preventDefault();
        
        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const node = nodes.get(nodeId);
            showContextMenu(params.event, node);
        } else {
            showContextMenu(params.event, null, params.pointer.canvas);
        }
    });
    
    // Handle mouse down for focus mode - DISABLED
    /*
    network.on("hold", function(params) {
        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            focusNode(nodeId);
        }
    });
    */
    
    // Handle mouse up to release focus
    network.on("release", function(params) {
        if (focusedNode) {
            releaseFocus();
        }
    });
    
    // Also release on general mouse up (backup)
    document.addEventListener('mouseup', function() {
        if (focusedNode) {
            releaseFocus();
        }
    });
    
    // Handle ESC key to cancel connection mode
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && connectionMode) {
            cancelConnectionMode();
        }
    });
    
    // Handle edge hover
    network.on("hoverEdge", function(params) {
        if (params.edge) {
            const edge = edges.get(params.edge);
            if (edge) {
                // Show edge information
                const fromNode = nodes.get(edge.from);
                const toNode = nodes.get(edge.to);
                
                let info = '';
                if (edge.title && edge.title.includes('Same breach record')) {
                    // Breach record connection
                    info = edge.title;
                } else {
                    // Other connection
                    info = `Connected: ${fromNode.label} - ${toNode.label}`;
                    if (edge.title) {
                        info = edge.title;
                    }
                }
                
                // Update status bar with edge info
                updateStatus(info);
                
                // Create floating tooltip
                let tooltip = document.getElementById('edge-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'edge-tooltip';
                    tooltip.style.cssText = `
                        position: absolute;
                        background: #000;
                        border: 2px solid #0f0;
                        color: #0f0;
                        padding: 10px;
                        font-family: monospace;
                        font-size: 11px;
                        line-height: 1.3;
                        z-index: 1000;
                        max-width: 400px;
                        max-height: 500px;
                        overflow-y: auto;
                        box-shadow: 0 0 10px #0f0;
                        pointer-events: none;
                    `;
                    document.body.appendChild(tooltip);
                }
                
                // Format tooltip content
                let tooltipHTML = '';
                if (edge.title && edge.title.includes('Same breach record')) {
                    tooltipHTML = `<strong style="color: #ff6600;">${escapeHtml(edge.title)}</strong><br>`;
                    tooltipHTML += `<span style="color: #888;">These items were found together</span><br><br>`;
                    tooltipHTML += `<span style="color: ${getNodeColor(fromNode.type)}">${fromNode.type.toUpperCase()}: ${escapeHtml(fromNode.label)}</span><br>`;
                    tooltipHTML += `<span style="color: ${getNodeColor(toNode.type)}">${toNode.type.toUpperCase()}: ${escapeHtml(toNode.label)}</span>`;
                } else {
                    tooltipHTML = `<strong style="color: #0ff;">Connection</strong><br>`;
                    tooltipHTML += `<span style="color: ${getNodeColor(fromNode.type)}">${escapeHtml(fromNode.label)}</span><br>`;
                    tooltipHTML += `<span style="color: ${getNodeColor(toNode.type)}">${escapeHtml(toNode.label)}</span>`;
                    if (edge.title) {
                        tooltipHTML += `<br><span style="color: #888;">${escapeHtml(edge.title)}</span>`;
                    }
                }
                
                tooltip.innerHTML = tooltipHTML;
                tooltip.style.display = 'block';
                
                // Position tooltip near mouse
                const updateTooltipPosition = (e) => {
                    tooltip.style.left = (e.pageX + 15) + 'px';
                    tooltip.style.top = (e.pageY - 30) + 'px';
                };
                
                // Track mouse movement
                document.addEventListener('mousemove', updateTooltipPosition);
                tooltip.setAttribute('data-mousemove-handler', 'true');
                
                // Highlight the edge
                edges.update({
                    id: params.edge,
                    width: 4,
                    color: {
                        color: '#ffff00',
                        highlight: '#ff0000',  // Keep red highlight when clicked
                        inherit: false
                    }
                });
            }
        }
    });
    
    // Handle edge blur (mouse leaves edge)
    network.on("blurEdge", function(params) {
        if (params.edge) {
            const edge = edges.get(params.edge);
            if (edge) {
                // Check if this edge connects two anchored nodes
                const fromAnchored = anchoredNodes.has(edge.from);
                const toAnchored = anchoredNodes.has(edge.to);
                const isBetweenAnchored = fromAnchored && toAnchored;
                
                // Determine the correct color to restore
                let restoreColor = '#666666'; // Default grey
                let restoreWidth = 2;
                let restoreDashes = true;
                
                if (isBetweenAnchored) {
                    // Keep thick white for anchored connections
                    restoreColor = '#ffffff';
                    restoreWidth = 3;
                    restoreDashes = false;
                } else if (edge.color && edge.color.color === '#20B2AA') {
                    // WHOIS connections stay teal
                    restoreColor = '#20B2AA';
                } else if (edge.color && edge.color.color === '#ff00ff') {
                    // Manual connections stay magenta
                    restoreColor = '#ff00ff';
                }
                
                // Restore edge appearance based on its type
                edges.update({
                    id: params.edge,
                    width: restoreWidth,
                    dashes: restoreDashes,
                    color: {
                        color: restoreColor,
                        inherit: false
                    }
                });
                
                // Hide tooltip
                const tooltip = document.getElementById('edge-tooltip');
                if (tooltip) {
                    tooltip.style.display = 'none';
                    // Remove mousemove listener
                    if (tooltip.getAttribute('data-mousemove-handler')) {
                        const handlers = document._getEventListeners ? document._getEventListeners(document).mousemove : [];
                        // Just hide it, the handler will be replaced on next hover
                    }
                }
                
                // Clear status
                updateStatus('Ready');
            }
        }
    });
    
    // Handle keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        // Check if user is typing in an input/textarea field
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
            activeElement.tagName === 'INPUT' || 
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.contentEditable === 'true'
        );
        
        // Delete key for selected nodes (only if not typing)
        if ((e.key === 'Delete' || e.key === 'Backspace') && !isTyping) {
            const selectedNodes = network.getSelectedNodes();
            if (selectedNodes.length > 0) {
                e.preventDefault();
                deleteSelectedNodes(selectedNodes);
            }
        }
        
        // Ctrl/Cmd + A to select all (only if not typing)
        if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isTyping) {
            e.preventDefault();
            network.selectNodes(nodes.getIds());
        }
        
        // Escape to deselect
        if (e.key === 'Escape') {
            network.unselectAll();
            fixStuckFocus();
        }
        
        // R to reset node colors (only if not typing)
        if ((e.key === 'r' || e.key === 'R') && !isTyping) {
            e.preventDefault();
            if (e.shiftKey) {
                // Shift+R to recover lost nodes
                recoverLostNodes();
            } else {
                fixStuckFocus();
            }
        }
    });
    
    // Ensure node remains visible and properly configured
    function ensureNodeVisible(nodeId) {
        const node = nodes.get(nodeId);
        if (node) {
            const update = {
                id: nodeId,
                hidden: false,
                physics: false
                // Don't update fixed property - let vis.js handle it
            };
            
            // Get current position
            const currentPos = network.getPositions([nodeId])[nodeId];
            if (currentPos && !isNaN(currentPos.x) && !isNaN(currentPos.y)) {
                update.x = currentPos.x;
                update.y = currentPos.y;
            } else if (node.x !== undefined && node.y !== undefined) {
                // Fallback to stored position
                update.x = node.x;
                update.y = node.y;
            } else {
                // Last resort: center the node
                console.warn(`[EnsureVisible] No valid position for node ${nodeId}, centering it`);
                const view = network.getViewPosition();
                update.x = view.x;
                update.y = view.y;
            }
            
            nodes.update(update);
            
            // Force a redraw
            network.redraw();
            
            return true;
        }
        return false;
    }
    
    // Safe node movement function
    function safeMoveNode(nodeId, x, y) {
        if (nodeId && !isNaN(x) && !isNaN(y) && isFinite(x) && isFinite(y)) {
            try {
                // Check if node exists before moving
                const node = nodes.get(nodeId);
                if (!node) {
                    console.error(`[SafeMove] Node ${nodeId} does not exist in dataset`);
                    return false;
                }
                
                console.log(`[SafeMove] Moving node ${nodeId} to (${x}, ${y})`);
                network.moveNode(nodeId, x, y);
                
                // Verify position after move
                const newPos = network.getPositions([nodeId])[nodeId];
                if (!newPos || isNaN(newPos.x) || isNaN(newPos.y)) {
                    console.error(`[SafeMove] Failed to verify position after move for node ${nodeId}`);
                }
                
                return true;
            } catch (error) {
                console.error(`[SafeMove] Failed to move node ${nodeId} to ${x}, ${y}:`, error);
                return false;
            }
        } else {
            console.warn(`[SafeMove] Invalid move parameters for node ${nodeId}: x=${x}, y=${y}`);
            return false;
        }
    }
    
    // Simple drag tracking for merge functionality
    let draggedNode = null;
    
    network.on("dragStart", function(params) {
        if (params.nodes.length > 0) {
            draggedNode = params.nodes[0];
        }
    });
    
    /* REMOVED COMPLEX DRAG HANDLING
        // Update check indicator and merge indicator positions for dragged nodes
        if (params.nodes.length > 0) {
            // Log current position of main dragged node
            const mainNode = params.nodes[0];
            const currentPos = network.getPositions([mainNode])[mainNode];
            if (!currentPos || isNaN(currentPos.x) || isNaN(currentPos.y)) {
                console.error('[Dragging] Invalid position detected for node:', mainNode, currentPos);
                // Try to recover by ensuring node is visible
                ensureNodeVisible(mainNode);
            }
            params.nodes.forEach(nodeId => {
                const checkNodeId = 'check_' + nodeId;
                const checkNode = nodes.get(checkNodeId);
                if (checkNode) {
                    const parentPos = network.getPositions([nodeId])[nodeId];
                    if (parentPos && !isNaN(parentPos.x) && !isNaN(parentPos.y)) {
                        safeMoveNode(checkNodeId, parentPos.x + 40, parentPos.y - 15);
                    }
                }
                
                // Merge indicators disabled
            });
        }
        
        // Handle group dragging for connected nodes or selected nodes
        if (isGroupDrag && draggedNode && params.nodes.length > 0) {
            // Calculate the movement delta
            const currentPos = network.getPositions([draggedNode])[draggedNode];
            const initialPos = initialPositions.get(draggedNode);
            
            if (currentPos && initialPos && !isNaN(currentPos.x) && !isNaN(currentPos.y) && !isNaN(initialPos.x) && !isNaN(initialPos.y)) {
                const deltaX = currentPos.x - initialPos.x;
                const deltaY = currentPos.y - initialPos.y;
                
                // Move all connected nodes by the same delta
                connectedNodeGroup.forEach(nodeId => {
                    if (nodeId !== draggedNode) { // The dragged node moves automatically
                        const nodeInitialPos = initialPositions.get(nodeId);
                        if (nodeInitialPos && !isNaN(nodeInitialPos.x) && !isNaN(nodeInitialPos.y)) {
                            const newX = nodeInitialPos.x + deltaX;
                            const newY = nodeInitialPos.y + deltaY;
                            if (!isNaN(newX) && !isNaN(newY)) {
                                safeMoveNode(nodeId, newX, newY);
                            }
                        }
                    }
                    
                    // Also move check indicators for connected nodes
                    const checkNodeId = 'check_' + nodeId;
                    const checkNode = nodes.get(checkNodeId);
                    if (checkNode) {
                        const nodePos = network.getPositions([nodeId])[nodeId];
                        if (nodePos && !isNaN(nodePos.x) && !isNaN(nodePos.y)) {
                            safeMoveNode(checkNodeId, nodePos.x + 40, nodePos.y - 15);
                        }
                    }
                    
                    // Merge indicators disabled
                });
                
                // Also move selected nodes if we're dragging multiple selected nodes
                if (selectedNodes.has(draggedNode) && selectedNodes.size > 1) {
                    selectedNodes.forEach(nodeId => {
                        if (nodeId !== draggedNode && !connectedNodeGroup.has(nodeId)) { // Don't double-move connected nodes
                            const nodeInitialPos = initialPositions.get(nodeId);
                            if (nodeInitialPos && !isNaN(nodeInitialPos.x) && !isNaN(nodeInitialPos.y)) {
                                const newX = nodeInitialPos.x + deltaX;
                                const newY = nodeInitialPos.y + deltaY;
                                if (!isNaN(newX) && !isNaN(newY)) {
                                    safeMoveNode(nodeId, newX, newY);
                                }
                            }
                        }
                    });
                }
            }
        }
    });*/
    
    network.on("dragEnd", function(params) {
        // Simple drag end - handle merge or cluster addition
        if (draggedNode && params.nodes.length > 0) {
            const draggedNodeId = draggedNode;
            
            // Get final position of dragged node
            const draggedPos = network.getPositions([draggedNodeId])[draggedNodeId];
            
            if (draggedPos) {
                // First check if we're over a cluster
                let targetClusterId = null;
                clusters.forEach((cluster, clusterId) => {
                    const clusterNode = nodes.get(clusterId);
                    if (clusterNode) {
                        // Check if dragged position is within cluster bounds
                        const halfWidth = cluster.width / 2;
                        const halfHeight = cluster.height / 2;
                        if (draggedPos.x >= cluster.x - halfWidth && 
                            draggedPos.x <= cluster.x + halfWidth &&
                            draggedPos.y >= cluster.y - halfHeight && 
                            draggedPos.y <= cluster.y + halfHeight) {
                            targetClusterId = clusterId;
                        }
                    }
                });
                
                if (targetClusterId) {
                    // Add node to cluster
                    const draggedNodeObj = nodes.get(draggedNodeId);
                    if (draggedNodeObj && !draggedNodeObj.clusterId) {
                        saveUndoState("Add node to cluster");
                        addNodesToCluster(targetClusterId, [draggedNodeId]);
                        updateStatus(`Added node to cluster`);
                    }
                    return;
                }
                
                // Otherwise check for node merging
                let targetNodeId = null;
                const allNodes = nodes.get();
                
                for (const node of allNodes) {
                    // Skip the dragged node itself, selected nodes, and cluster nodes
                    if (node.id === draggedNodeId || selectedNodes.has(node.id) || node.type === 'cluster' || node.type === 'cluster_inner') continue;
                    
                    const nodePos = network.getPositions([node.id])[node.id];
                    if (nodePos) {
                        // Calculate distance between centers
                        const dx = draggedPos.x - nodePos.x;
                        const dy = draggedPos.y - nodePos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If nodes are very close (within 50 pixels), consider it a merge
                        if (distance < 50) {
                            targetNodeId = node.id;
                            break;
                        }
                    }
                }
                
                if (targetNodeId) {
                    // Check if multiple nodes are selected
                    if (selectedNodes.size > 1) {
                        // Merge all selected nodes into the target
                        const nodesToMerge = Array.from(selectedNodes);
                        for (const nodeId of nodesToMerge) {
                            if (nodeId !== targetNodeId) {
                                mergeNodes(nodeId, targetNodeId);
                            }
                        }
                        updateStatus(`Merged ${nodesToMerge.length} selected nodes into target`);
                    } else {
                        // Single node merge
                        mergeNodes(draggedNodeId, targetNodeId);
                    }
                    
                    // Clear selection after merge
                    network.unselectAll();
                    selectedNodes.clear();
                }
            }
        }
        
        draggedNode = null;
    });
    
    // Track node selection changes
    network.on("selectNode", function(params) {
        selectedNodes.clear();
        params.nodes.forEach(nodeId => selectedNodes.add(nodeId));
        
        // Show anchor button if multiple nodes selected
        const anchorBtn = document.getElementById('anchorSelectedBtn');
        if (selectedNodes.size > 0) {
            anchorBtn.style.display = 'inline-block';
            
            // Check if all selected nodes are anchored
            let allAnchored = true;
            selectedNodes.forEach(nodeId => {
                if (!anchoredNodes.has(nodeId)) {
                    allAnchored = false;
                }
            });
            
            if (allAnchored) {
                anchorBtn.textContent = `Unanchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
            } else {
                anchorBtn.textContent = `Anchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
            }
        } else {
            anchorBtn.style.display = 'none';
        }
        
        // Update cluster buttons
        updateClusterButtons();
    });
    
    network.on("deselectNode", function(params) {
        selectedNodes.clear();
        const stillSelected = network.getSelectedNodes();
        stillSelected.forEach(nodeId => selectedNodes.add(nodeId));
        
        // Update anchor button
        const anchorBtn = document.getElementById('anchorSelectedBtn');
        if (selectedNodes.size > 0) {
            anchorBtn.style.display = 'inline-block';
            
            // Check if all selected nodes are anchored
            let allAnchored = true;
            selectedNodes.forEach(nodeId => {
                if (!anchoredNodes.has(nodeId)) {
                    allAnchored = false;
                }
            });
            
            if (allAnchored) {
                anchorBtn.textContent = `Unanchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
            } else {
                anchorBtn.textContent = `Anchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
            }
        } else {
            anchorBtn.style.display = 'none';
        }
        
        // Update cluster buttons
        updateClusterButtons();
    });
    
    /* REMOVED THE REST OF COMPLEX DRAG CODE */
    
    // Track node selections for AI chat with Command key support
    network.on("selectNode", function(params) {
        // Check if Command key (metaKey) is pressed for multi-selection
        const event = params.event?.srcEvent || params.event;
        const isMultiSelect = event && (event.metaKey || event.ctrlKey || event.shiftKey);
        
        if (!isMultiSelect && !isGroupDrag) {
            // For normal click, only select the clicked node
            selectedNodes.clear();
            network.unselectAll();
            if (params.nodes.length > 0) {
                const clickedNode = params.nodes[0];
                network.selectNodes([clickedNode]);
                selectedNodes.add(clickedNode);
            }
        } else if (!isGroupDrag) {
            // Multi-select mode
            params.nodes.forEach(nodeId => selectedNodes.add(nodeId));
        }
        // If isGroupDrag, the selection is handled by the hold timer
        
        updateChatInputWithSelection();
        
        // Show anchor button when nodes are selected
        const anchorBtn = document.getElementById('anchorSelectedBtn');
        if (selectedNodes.size > 0) {
            anchorBtn.style.display = 'inline-block';
            
            // Check if all selected nodes are anchored
            let allAnchored = true;
            selectedNodes.forEach(nodeId => {
                if (!anchoredNodes.has(nodeId)) {
                    allAnchored = false;
                }
            });
            
            if (allAnchored) {
                anchorBtn.textContent = `Unanchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
            } else {
                anchorBtn.textContent = `Anchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
            }
        }
        
        // Update cluster buttons
        updateClusterButtons();
    });
}

// Show WHOIS results dialog
async function showWhoisResultsDialog(whoisData, searchQuery, parentNodeId) {
    // Handle domain WHOIS results EXACTLY like the Python script
    if (whoisData.query_type === 'domain' && whoisData.records) {
        const records = whoisData.records;
        console.log(`Got ${records.length} WHOIS history records for ${searchQuery}`);
        
        // Combine ALL raw WHOIS text for Claude to analyze
        let allWhoisText = '';
        records.forEach((record, idx) => {
            if (record.rawText || record.cleanText) {
                allWhoisText += `\n\n=== WHOIS RECORD ${idx + 1} (${record.audit?.createdDate || 'Unknown Date'}) ===\n`;
                allWhoisText += record.cleanText || '';
                if (record.rawText) {
                    allWhoisText += '\n\n--- RAW TEXT ---\n' + record.rawText;
                }
            }
        });
        
        console.log('Sending ALL WHOIS data to Claude for analysis...');
        
        // Send ALL the WHOIS data to Claude at once
        try {
            const aiExtraction = await fetch('/api/extract-whois', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    whois_text: allWhoisText, 
                    domain: searchQuery 
                })
            });
            
            let suggestions = [{
                value: searchQuery,
                type: 'domain',
                source: 'WHOIS Domain Search',
                context: `Domain with ${records.length} historical WHOIS records`,
                parentNodeId: parentNodeId
            }];
            
            if (aiExtraction.ok) {
                const extracted = await aiExtraction.json();
                console.log(`Claude extracted ${extracted.entities?.length || 0} entities from ALL WHOIS data`);
                
                if (extracted.entities) {
                    extracted.entities.forEach(entity => {
                        suggestions.push({
                            value: entity.value,
                            type: entity.type,
                            source: 'WHOIS AI Extract',
                            context: entity.context,
                            parentNodeId: parentNodeId
                        });
                    });
                }
            }
            
            // Show the results dialog
            console.log('=== ABOUT TO SHOW WHOIS DIALOG ===');
            console.log('Suggestions:', suggestions);
            console.log('Search query:', searchQuery);
            console.log('Record count:', records.length);
            showWhoisExtractedDialog(suggestions, searchQuery, records.length);
            console.log('=== WHOIS DIALOG SHOULD BE VISIBLE NOW ===');
            
        } catch (error) {
            console.error('AI WHOIS extraction failed:', error);
            updateStatus('Failed to extract WHOIS data');
        }
        
        return;
    }
    
    // Handle reverse WHOIS results (original code)
    const results = whoisData.results || [];
    console.log('WHOIS Results:', results);
    console.log('Search query:', searchQuery);
    console.log('Parent node ID:', parentNodeId);
    
    // Extract all potential nodes from WHOIS results
    let suggestions = [];
    
    console.log(`Processing ${results.length} WHOIS results`);
    
    // Process only the first few WHOIS records to avoid overwhelming Claude
    const recordsToProcess = results.slice(0, 3); // Process first 3 records
    
    for (const result of recordsToProcess) {
        if (result.type === 'whois_domain' && result.raw_whois_text) {
            // ALWAYS add the domain node first
            if (result.domain) {
                suggestions.push({
                    value: result.domain,
                    type: 'domain',
                    source: 'WHOIS Domain',
                    context: `Domain from WHOIS search | Created: ${result.created || 'Unknown'} | Expires: ${result.expires || 'Unknown'}`,
                    data: result,
                    parentNodeId: parentNodeId // Keep track of parent
                });
            }
            
            // ONLY use AI to extract all information from WHOIS text
            console.log(`Using Claude to extract entities from ${result.domain} WHOIS data`);
            try {
                const aiExtraction = await fetch('/api/extract-whois', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ whois_text: result.raw_whois_text, domain: result.domain })
                });
                
                if (aiExtraction.ok) {
                    const extracted = await aiExtraction.json();
                    console.log(`Claude extracted ${extracted.entities?.length || 0} entities from ${result.domain}`);
                    if (extracted.entities) {
                        extracted.entities.forEach(entity => {
                            // Avoid duplicates
                            if (!suggestions.some(s => s.value === entity.value && s.type === entity.type)) {
                                suggestions.push({
                                    value: entity.value,
                                    type: entity.type,
                                    source: `WHOIS AI Extract - ${result.domain}`,
                                    context: entity.context || `Extracted from ${result.domain} WHOIS`,
                                    data: result,
                                    parentNodeId: parentNodeId // Keep track of parent
                                });
                            }
                        });
                    }
                } else {
                    console.error('AI extraction failed with status:', aiExtraction.status);
                }
            } catch (error) {
                console.error('AI WHOIS extraction failed:', error);
            }
        } else if (result.type === 'whois_reverse' && result.domains) {
            // For reverse WHOIS, we need to search each domain's historical WHOIS
            // This case should rarely happen now since server already fetches full data
            for (const domain of result.domains) {
                suggestions.push({
                    value: domain,
                    type: 'domain',
                    source: 'WHOIS Reverse Search',
                    context: `Domain associated with ${searchQuery}`,
                    data: result,
                    parentNodeId: parentNodeId, // Keep track of parent
                    searchHistorical: true // Flag to search historical WHOIS
                });
            }
        }
    }
    
    if (suggestions.length === 0) {
        updateStatus('No extractable data found in WHOIS results');
        console.log('No suggestions found in WHOIS data');
        return;
    }
    
    console.log(`Found ${suggestions.length} suggestions from WHOIS data`);
    
    // Show dialog with checkboxes for each suggestion
    const html = `
        <div class="modal" id="whoisResultsModal" style="display: block; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8);">
            <div class="modal-content" style="background-color: #1a1a1a; margin: 5% auto; padding: 20px; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto; border: 2px solid #666;">
                <h2 style="color: #20B2AA; margin-bottom: 20px;">🌐 WHOIS Search Results</h2>
                <p style="margin-bottom: 20px;">Found ${suggestions.length} data points from ${results.length} WHOIS records. Review and select which nodes to create:</p>
                
                <div style="margin-bottom: 20px;">
                    <button onclick="selectAllWhois(true)" style="background: #444; color: white; border: none; padding: 5px 15px; margin-right: 10px; border-radius: 3px; cursor: pointer;">Select All</button>
                    <button onclick="selectAllWhois(false)" style="background: #444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">Deselect All</button>
                </div>
                
                <div id="whoisSuggestionsList">
                    ${suggestions.map((suggestion, index) => {
                        const nodeColor = getNodeColor(suggestion.type);
                        return `
                            <div style="margin: 10px 0; padding: 10px; background: #222; border: 1px solid #444; border-radius: 5px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="whois_suggestion_${index}_enabled" checked style="margin-right: 10px;">
                                    <div style="flex: 1;">
                                        <span style="color: ${nodeColor}; font-weight: bold;">[${suggestion.type.toUpperCase()}]</span>
                                        <span style="color: #fff; margin-left: 10px;">${escapeHtml(suggestion.value)}</span>
                                        <div style="color: #888; font-size: 0.9em; margin-top: 5px;">
                                            Source: ${suggestion.source} | ${suggestion.context}
                                            ${suggestion.searchHistorical ? '<br><em>Will search historical WHOIS data for this domain</em>' : ''}
                                        </div>
                                    </div>
                                </label>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <details style="margin-top: 20px;">
                    <summary style="cursor: pointer; color: #20B2AA;">View Raw WHOIS Data</summary>
                    <pre style="background: #000; padding: 10px; margin-top: 10px; color: #888; overflow: auto; max-height: 300px;">${results.map(r => escapeHtml(r.raw_whois_text || JSON.stringify(r, null, 2))).join('\n\n---\n\n')}</pre>
                </details>
                
                <div style="margin-top: 20px; text-align: right;">
                    <button onclick="cancelWhoisResults()" style="background: #666; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">Cancel</button>
                    <button onclick="createWhoisNodes('${parentNodeId || ''}', ${suggestions.length})" style="background: #20B2AA; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Create Selected Nodes</button>
                </div>
            </div>
        </div>
    `;
    
    console.log('Inserting WHOIS results dialog into DOM');
    document.body.insertAdjacentHTML('beforeend', html);
    
    // Store suggestions for later use
    window.whoisSuggestions = suggestions;
    console.log('WHOIS dialog should now be visible');
}

// Show dialog with WHOIS extracted entities
function showWhoisExtractedDialog(suggestions, domain, recordCount) {
    console.log(`=== SHOWING WHOIS RESULTS DIALOG ===`);
    console.log(`Domain: ${domain}`);
    console.log(`Record count: ${recordCount}`);
    console.log(`Suggestions count: ${suggestions.length}`);
    console.log('Suggestions:', suggestions);
    
    const html = `
        <div class="modal" id="whoisResultsModal" style="display: block; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8);">
            <div class="modal-content" style="background-color: #1a1a1a; margin: 5% auto; padding: 20px; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto; border: 2px solid #666;">
                <h2 style="color: #20B2AA; margin-bottom: 20px;">🌐 WHOIS History Analysis for ${escapeHtml(domain)}</h2>
                <p style="margin-bottom: 20px;">Analyzed ${recordCount} historical WHOIS records. Claude extracted ${suggestions.length - 1} entities:</p>
                
                <div style="margin-bottom: 20px;">
                    <button onclick="selectAllWhois(true)" style="background: #444; color: white; border: none; padding: 5px 15px; margin-right: 10px; border-radius: 3px; cursor: pointer;">Select All</button>
                    <button onclick="selectAllWhois(false)" style="background: #444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">Deselect All</button>
                </div>
                
                <div id="whoisSuggestionsList">
                    ${suggestions.map((suggestion, index) => {
                        const nodeColor = getNodeColor(suggestion.type);
                        return `
                            <div style="margin: 10px 0; padding: 10px; background: #222; border: 1px solid #444; border-radius: 5px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="whois_suggestion_${index}_enabled" checked style="margin-right: 10px;">
                                    <div style="flex: 1;">
                                        <span style="color: ${nodeColor}; font-weight: bold;">[${suggestion.type.toUpperCase()}]</span>
                                        <span style="color: #fff; margin-left: 10px;">${escapeHtml(suggestion.value)}</span>
                                        <div style="color: #888; font-size: 0.9em; margin-top: 5px;">
                                            ${suggestion.context}
                                        </div>
                                    </div>
                                </label>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div style="margin-top: 20px; text-align: right;">
                    <button onclick="cancelWhoisResults()" style="background: #666; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">Cancel</button>
                    <button onclick="createWhoisNodes('${suggestions[0]?.parentNodeId || ''}', ${suggestions.length})" style="background: #20B2AA; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Create Selected Nodes</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', html);
    window.whoisSuggestions = suggestions;
    console.log('=== WHOIS DIALOG HTML INSERTED ===');
    console.log('Modal element exists:', !!document.getElementById('whoisResultsModal'));
}

// Helper functions for WHOIS dialog
window.selectAllWhois = function(checked) {
    const checkboxes = document.querySelectorAll('[id^="whois_suggestion_"][id$="_enabled"]');
    checkboxes.forEach(cb => cb.checked = checked);
}

// Helper function for AI suggestions
window.selectAllSuggestions = function(checked) {
    const checkboxes = document.querySelectorAll('[id^="suggestion-"]');
    checkboxes.forEach(cb => cb.checked = checked);
}

window.cancelWhoisResults = function() {
    const modal = document.getElementById('whoisResultsModal');
    if (modal) modal.remove();
    updateStatus('WHOIS results cancelled');
}

window.createWhoisNodes = async function(parentNodeId, suggestionCount) {
    const selectedSuggestions = [];
    
    for (let i = 0; i < suggestionCount; i++) {
        const checkbox = document.getElementById(`whois_suggestion_${i}_enabled`);
        if (checkbox && checkbox.checked && window.whoisSuggestions[i]) {
            selectedSuggestions.push(window.whoisSuggestions[i]);
        }
    }
    
    if (selectedSuggestions.length === 0) {
        updateStatus('No items selected');
        return;
    }
    
    // Remove modal
    const modal = document.getElementById('whoisResultsModal');
    if (modal) modal.remove();
    
    // Create nodes and search historical WHOIS for domains
    let createdCount = 0;
    const domainNodes = []; // Track domain nodes for historical searches
    
    for (const suggestion of selectedSuggestions) {
        // Use the parentNodeId from the suggestion if available
        const effectiveParentId = suggestion.parentNodeId || parentNodeId;
        
        const result = addNode({
            value: suggestion.value,
            label: suggestion.value,
            source: suggestion.source,
            context: suggestion.context,
            whoisData: suggestion.data
        }, suggestion.type, effectiveParentId);
        const nodeId = result?.nodeId;
        
        if (nodeId) {
            createdCount++;
            
            // Create a direct connection between parent and new node (for WHOIS relationships)
            if (effectiveParentId && nodeId !== effectiveParentId) {
                // Check if edge already exists
                const existingEdge = edges.get({
                    filter: edge => 
                        (edge.from === effectiveParentId && edge.to === nodeId) ||
                        (edge.from === nodeId && edge.to === effectiveParentId)
                });
                
                if (existingEdge.length === 0 && effectiveParentId !== nodeId) {
                    edges.add({
                        from: effectiveParentId,
                        to: nodeId,
                        color: {
                            color: '#20B2AA' // Teal for WHOIS connections
                        },
                        dashes: true,
                        width: 2,
                        title: `WHOIS connection: ${suggestion.source}`,
                        arrows: showArrows ? 'to' : ''
                    });
                }
            }
            
            // If this is a domain that needs historical WHOIS search
            if (suggestion.searchHistorical && suggestion.type === 'domain') {
                domainNodes.push({ nodeId, domain: suggestion.value });
            }
            
            // Save graph state after each node creation
            saveGraphState();
        }
    }
    
    // Process historical WHOIS searches for domains after all nodes are created
    for (const { nodeId, domain } of domainNodes) {
        updateStatus(`Searching historical WHOIS for ${domain}...`);
        const historicalWhois = await performWhoisSearch(domain, 'domain');
        if (historicalWhois && historicalWhois.results && historicalWhois.results.length > 0) {
            // Show dialog for historical results
            await showWhoisResultsDialog(historicalWhois, domain, nodeId);
        }
        // Add small delay between searches
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    updateStatus(`Created ${createdCount} nodes from WHOIS data`);
}

// Helper function for backward compatibility - returns just nodeId
function addNodeSimple(data, type, parentId = null, forceDuplicate = false) {
    const result = addNode(data, type, parentId, forceDuplicate);
    return result?.nodeId;
}

// Normalize phone numbers for similarity comparison
function normalizePhone(phone) {
    return phone.replace(/[^\d]/g, ''); // Remove all non-digits
}

// Normalize addresses for similarity comparison  
function normalizeAddress(address) {
    return address.toLowerCase()
        .replace(/\b(street|st|avenue|ave|road|rd|drive|dr|lane|ln|boulevard|blvd|court|ct)\b/g, '')
        .replace(/[^\w\s]/g, '') // Remove punctuation
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
}

// Normalize emails for similarity comparison
function normalizeEmail(email) {
    return email.toLowerCase().trim();
}

// Calculate similarity between two strings (0-1, 1 = identical)
function calculateSimilarity(str1, str2) {
    if (str1 === str2) return 1;
    
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1;
    
    // Calculate Levenshtein distance
    const editDistance = levenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
}

// Levenshtein distance algorithm
function levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

// Check for similar existing nodes
function findSimilarNodes(newValue, type) {
    const similarNodes = [];
    const allNodes = nodes.get();
    
    for (const existingNode of allNodes) {
        if (existingNode.type === type) {
            let similarity = 0;
            let normalizedNew, normalizedExisting;
            
            switch (type) {
                case 'phone':
                    normalizedNew = normalizePhone(newValue);
                    normalizedExisting = normalizePhone(existingNode.data.value);
                    
                    // High similarity if normalized phones match
                    if (normalizedNew === normalizedExisting) {
                        similarity = 1;
                    } else if (normalizedNew.length >= 7 && normalizedExisting.length >= 7) {
                        // Compare last 7+ digits for partial matches
                        const newSuffix = normalizedNew.slice(-7);
                        const existingSuffix = normalizedExisting.slice(-7);
                        if (newSuffix === existingSuffix) {
                            similarity = 0.9;
                        } else {
                            similarity = calculateSimilarity(normalizedNew, normalizedExisting);
                        }
                    }
                    break;
                    
                case 'address':
                    normalizedNew = normalizeAddress(newValue);
                    normalizedExisting = normalizeAddress(existingNode.data.value);
                    similarity = calculateSimilarity(normalizedNew, normalizedExisting);
                    break;
                    
                case 'email':
                    normalizedNew = normalizeEmail(newValue);
                    normalizedExisting = normalizeEmail(existingNode.data.value);
                    similarity = calculateSimilarity(normalizedNew, normalizedExisting);
                    break;
                    
                case 'name':
                    // Names are tricky - normalize and check
                    normalizedNew = newValue.toLowerCase().replace(/[^\w\s]/g, '').trim();
                    normalizedExisting = existingNode.data.value.toLowerCase().replace(/[^\w\s]/g, '').trim();
                    similarity = calculateSimilarity(normalizedNew, normalizedExisting);
                    break;
                    
                case 'username':
                    // Usernames should be exact or very similar
                    similarity = calculateSimilarity(newValue.toLowerCase(), existingNode.data.value.toLowerCase());
                    break;
                    
                default:
                    // For other types, basic string similarity
                    similarity = calculateSimilarity(newValue.toLowerCase(), existingNode.data.value.toLowerCase());
            }
            
            // Alert threshold: 0.6+ similarity but not exact match
            if (similarity >= 0.6 && similarity < 1.0) {
                similarNodes.push({
                    nodeId: existingNode.id,
                    value: existingNode.data.value,
                    similarity: similarity,
                    recommendAction: similarity >= 0.95 ? 'merge' : similarity >= 0.8 ? 'hypothetical' : 'review'
                });
            }
        }
    }
    
    return similarNodes.sort((a, b) => b.similarity - a.similarity);
}

// Show similarity alert dialog
function showSimilarityAlert(newValue, type, similarNodes, callback) {
    const html = `
        <div class="modal" id="similarityAlertModal" style="display: block; position: fixed; z-index: 15000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9);">
            <div class="modal-content" style="background-color: #1a1a1a; margin: 10% auto; padding: 20px; width: 70%; max-width: 600px; border: 3px solid #ff6600; border-radius: 10px;">
                <h2 style="color: #ff6600; margin-bottom: 20px;">⚠️ POTENTIAL DUPLICATE DETECTED</h2>
                <p style="color: #fff; margin-bottom: 15px;">The new <strong>${type.toUpperCase()}</strong> you're adding might be similar to existing nodes:</p>
                
                <div style="background: #222; padding: 15px; margin: 15px 0; border-radius: 5px;">
                    <strong style="color: #00ff00;">NEW:</strong> <span style="color: #fff;">${escapeHtml(newValue)}</span>
                </div>
                
                <div style="margin: 20px 0;">
                    <h3 style="color: #ff6600; margin-bottom: 10px;">Similar Existing Nodes:</h3>
                    ${similarNodes.map(node => `
                        <div style="background: #333; padding: 10px; margin: 8px 0; border-radius: 5px; border-left: 4px solid #ff6600;">
                            <strong style="color: #ffff00;">EXISTING:</strong> <span style="color: #fff;">${escapeHtml(node.value)}</span>
                            <div style="color: #888; font-size: 0.9em; margin-top: 5px;">
                                Similarity: ${(node.similarity * 100).toFixed(1)}%
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="background: #003366; padding: 15px; margin: 15px 0; border-radius: 5px; border-left: 4px solid #00BFFF;">
                    <strong style="color: #00BFFF;">💡 Recommendation:</strong>
                    <p style="color: #ccc; margin: 5px 0 0 0;">Review these similarities carefully. Consider merging nodes if they represent the same entity with different formatting.</p>
                </div>
                
                <div style="margin-top: 25px; text-align: center;">
                    <button onclick="handleSimilarityChoice('merge')" style="background: #ff6600; color: white; border: none; padding: 12px 25px; margin: 0 5px; border-radius: 5px; cursor: pointer; font-weight: bold;">MERGE WITH EXISTING</button>
                    <button onclick="handleSimilarityChoice('hypothetical')" style="background: #0066ff; color: white; border: none; padding: 12px 25px; margin: 0 5px; border-radius: 5px; cursor: pointer;">CREATE + HYPOTHETICAL LINK</button>
                    <button onclick="handleSimilarityChoice('create')" style="background: #006600; color: white; border: none; padding: 12px 25px; margin: 0 5px; border-radius: 5px; cursor: pointer;">CREATE SEPARATELY</button>
                    <button onclick="handleSimilarityChoice('cancel')" style="background: #666; color: white; border: none; padding: 12px 25px; margin: 0 5px; border-radius: 5px; cursor: pointer;">CANCEL</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', html);
    
    // Store callback for button handlers
    window.similarityCallback = callback;
    window.similarNodes = similarNodes;
}

// Handle user choice on similarity alert
window.handleSimilarityChoice = function(choice) {
    const modal = document.getElementById('similarityAlertModal');
    if (modal) modal.remove();
    
    if (window.similarityCallback) {
        window.similarityCallback(choice, window.similarNodes);
    }
    
    // Clean up
    delete window.similarityCallback;
    delete window.similarNodes;
};

// Add a node to the graph
function addNode(data, type, parentId = null, forceDuplicate = false) {
    // Create a unique key based on value and type
    const valueKey = `${type}_${data.value || data.label || data.id}`;
    
    // Check if node already exists (unless forcing duplicate)
    if (!forceDuplicate && valueToNodeMap.has(valueKey)) {
        const existingNodeId = valueToNodeMap.get(valueKey);
        
        // Store search relationship for query nodes
        if (parentId) {
            const searchKey = `${parentId}_search`;
            let searchData = nodeSearchQueries.get(searchKey) || {
                sourceNode: parentId,
                query: nodes.get(parentId)?.label,
                results: []
            };
            if (!searchData.results.includes(existingNodeId)) {
                searchData.results.push(existingNodeId);
            }
            nodeSearchQueries.set(searchKey, searchData);
        }
        
        updateStatus();
        return { nodeId: existingNodeId, isExisting: true };
    }
    
    // Check for similar nodes (but not exact matches)
    if (!forceDuplicate) {
        const newValue = data.value || data.label || data.id;
        const similarNodes = findSimilarNodes(newValue, type);
        
        if (similarNodes.length > 0) {
            // Auto-create hypothetical links for high similarity (80-95%)
            const autoLinkNodes = similarNodes.filter(n => n.similarity >= 0.8 && n.similarity < 0.95);
            
            if (autoLinkNodes.length > 0) {
                // Create new node first
                const newNodeResult = createNewNode();
                
                // Auto-create hypothetical links
                autoLinkNodes.forEach(similarNode => {
                    const reason = `Auto-detected similarity (${(similarNode.similarity * 100).toFixed(1)}% match)`;
                    createHypotheticalLink(newNodeResult.nodeId, similarNode.nodeId, reason);
                });
                
                updateStatus(`Created node with ${autoLinkNodes.length} hypothetical link(s)`);
                saveGraphState();
                return newNodeResult;
            }
            
            // Show alert for very high similarity (95%+) - likely merge candidates
            const mergeNodes = similarNodes.filter(n => n.similarity >= 0.95);
            if (mergeNodes.length > 0) {
                // Show alert and wait for user decision
                return new Promise((resolve) => {
                    showSimilarityAlert(newValue, type, mergeNodes, (choice, nodes) => {
                    if (choice === 'cancel') {
                        resolve(null);
                    } else if (choice === 'merge') {
                        // User chose to merge - return the most similar existing node
                        const targetNodeId = nodes[0].nodeId;
                        
                        // Store search relationship if needed
                        if (parentId) {
                            const searchKey = `${parentId}_search`;
                            let searchData = nodeSearchQueries.get(searchKey) || {
                                sourceNode: parentId,
                                query: nodes.get(parentId)?.label,
                                results: []
                            };
                            if (!searchData.results.includes(targetNodeId)) {
                                searchData.results.push(targetNodeId);
                            }
                            nodeSearchQueries.set(searchKey, searchData);
                        }
                        
                        resolve({ nodeId: targetNodeId, isExisting: true, wasMerged: true });
                    } else if (choice === 'hypothetical') {
                        // User chose hypothetical link - create new node and link it
                        const newNodeResult = createNewNode();
                        const targetNodeId = nodes[0].nodeId;
                        
                        // Create hypothetical link
                        setTimeout(() => {
                            const reason = `Similar to ${nodes[0].value} (${(nodes[0].similarity * 100).toFixed(1)}% match)`;
                            createHypotheticalLink(newNodeResult.nodeId, targetNodeId, reason);
                            saveGraphState();
                        }, 100);
                        
                        resolve(newNodeResult);
                    } else {
                        // User chose to create anyway - continue with normal creation
                        resolve(createNewNode());
                    }
                    });
                });
            }
        }
    }
    
    // Create new node (normal path)
    return createNewNode();
    
    function createNewNode() {
    
    const nodeId = `node_${nodeIdCounter++}`;
    const color = getNodeColor(type);
    
    // Create tooltip with field type and breach info
    let tooltip = `${type.toUpperCase()}: ${data.value || data.label || 'Unknown'}`;
    if (data.breach) {
        tooltip += `\n\nFound in: ${data.breach}`;
        if (data.breachData) {
            const bd = data.breachData;
            if (bd.breach_date) tooltip += `\nBreach Date: ${bd.breach_date}`;
            if (bd.added_date) tooltip += `\nAdded: ${bd.added_date}`;
            if (bd.source) tooltip += `\nSource: ${bd.source}`;
        }
    }
    
    // Calculate position with good spacing and NO OVERLAP
    let x, y;
    const minDistance = 400; // INCREASED minimum distance between any two nodes
    
    if (parentId && nodes.get(parentId)) {
        // Position relative to parent
        const parentNode = nodes.get(parentId);
        const parentPos = network ? network.getPositions([parentId])[parentId] : {x: 0, y: 0};
        
        // Calculate angle based on existing children
        const connectedToParent = edges.get({
            filter: edge => edge.from === parentId
        }).length;
        
        // Use more points in circle for better distribution
        const maxNodesInCircle = 16; // More slots for better spacing
        const angleStep = (2 * Math.PI) / maxNodesInCircle;
        let angle = connectedToParent * angleStep;
        let distance = 800; // Start with even larger distance
        
        // Find a position that doesn't overlap with existing nodes
        let attempts = 0;
        do {
            x = parentPos.x + distance * Math.cos(angle);
            y = parentPos.y + distance * Math.sin(angle);
            
            // Check if this position overlaps with any existing node
            const allPositions = network ? network.getPositions() : {};
            let tooClose = false;
            
            for (let existingId in allPositions) {
                if (existingId !== parentId) {
                    const existingPos = allPositions[existingId];
                    const dx = x - existingPos.x;
                    const dy = y - existingPos.y;
                    const distanceToExisting = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distanceToExisting < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
            }
            
            if (!tooClose) break;
            
            // Try next angle or increase distance
            attempts++;
            if (attempts % maxNodesInCircle === 0) {
                distance += 300; // Move further out faster
            }
            angle += angleStep;
            
        } while (attempts < 50); // Prevent infinite loop
        
    } else {
        // Position new root nodes in a grid pattern with larger spacing
        const gridSize = Math.ceil(Math.sqrt(nodes.length + 1));
        const index = nodes.length;
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        const spacing = 1000; // MASSIVE spacing between grid nodes
        
        x = col * spacing - (gridSize * spacing) / 2;
        y = row * spacing - (gridSize * spacing) / 2;
        
        // Add random offset to prevent perfect grid alignment
        x += (Math.random() - 0.5) * 300;
        y += (Math.random() - 0.5) * 300;
        
        // Final collision check for grid nodes
        const allPositions = network ? network.getPositions() : {};
        let finalAttempts = 0;
        while (finalAttempts < 20) {
            let tooClose = false;
            for (let existingId in allPositions) {
                const existingPos = allPositions[existingId];
                const dx = x - existingPos.x;
                const dy = y - existingPos.y;
                const distanceToExisting = Math.sqrt(dx * dx + dy * dy);
                
                if (distanceToExisting < minDistance) {
                    tooClose = true;
                    break;
                }
            }
            
            if (!tooClose) break;
            
            // Move to a completely different position
            x += (Math.random() - 0.5) * 1000;
            y += (Math.random() - 0.5) * 1000;
            finalAttempts++;
        }
    }
    
    const node = {
        id: nodeId,
        label: data.label || data.value || 'Unknown', // Full value, no truncation
        title: tooltip,
        color: {
            background: '#000000',  // Black background
            border: color,          // Colored border
            highlight: {
                background: '#1a1a1a',
                border: color
            }
        },
        data: {
            ...data,
            addedAt: Date.now() // Track when node was added
        },
        type: type,
        x: x,
        y: y,
        physics: false,  // Regular nodes don't move with physics
        // Remove fixed property - let vis.js handle it internally
        font: {
            color: '#666666',  // Bright green text
            multi: 'html',
            size: 12
        },
        shadow: false  // No shadow
    };
    
    nodes.add(node);
    
    // No temporary highlighting
    
    // Store in map for deduplication
    if (!forceDuplicate) {
        valueToNodeMap.set(valueKey, nodeId);
    }
    
    // Don't create search connections by default
    // These will be stored in query nodes instead
    if (parentId && parentId !== nodeId) {
        // Store the search relationship for later query node creation
        if (!nodeSearchQueries) {
            window.nodeSearchQueries = new Map();
        }
        
        const searchKey = `${parentId}_search`;
        let searchData = nodeSearchQueries.get(searchKey) || {
            sourceNode: parentId,
            query: nodes.get(parentId)?.label,
            results: [],
            timestamp: new Date().getTime()
        };
        searchData.results.push(nodeId);
        nodeSearchQueries.set(searchKey, searchData);
        
        // Update the parent node to show it has been searched
        const parentNode = nodes.get(parentId);
        if (parentNode) {
            nodes.update({
                id: parentId,
                searched: true
            });
        }
    }
    
    updateStatus();
    saveGraphState(); // Save after adding nodes
    return { nodeId: nodeId, isExisting: false };
    
    } // End of createNewNode function
}

// Get edge label based on parent and child nodes
function getEdgeLabel(fromId, toId) {
    const fromNode = nodes.get(fromId);
    const toNode = nodes.get(toId);
    
    if (!fromNode || !toNode) return '';
    
    // For consistency: arrows always point from container to contained
    // or from searcher to found
    return ''; // Remove labels for now - arrows speak for themselves
}

// Create connections for all nodes from the same breach record
function createValueBasedConnections(breach) {
    if (!breach) return;
    
    // Collect all nodes from this breach record
    const breachNodes = [];
    const fields = ['email', 'username', 'password', 'ip_address', 'phone', 'name', 'address', 'domain', 'vin'];
    
    // Gather all node IDs from this breach
    fields.forEach(field => {
        if (breach[field] && breach[field].length > 0) {
            breach[field].forEach(value => {
                const nodeId = valueToNodeMap.get(`${field}_${value}`);
                if (nodeId) {
                    breachNodes.push(nodeId);
                }
            });
        }
    });
    
    // Also check hashed passwords if they're included
    if (includeHashedPasswords && breach.hashed_password && breach.hashed_password.length > 0) {
        breach.hashed_password.forEach(hash => {
            const nodeId = valueToNodeMap.get(`hashed_password_${hash}`);
            if (nodeId) {
                breachNodes.push(nodeId);
            }
        });
    }
    
    // Connect all nodes from this breach record to each other
    // They're all from the same breach record, so they're all related
    for (let i = 0; i < breachNodes.length; i++) {
        for (let j = i + 1; j < breachNodes.length; j++) {
            const nodeId1 = breachNodes[i];
            const nodeId2 = breachNodes[j];
            
            // Create undirected edge (no arrows)
            const edgeId = `edge_${nodeId1}_${nodeId2}_breach`;
            const reverseEdgeId = `edge_${nodeId2}_${nodeId1}_breach`;
            
            // Check if edge already exists in either direction
            if (!edges.get(edgeId) && !edges.get(reverseEdgeId) && nodeId1 !== nodeId2) {
                const breachName = breach.database_name || 'Unknown';
                edges.add({
                    id: edgeId,
                    from: nodeId1,
                    to: nodeId2,
                    title: `Same breach record: ${breachName}`,
                    color: {
                        color: '#666666',
                        inherit: false
                    },
                    dashes: [5, 5],
                    width: 2,
                    arrows: {
                        to: { enabled: false },
                        from: { enabled: false }
                    }
                });
            }
        }
    }
}

// Get color based on node type
function getNodeColor(type) {
    const colors = {
        'email': '#00CED1',      // Dark turquoise
        'username': '#9370DB',    // Medium purple
        'password': '#FFFF00',    // YELLOW for passwords
        'hashed_password': '#FFD700', // Gold for hashes
        'ip_address': '#FFA500',  // Orange
        'phone': '#808080',       // Gray
        'domain': '#32CD32',      // Lime green
        'name': '#4169E1',        // Royal blue
        'address': '#8B4513',     // Saddle brown
        'vin': '#FF1493',         // Deep pink
        'company': '#00FF00',     // Bright green
        'dob': '#FF69B4',         // Hot pink
        'social': '#FF0000',      // Red
        'url': '#00FFFF'          // Cyan
    };
    return colors[type] || '#FFFFFF';
}

// Truncate label for display (disabled - show full text)
function truncateLabel(text) {
    if (!text) return 'Unknown';
    // Return full text - no truncation
    return text;
}

// Show node details in the info panel
// Get the query that found this node
function getQueryForNode(nodeId) {
    // Check all search queries to find which one resulted in this node
    for (let [searchKey, searchData] of nodeSearchQueries.entries()) {
        if (searchData.results && searchData.results.includes(nodeId)) {
            return searchData.query;
        }
    }
    return null;
}

function showNodeDetails(node) {
    if (!node) return;
    
    // Skip cluster nodes and cluster inner nodes
    if (node.type === 'cluster' || node.type === 'cluster_inner') {
        const detailsDiv = document.getElementById('node-details');
        detailsDiv.innerHTML = `
            <div style="padding: 20px;">
                <h3 style="color: #ff6600;">CLUSTER: ${node.label || node.id}</h3>
                <p>This is a cluster frame containing multiple nodes.</p>
                <p>Use the "Cluster Contents" checkbox to show/hide nodes inside.</p>
            </div>
        `;
        return;
    }
    
    // Initialize node.data if it doesn't exist
    if (!node.data) {
        node.data = {
            value: node.label,
            breach: 'Unknown'
        };
    }
    
    currentProfileNode = node;
    const detailsDiv = document.getElementById('node-details');
    
    // Get connected nodes
    const connectedEdges = edges.get({
        filter: edge => edge.from === node.id || edge.to === node.id
    });
    
    const connectedNodes = [];
    connectedEdges.forEach(edge => {
        const connectedId = edge.from === node.id ? edge.to : edge.from;
        const connectedNode = nodes.get(connectedId);
        if (connectedNode) {
            const nodeType = connectedNode.type || 'unknown';
            connectedNodes.push(`${nodeType}: ${escapeHtml(connectedNode.label)}`);
        }
    });
    
    // Ensure node has a type
    const nodeType = node.type || 'unknown';
    
    let html = `
        <div style="background: #0a0a0a; padding: 10px; border: 1px solid #00ff00;">
            <h3 style="margin: 0 0 10px 0; color: ${getNodeColor(nodeType)}">${nodeType.toUpperCase()}: ${escapeHtml(node.label)}</h3>
            
            <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                <strong>Type:</strong>
                <span style="display: inline-block; width: 12px; height: 12px; background: ${getNodeColor(nodeType)}; border-radius: 2px;"></span>
                <span style="color: ${getNodeColor(nodeType)}">${nodeType}</span>
                <button onclick="showChangeTypeMenu('${node.id}')" style="font-size: 11px; padding: 2px 8px; background: #004400; border: 1px solid #00ff00;">Change</button>
            </div>
            
            <div style="margin-bottom: 15px;">
                <strong>Primary Value:</strong> 
                <input type="text" id="node-primary-value" value="${escapeHtml(node.data?.value || node.label || '')}" 
                       style="width: 100%; background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; font-family: inherit;">
            </div>
            
            ${node.data?.variations && node.data.variations.length > 0 ? `
                <div style="margin-bottom: 15px; background: #001100; padding: 10px; border: 1px solid #003300;">
                    <strong>Variations (${node.data.variations.length}):</strong>
                    ${node.data.mergeHistory ? `<button onclick="showUnmergeOptions('${node.id}')" style="float: right; font-size: 11px;">Unmerge</button>` : ''}
                    <div style="clear: both; margin-top: 5px;">
                        ${node.data.variations.map((v, idx) => `
                            <div style="padding: 5px; margin: 5px 0; background: #000; border: 1px solid #003300;">
                                <span style="color: ${getNodeColor(v.type)}">${v.type}:</span>
                                <input type="text" id="variation-${idx}" value="${escapeHtml(v.value)}" 
                                       style="width: 70%; background: #000; color: #0f0; border: 1px solid #0f0; padding: 2px; font-family: inherit;">
                                <br><small style="color: #888;">From: ${v.breach || 'Unknown'} • ${v.mergedAt ? new Date(v.mergedAt).toLocaleDateString() : ''}</small>
                                ${v.notes ? `<br><small style="color: #888;">Notes: ${escapeHtml(v.notes)}</small>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
            
            <div style="margin-bottom: 15px;">
                <strong>Found in:</strong> <span style="color: #ff0000">${escapeHtml(node.data?.breach || 'Unknown')}</span>
                ${node.data?.breachData?.breach_date ? `<br><small>Breach Date: ${node.data.breachData.breach_date}</small>` : ''}
            </div>
            
            ${getQueryForNode(node.id) ? `
                <div style="margin-bottom: 15px; background: #330000; padding: 10px; border: 2px solid #ff0000;">
                    <strong style="color: #ff0000;">Found by Query:</strong><br>
                    <div style="background: #000000; padding: 8px; border: 1px solid #ff0000; margin-top: 5px;">
                        <span style="color: #ff0000; font-family: monospace;">${escapeHtml(getQueryForNode(node.id))}</span>
                    </div>
                </div>
            ` : ''}
            
            <div style="margin-bottom: 15px;">
                <strong>Connected to (${connectedNodes.length}):</strong>
                <div style="max-height: 150px; overflow-y: auto; margin-top: 5px;">
                    ${connectedNodes.length > 0 ? connectedNodes.map(n => `<div style="padding: 2px 0;">• ${n}</div>`).join('') : '<div>No connections</div>'}
                </div>
            </div>
            
            ${(() => {
                // Check for merged images
                let mergedImages = [];
                if (node.data.mergedImages && node.data.mergedImages.length > 0) {
                    mergedImages = node.data.mergedImages;
                } else if (node.data.variations && node.data.variations.length > 0) {
                    // Check variations for image nodes
                    node.data.variations.forEach(v => {
                        if (v.type === 'image' && v.dataURL) {
                            mergedImages.push({ dataURL: v.dataURL, mergedAt: v.mergedAt });
                        }
                    });
                }
                
                return mergedImages.length > 0 ? `
                    <div style="margin-bottom: 15px; background: #001100; padding: 10px; border: 1px solid #00ff00;">
                        <strong>Merged Images (${mergedImages.length}):</strong>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
                            ${mergedImages.map((img, idx) => `
                                <div style="border: 2px solid #00ff00; padding: 5px;">
                                    <img src="${img.dataURL}" style="max-width: 200px; max-height: 200px; cursor: pointer;" 
                                         onclick="window.open('${img.dataURL}', '_blank')" 
                                         title="Click to view full size">
                                    ${img.mergedAt ? `<br><small style="color: #888;">Merged: ${new Date(img.mergedAt).toLocaleDateString()}</small>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : '';
            })()}
            
            <div>
                <strong>Notes:</strong><br>
                <textarea id="node-notes" style="width: 100%; height: 100px; background: #000; color: #0f0; border: 1px solid #0f0; font-family: inherit; margin-top: 5px;" placeholder="Add notes here...">${escapeHtml(node.data.notes || '')}</textarea>
                <button onclick="saveNodeDetails('${node.id}')" style="margin-top: 5px;">Save All Changes</button>
                <button onclick="showChangeTypeMenu('${node.id}')" style="margin-top: 5px; margin-left: 10px; background: #004400; border: 1px solid #00ff00;">Change Type</button>
            </div>
        </div>
    `;
    
    detailsDiv.innerHTML = html;
}

// Expand a node (search for related data)
async function expandNode(node) {
    console.log('expandNode called with:', node);
    
    // Ensure node has data property
    if (!node) {
        console.error('expandNode: No node provided');
        return;
    }
    
    if (!node.data) {
        console.log('Node missing data property, creating from label/title');
        node.data = {
            value: node.label || node.title || node.id,
            label: node.label || node.title || node.id
        };
    }
    
    // Check if this node has already been expanded
    const nodeKey = `${node.id}_${node.type}_${node.data.value || node.data.label}`;
    if (nodeExpansionCache.has(nodeKey)) {
        updateStatus('Node already searched - double-click search indicator to view query');
        
        // Redraw search indicators to make sure it's visible
        clearSearchIndicators();
        drawSearchIndicators();
        return;
    }
    
    // If AI suggestions are enabled, show suggestions modal first
    if (aiSuggestionsEnabled) {
        updateStatus('Generating AI suggestions...');
        
        try {
            const suggestions = await generateAISuggestions(node.data.value || node.label, node.type);
            
            if (suggestions && suggestions.length > 0) {
                showAISuggestionsModal(suggestions, node);
                return; // Let user choose what to search
            } else {
                updateStatus('No AI suggestions available, proceeding with normal search');
            }
        } catch (error) {
            console.error('AI suggestions failed:', error);
            updateStatus('AI suggestions failed, proceeding with normal search');
        }
    }
    
    // Normal expansion (when AI is disabled or no suggestions)
    updateStatus('Expanding node...');
    
    // Special handling for domain nodes
    if (node.type === 'domain') {
        await handleDomainNodeExpansion(node);
        return;
    }
    
    // Determine what to search for based on the node type
    let searchQueries = [];
    
    // For any data node, search for its value
    if (node.data && node.data.value) {
        // 1. FIRST: Search in its own category
        searchQueries.push({ 
            value: node.data.value, 
            type: node.type,
            priority: 1,
            description: `Searching as ${node.type}`
        });
        
        // 2. OSINT SEARCH: For email and phone nodes, add OSINT search
        if (node.type === 'email' || node.type === 'phone') {
            searchQueries.push({ 
                value: node.data.value, 
                type: 'osint',
                priority: 2,
                description: `OSINT Industries search for ${node.type}`
            });
        }
        
        // 3. THEN: Search in other categories (blanket search)
        searchQueries.push({ 
            value: node.data.value, 
            type: 'blanket_search',
            priority: 3,
            description: 'Searching in all fields'
        });
        
        // 4. Add any variations if they exist
        if (node.data.variations && node.data.variations.length > 0) {
            node.data.variations.forEach((variation, idx) => {
                searchQueries.push({ 
                    value: variation.value, 
                    type: variation.type || 'blanket_search',
                    priority: 4 + idx,
                    description: `Searching variation: ${variation.value}`
                });
            });
        }
    }
    
    // Perform searches for each query in priority order
    let hasNewResults = false;
    searchQueries.sort((a, b) => a.priority - b.priority);
    
    for (const query of searchQueries) {
        updateStatus(query.description);
        const result = await performSearch(query.value, query.type, node.id);
        if (result) hasNewResults = true;
    }
    
    // Mark this node as expanded only if we got results
    if (hasNewResults) {
        nodeExpansionCache.set(nodeKey, true);
    }
    
    updateStatus('Ready');
}

// Handle domain node expansion (REVERSE WHOIS + DeHashed email search)
async function handleDomainNodeExpansion(node) {
    const domain = node.data.value || node.label;
    console.log('=== DOMAIN REVERSE SEARCH START ===');
    console.log('Reverse searching domain:', domain);
    updateStatus(`Reverse searching domain: ${domain}...`);
    
    // Mark as expanded
    const nodeKey = `${node.id}_${node.type}_${domain}`;
    nodeExpansionCache.set(nodeKey, true);
    
    try {
        // First get domain's current WHOIS to extract registrant info
        updateStatus(`Getting ${domain} WHOIS for reverse search...`);
        const domainWhois = await performWhoisSearch(domain, 'domain');
        
        if (!domainWhois || !domainWhois.records || domainWhois.records.length === 0) {
            updateStatus(`No WHOIS data found for ${domain} - cannot perform reverse search`);
            return;
        }
        
        // Extract registrant info from the domain's WHOIS
        const latestRecord = domainWhois.records[0];
        const registrantContact = latestRecord.registrantContact || {};
        
        // Build search terms for reverse WHOIS
        const searchTerms = [];
        if (registrantContact.email && !registrantContact.email.includes('privacy') && !registrantContact.email.includes('redacted')) {
            searchTerms.push({ value: registrantContact.email, type: 'email' });
        }
        if (registrantContact.name && !registrantContact.name.includes('privacy') && !registrantContact.name.includes('redacted')) {
            searchTerms.push({ value: registrantContact.name, type: 'terms' });
        }
        if (registrantContact.organization && !registrantContact.organization.includes('privacy') && !registrantContact.organization.includes('redacted')) {
            searchTerms.push({ value: registrantContact.organization, type: 'terms' });
        }
        
        if (searchTerms.length === 0) {
            updateStatus(`${domain} WHOIS data is privacy protected - trying domain history anyway...`);
            // Fall back to showing domain history
            await showWhoisResultsDialog(domainWhois, domain, node.id);
            return;
        }
        
        // Perform REVERSE WHOIS searches for each term
        updateStatus(`Found ${searchTerms.length} search terms - performing reverse WHOIS...`);
        const reversePromises = searchTerms.map(term => performWhoisSearch(term.value, term.type));
        
        // Also search DeHashed for emails with this domain
        const emailSearchPromise = performSearch(`@${domain}`, 'email', node.id);
        
        // Wait for all searches to complete
        const [emailSearchResult, ...reverseResults] = await Promise.all([emailSearchPromise, ...reversePromises]);
        
        // Combine all WHOIS results
        let allDomains = new Set([domain]); // Include original domain
        let allWhoisResults = [];
        
        for (let i = 0; i < reverseResults.length; i++) {
            const result = reverseResults[i];
            const searchTerm = searchTerms[i];
            
            if (result && result.results) {
                console.log(`Reverse WHOIS for ${searchTerm.value} found ${result.results.length} domains`);
                result.results.forEach(r => {
                    if (r.domain) allDomains.add(r.domain);
                });
                allWhoisResults.push(...result.results);
            }
        }
        
        console.log(`Total unique domains found: ${allDomains.size}`);
        updateStatus(`Found ${allDomains.size} domains associated with ${domain} registrant`);
        
        // Show results dialog with all found domains
        if (allWhoisResults.length > 0) {
            const combinedResult = {
                results: allWhoisResults,
                query: domain,
                query_type: 'reverse_domain'
            };
            await showWhoisResultsDialog(combinedResult, domain, node.id);
        } else {
            updateStatus(`No additional domains found for ${domain} registrant`);
        }
        
    } catch (error) {
        console.error('Error during domain reverse search:', error);
        updateStatus(`Error reverse searching domain: ${error.message}`);
    }
    
    console.log('=== DOMAIN REVERSE SEARCH END ===');
}

// Check if query should be searched in WHOIS
function isWhoisCandidate(query, type) {
    // If type is explicitly set, check if it's a whois-able type
    if (type) {
        return type === 'email' || type === 'phone' || type === 'name' || type === 'company';
    }
    
    // Auto-detect if type not provided
    if (/@/.test(query)) {
        return true; // Email
    } else if (/^\+?\d[\d\s\-\(\)\.]{6,}$/.test(query.trim())) {
        return true; // Phone
    } else if (/^[a-zA-Z\s]{3,}$/.test(query) && query.split(' ').length >= 2) {
        return true; // Name (at least two words)
    }
    
    return false;
}

// Perform WHOIS search
async function performWhoisSearch(query, type) {
    try {
        console.log('performWhoisSearch called with:', { query, type });
        updateStatus(`🌐 Searching WHOIS for ${query}...`);
        
        const requestBody = { query, type };
        console.log('Sending WHOIS request:', requestBody);
        
        const response = await fetch('/api/whois', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        
        console.log('WHOIS response status:', response.status);
        
        if (!response.ok) {
            console.error('WHOIS search failed:', response.status);
            const errorText = await response.text();
            console.error('Error response:', errorText);
            return null;
        }
        
        const data = await response.json();
        console.log('WHOIS response data:', data);
        
        if (data.error) {
            console.error('WHOIS error:', data.error);
            updateStatus('WHOIS search failed: ' + data.error);
            return null;
        }
        
        return data;
    } catch (error) {
        console.error('WHOIS search error:', error);
        updateStatus('WHOIS search error');
        return null;
    }
}

// Perform OSINT search
async function performOSINTSearch(query, type) {
    try {
        console.log('performOSINTSearch called with:', { query, type });
        updateStatus(`🔍 Searching OSINT Industries for ${query}...`);
        
        const requestBody = { query, type };
        console.log('Sending OSINT request:', requestBody);
        
        const response = await fetch('/api/osint', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        
        console.log('OSINT response status:', response.status);
        
        if (!response.ok) {
            console.error('OSINT search failed:', response.status);
            const errorText = await response.text();
            console.error('Error response:', errorText);
            return null;
        }
        
        const data = await response.json();
        console.log('OSINT response data:', data);
        
        if (data.error) {
            console.error('OSINT error:', data.error);
            updateStatus('OSINT search failed: ' + data.error);
            return null;
        }
        
        return data;
    } catch (error) {
        console.error('OSINT search error:', error);
        updateStatus('OSINT search error');
        return null;
    }
}

// Handle OSINT Industries search
async function handleOSINTSearch(query, parentNodeId = null) {
    try {
        updateStatus(`🔍 Searching OSINT Industries for ${query}...`);
        
        // Auto-detect query type for OSINT
        let osintType = 'email';
        if (query.includes('@')) {
            osintType = 'email';
        } else if (/^\+?\d[\d\s\-\(\)\.]{6,}$/.test(query.trim())) {
            osintType = 'phone';
        }
        
        let searchQueries = [query]; // Start with original query
        
        // For phone numbers, generate local variations using Claude AI
        if (osintType === 'phone') {
            updateStatus(`🔍 Generating phone number variations for OSINT search...`);
            
            try {
                const phoneVariations = await generatePhoneVariations(query);
                if (phoneVariations && phoneVariations.length > 0) {
                    // Add variations but avoid duplicates
                    phoneVariations.forEach(variation => {
                        if (!searchQueries.includes(variation)) {
                            searchQueries.push(variation);
                        }
                    });
                    console.log(`Generated ${phoneVariations.length} phone variations:`, phoneVariations);
                }
            } catch (error) {
                console.warn('Failed to generate phone variations:', error);
                // Continue with original query if variation generation fails
            }
        }
        
        // Search OSINT for each query variation
        const allOsintData = { entities: [], raw_results: [] };
        let searchCount = 0;
        
        for (const searchQuery of searchQueries) {
            updateStatus(`🔍 OSINT search ${++searchCount}/${searchQueries.length}: ${searchQuery}...`);
            
            try {
                const osintData = await performOSINTSearch(searchQuery, osintType);
                
                if (osintData && osintData.entities) {
                    // Merge entities, avoiding duplicates
                    osintData.entities.forEach(entity => {
                        if (!allOsintData.entities.some(existing => 
                            existing.value === entity.value && existing.type === entity.type)) {
                            allOsintData.entities.push({
                                ...entity,
                                context: `${entity.context} (searched: ${searchQuery})`
                            });
                        }
                    });
                }
                
                if (osintData && osintData.raw_results) {
                    allOsintData.raw_results.push(...osintData.raw_results);
                }
                
                // Small delay between searches to avoid rate limiting
                if (searchCount < searchQueries.length) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } catch (error) {
                console.warn(`OSINT search failed for ${searchQuery}:`, error);
            }
        }
        
        if (!allOsintData.entities || allOsintData.entities.length === 0) {
            updateStatus(`No OSINT results found for ${query} or its variations`);
            return false;
        }
        
        console.log(`Claude extracted ${allOsintData.entities.length} total entities from OSINT data across ${searchQueries.length} variations`);
        
        // Show OSINT results dialog for user approval
        showOSINTResultsDialog(allOsintData, query, parentNodeId);
        
        return true;
    } catch (error) {
        console.error('OSINT search error:', error);
        updateStatus(`OSINT search failed: ${error.message}`);
        return false;
    }
}

// Show OSINT results dialog
function showOSINTResultsDialog(osintData, query, parentNodeId) {
    console.log(`Showing OSINT results dialog with ${osintData.entities.length} entities`);
    
    const html = `
        <div class="modal" id="osintResultsModal" style="display: block; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8);">
            <div class="modal-content" style="background-color: #1a1a1a; margin: 5% auto; padding: 20px; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto; border: 2px solid #666;">
                <h2 style="color: #00BFFF; margin-bottom: 20px;">🔍 OSINT Industries Results for: ${escapeHtml(query)}</h2>
                <p style="margin-bottom: 20px;">Found ${osintData.total_results || 0} total results across platforms. Claude extracted ${osintData.entities.length} relevant entities:</p>
                
                <div style="margin-bottom: 20px;">
                    <button onclick="selectAllOSINT(true)" style="background: #444; color: white; border: none; padding: 5px 15px; margin-right: 10px; border-radius: 3px; cursor: pointer;">Select All</button>
                    <button onclick="selectAllOSINT(false)" style="background: #444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">Deselect All</button>
                </div>
                
                <div id="osintSuggestionsList">
                    ${osintData.entities.map((entity, index) => {
                        const nodeColor = getNodeColor(entity.type);
                        return `
                            <div style="margin: 10px 0; padding: 15px; background: #222; border: 1px solid #444; border-radius: 5px;">
                                <div style="display: flex; align-items: flex-start; gap: 10px;">
                                    <input type="checkbox" id="osint_entity_${index}_enabled" checked style="margin-top: 5px;">
                                    
                                    <div style="flex: 1;">
                                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                                            <label style="color: #aaa; font-size: 0.9em; min-width: 40px;">Type:</label>
                                            <select id="osint_entity_${index}_type" style="background: #333; color: #fff; border: 1px solid #555; padding: 3px; border-radius: 3px;">
                                                <option value="email" ${entity.type === 'email' ? 'selected' : ''}>Email</option>
                                                <option value="phone" ${entity.type === 'phone' ? 'selected' : ''}>Phone</option>
                                                <option value="name" ${entity.type === 'name' ? 'selected' : ''}>Name</option>
                                                <option value="username" ${entity.type === 'username' ? 'selected' : ''}>Username</option>
                                                <option value="company" ${entity.type === 'company' ? 'selected' : ''}>Company</option>
                                                <option value="address" ${entity.type === 'address' ? 'selected' : ''}>Address</option>
                                                <option value="url" ${entity.type === 'url' ? 'selected' : ''}>URL</option>
                                                <option value="other" ${entity.type === 'other' ? 'selected' : ''}>Other</option>
                                            </select>
                                        </div>
                                        
                                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                                            <label style="color: #aaa; font-size: 0.9em; min-width: 40px;">Value:</label>
                                            <input type="text" id="osint_entity_${index}_value" value="${escapeHtml(entity.value)}" 
                                                   style="flex: 1; background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 3px;">
                                        </div>
                                        
                                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: flex-start;">
                                            <label style="color: #aaa; font-size: 0.9em; min-width: 40px; margin-top: 5px;">Notes:</label>
                                            <textarea id="osint_entity_${index}_notes" rows="2" placeholder="Add any notes about this entity..."
                                                      style="flex: 1; background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 3px; resize: vertical;">${escapeHtml(entity.context || '')}</textarea>
                                        </div>
                                        
                                        <div style="color: #666; font-size: 0.8em; margin-top: 5px;">
                                            Source: ${entity.context}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    
                    ${osintData.notes && osintData.notes.length > 0 ? `
                        <div style="margin: 20px 0; padding: 15px; background: #001122; border: 1px solid #004466; border-radius: 5px;">
                            <h3 style="color: #00BFFF; margin-bottom: 15px;">📝 Suggested Notes from Claude:</h3>
                            ${osintData.notes.map((note, index) => `
                                <div style="margin: 10px 0; padding: 10px; background: #002233; border: 1px solid #003355; border-radius: 3px;">
                                    <div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                                        <input type="checkbox" id="osint_note_${index}_enabled" checked style="margin: 0;">
                                        <label style="color: #aaa; font-size: 0.9em; min-width: 60px;">For Node:</label>
                                        <input type="text" id="osint_note_${index}_target" value="${escapeHtml(note.for_node || '')}" 
                                               style="flex: 1; background: #333; color: #fff; border: 1px solid #555; padding: 3px; border-radius: 3px;" placeholder="Target node value">
                                    </div>
                                    <div style="display: flex; gap: 10px; align-items: flex-start;">
                                        <label style="color: #aaa; font-size: 0.9em; min-width: 60px; margin-top: 5px;">Note:</label>
                                        <textarea id="osint_note_${index}_content" rows="2" 
                                                  style="flex: 1; background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 3px; resize: vertical;">${escapeHtml(note.note || '')}</textarea>
                                    </div>
                                    <div style="color: #666; font-size: 0.8em; margin-top: 5px;">
                                        Context: ${note.context || 'N/A'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
                
                <details style="margin-top: 20px;">
                    <summary style="cursor: pointer; color: #00BFFF;">View Raw OSINT Data (${osintData.total_results || 0} results)</summary>
                    <pre style="background: #000; padding: 10px; margin-top: 10px; color: #888; overflow: auto; max-height: 300px;">${JSON.stringify(osintData.raw_results || [], null, 2)}</pre>
                </details>
                
                <div style="margin-top: 20px; text-align: right;">
                    <button onclick="cancelOSINTResults()" style="background: #666; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">Cancel</button>
                    <button onclick="createOSINTNodes('${parentNodeId || ''}', ${osintData.entities.length})" style="background: #00BFFF; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Create Selected Nodes</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', html);
    window.osintEntities = osintData.entities;
}

// Helper functions for OSINT dialog
window.selectAllOSINT = function(checked) {
    const checkboxes = document.querySelectorAll('[id^="osint_entity_"][id$="_enabled"]');
    checkboxes.forEach(cb => cb.checked = checked);
}

window.cancelOSINTResults = function() {
    const modal = document.getElementById('osintResultsModal');
    if (modal) modal.remove();
    updateStatus('OSINT results cancelled');
}

window.createOSINTNodes = async function(parentNodeId, entityCount) {
    const selectedEntities = [];
    const selectedNotes = [];
    
    // Collect edited entity data from form fields
    for (let i = 0; i < entityCount; i++) {
        const checkbox = document.getElementById(`osint_entity_${i}_enabled`);
        const typeSelect = document.getElementById(`osint_entity_${i}_type`);
        const valueInput = document.getElementById(`osint_entity_${i}_value`);
        const notesTextarea = document.getElementById(`osint_entity_${i}_notes`);
        
        if (checkbox && checkbox.checked && typeSelect && valueInput) {
            selectedEntities.push({
                type: typeSelect.value,
                value: valueInput.value.trim(),
                context: notesTextarea ? notesTextarea.value.trim() : '',
                originalData: window.osintEntities[i] // Keep reference to original
            });
        }
    }
    
    // Collect selected notes from Claude suggestions
    const noteCheckboxes = document.querySelectorAll('[id^="osint_note_"][id$="_enabled"]');
    noteCheckboxes.forEach((checkbox, index) => {
        if (checkbox.checked) {
            const targetInput = document.getElementById(`osint_note_${index}_target`);
            const contentTextarea = document.getElementById(`osint_note_${index}_content`);
            
            if (targetInput && contentTextarea && targetInput.value.trim() && contentTextarea.value.trim()) {
                selectedNotes.push({
                    targetNode: targetInput.value.trim(),
                    content: contentTextarea.value.trim()
                });
            }
        }
    });
    
    if (selectedEntities.length === 0 && selectedNotes.length === 0) {
        updateStatus('No entities or notes selected');
        return;
    }
    
    // Remove modal
    const modal = document.getElementById('osintResultsModal');
    if (modal) modal.remove();
    
    // Create nodes for selected entities
    let createdCount = 0;
    const createdNodeIds = [];
    
    for (const entity of selectedEntities) {
        try {
            const result = await addNode({
                value: entity.value,
                label: entity.value,
                source: 'OSINT Industries',
                context: entity.context,
                osintData: entity
            }, entity.type, parentNodeId);
            
            if (result && result.nodeId) {
                if (!result.isExisting) {
                    createdCount++;
                }
                createdNodeIds.push(result.nodeId);
                
                // Link to the source node that was searched
                if (parentNodeId) {
                    const edgeLabel = result.isExisting ? 
                        (result.wasMerged ? 'OSINT merged' : 'OSINT confirmed') : 
                        'OSINT found';
                    const edgeId = `edge_${parentNodeId}_${result.nodeId}_osint`;
                    
                    // Check if edge already exists
                    const existingEdge = edges.get({
                        filter: edge => (edge.from === parentNodeId && edge.to === result.nodeId) ||
                                       (edge.from === result.nodeId && edge.to === parentNodeId)
                    });
                    
                    if (existingEdge.length === 0 && parentNodeId !== result.nodeId) {
                        edges.add({
                            id: edgeId,
                            from: parentNodeId,
                            to: result.nodeId,
                            title: edgeLabel,
                            color: { color: '#00BFFF' },
                            width: 3,
                            arrows: { to: { enabled: false } }
                        });
                    }
                }
            }
        } catch (error) {
            console.error('Error creating OSINT node:', error);
        }
    }
    
    // Group entities by their source/context and link nodes from the same profile
    const profileGroups = new Map();
    selectedEntities.forEach((entity, index) => {
        const nodeId = createdNodeIds[index];
        if (nodeId) {
            // Group by context/source platform
            const contextKey = entity.context.split(' ').slice(0, 2).join(' '); // First two words as grouping key
            if (!profileGroups.has(contextKey)) {
                profileGroups.set(contextKey, []);
            }
            profileGroups.get(contextKey).push({ nodeId, entity });
        }
    });
    
    // Link nodes within each profile group
    let linkCount = 0;
    profileGroups.forEach((group, context) => {
        if (group.length > 1) {
            // Create edges between all nodes in the same profile group
            for (let i = 0; i < group.length; i++) {
                for (let j = i + 1; j < group.length; j++) {
                    const edgeId = `edge_${group[i].nodeId}_${group[j].nodeId}_osint_profile`;
                    // Check if edge already exists
                    const existingEdge = edges.get({
                        filter: edge => (edge.from === group[i].nodeId && edge.to === group[j].nodeId) ||
                                       (edge.from === group[j].nodeId && edge.to === group[i].nodeId)
                    });
                    
                    if (existingEdge.length === 0) {
                        edges.add({
                            id: edgeId,
                            from: group[i].nodeId,
                            to: group[j].nodeId,
                            title: `shared profile: ${context}`,
                            color: { color: '#00BFFF' },
                            width: 2,
                            arrows: { to: { enabled: false } }
                        });
                    }
                    linkCount++;
                }
            }
        }
    });
    
    const connectedCount = createdNodeIds.length - createdCount;
    let statusMsg = `OSINT Industries: `;
    if (createdCount > 0) statusMsg += `created ${createdCount} new nodes`;
    if (connectedCount > 0) {
        if (createdCount > 0) statusMsg += `, `;
        statusMsg += `connected to ${connectedCount} existing nodes`;
    }
    if (linkCount > 0) statusMsg += `, added ${linkCount} profile connections`;
    updateStatus(statusMsg);
    saveGraphState();
}

// Perform a search
async function performSearch(query, type = null, parentNodeId = null) {
    if (!query) return false;
    
    // Handle OSINT searches separately
    if (type === 'osint') {
        return await handleOSINTSearch(query, parentNodeId);
    }
    
    // Check cache first
    const cacheKey = `${query}_${type || 'auto'}`;
    if (searchCache.has(cacheKey)) {
        const cachedData = searchCache.get(cacheKey);
        updateStatus(`Using cached results for ${query}`);
        
        // If no parent node, don't create a search node - just process results without parent
        // This means initial searches won't have a parent node
        
        // Process cached results
        if (cachedData.results && cachedData.results.length > 0) {
            processCachedResults(cachedData.results, parentNodeId);
            updateStatus(`Found ${cachedData.results.length} breaches (cached)`);
            return true;
        } else {
            updateStatus('No results found (cached)');
            return false;
        }
    }
    
    // Check if this is a name, email, or phone number that should also be searched in WHOIS
    const shouldSearchWhois = isWhoisCandidate(query, type);
    
    // Check if this is a username that should be searched in OSINT
    const shouldSearchOSINT = (type === 'username' || (!type && !query.includes('@') && !/^\+?\d[\d\s\-\(\)\.]{6,}$/.test(query.trim())));
    
    // Start WHOIS and/or OSINT search in parallel if applicable (only for initial searches, not expansions)
    let whoisPromise = null;
    let osintPromise = null;
    
    if (!parentNodeId) {
        if (shouldSearchWhois && shouldSearchOSINT) {
            updateStatus(`🔍 Searching DeHashed, WHOIS, and OSINT for ${query}...`);
            whoisPromise = performWhoisSearch(query, type);
            osintPromise = handleOSINTSearch(query, parentNodeId);
        } else if (shouldSearchWhois) {
            updateStatus(`🔍 Searching DeHashed and WHOIS for ${query}...`);
            whoisPromise = performWhoisSearch(query, type);
        } else if (shouldSearchOSINT) {
            updateStatus(`🔍 Searching DeHashed and OSINT for ${query}...`);
            osintPromise = handleOSINTSearch(query, parentNodeId);
        } else {
            updateStatus(`🔍 Searching DeHashed for ${query}...`);
        }
    } else {
        updateStatus(`🔍 Searching DeHashed for ${query}...`);
    }
    
    // Add visual feedback in the search input
    const searchBtn = document.getElementById('searchBtn');
    const originalText = searchBtn.textContent;
    searchBtn.textContent = 'Searching...';
    searchBtn.disabled = true;
    
    try {
        const response = await fetch('/api/search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ query, type })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
            updateStatus(`❌ Error: ${data.error}`);
            searchBtn.textContent = originalText;
            searchBtn.disabled = false;
            return false;
        }
        
        // Cache the results and save to storage
        searchCache.set(cacheKey, data);
        saveCacheToStorage();
        
        // If no parent node, don't create a search node - just process results without parent
        // This means initial searches won't have a parent node
        
        // Process the results
        if (data.results && data.results.length > 0) {
            // Show progress while adding nodes
            let processedCount = 0;
            const totalBreaches = data.results.length;
            
            data.results.forEach((breach, index) => {
                const breachInfo = breach.database_name || 'Unknown Database';
                const breachNodes = []; // Track all nodes from this breach
                
                // Update progress
                processedCount++;
                updateStatus(`🔄 Processing breach ${processedCount}/${totalBreaches}...`);
                
                // Add nodes for ALL data types found in the breach
                if (breach.email && breach.email.length > 0) {
                    breach.email.forEach(email => {
                        const nodeId = addNodeSimple({ 
                            value: email, 
                            label: email,
                            breach: breachInfo,
                            breachData: breach
                        }, 'email', parentNodeId);
                        if (nodeId) breachNodes.push(nodeId);
                    });
                }
                
                if (breach.username && breach.username.length > 0) {
                    breach.username.forEach(username => {
                        const nodeId = addNodeSimple({ 
                            value: username, 
                            label: username,
                            breach: breachInfo,
                            breachData: breach
                        }, 'username', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.ip_address && breach.ip_address.length > 0) {
                    breach.ip_address.forEach(ip => {
                        const nodeId = addNodeSimple({ 
                            value: ip, 
                            label: ip,
                            breach: breachInfo,
                            breachData: breach
                        }, 'ip_address', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.password && breach.password.length > 0) {
                    breach.password.forEach(password => {
                        const nodeId = addNodeSimple({ 
                            value: password, 
                            label: password,
                            breach: breachInfo,
                            breachData: breach
                        }, 'password', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (includeHashedPasswords && breach.hashed_password && breach.hashed_password.length > 0) {
                    breach.hashed_password.forEach(hash => {
                        const nodeId = addNodeSimple({ 
                            value: hash, 
                            label: truncateLabel(hash),
                            breach: breachInfo,
                            breachData: breach
                        }, 'hashed_password', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.phone && breach.phone.length > 0) {
                    breach.phone.forEach(phone => {
                        const nodeId = addNodeSimple({ 
                            value: phone, 
                            label: phone,
                            breach: breachInfo,
                            breachData: breach
                        }, 'phone', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.name && breach.name.length > 0) {
                    breach.name.forEach(name => {
                        const nodeId = addNodeSimple({ 
                            value: name, 
                            label: name,
                            breach: breachInfo,
                            breachData: breach
                        }, 'name', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.address && breach.address.length > 0) {
                    breach.address.forEach(address => {
                        const nodeId = addNodeSimple({ 
                            value: address, 
                            label: truncateLabel(address),
                            breach: breachInfo,
                            breachData: breach
                        }, 'address', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.domain && breach.domain.length > 0) {
                    breach.domain.forEach(domain => {
                        const nodeId = addNodeSimple({ 
                            value: domain, 
                            label: domain,
                            breach: breachInfo,
                            breachData: breach
                        }, 'domain', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                if (breach.vin && breach.vin.length > 0) {
                    breach.vin.forEach(vin => {
                        const nodeId = addNodeSimple({ 
                            value: vin, 
                            label: vin,
                            breach: breachInfo,
                            breachData: breach
                        }, 'vin', parentNodeId);
                        breachNodes.push(nodeId);
                    });
                }
                
                // Create connections based on shared values within this breach
                createValueBasedConnections(breach);
            });
            
            updateStatus(`✅ Found ${data.results.length} breaches with ${data.total || data.results.length} total records`);
            
            // Process WHOIS results if we started that search
            if (whoisPromise) {
                whoisPromise.then(whoisData => {
                    if (whoisData && whoisData.results && whoisData.results.length > 0) {
                        updateStatus(`🌐 Found ${whoisData.results.length} WHOIS records`);
                        
                        // Show WHOIS results dialog for user approval
                        showWhoisResultsDialog(whoisData, query, parentNodeId);
                    }
                }).catch(error => {
                    console.error('WHOIS search error:', error);
                });
            }
            
            // Process OSINT results if we started that search
            if (osintPromise) {
                osintPromise.then(result => {
                    console.log('OSINT search completed');
                }).catch(error => {
                    console.error('OSINT search error:', error);
                });
            }
            
            searchBtn.textContent = originalText;
            searchBtn.disabled = false;
            return true;
        } else {
            updateStatus('⚠️ No results found in DeHashed');
            
            // Check WHOIS results if we started that search
            if (whoisPromise) {
                whoisPromise.then(whoisData => {
                    if (whoisData && whoisData.results && whoisData.results.length > 0) {
                        updateStatus(`🌐 Found ${whoisData.results.length} WHOIS records`);
                        
                        // Show WHOIS results dialog for user approval
                        showWhoisResultsDialog(whoisData, query, parentNodeId);
                    }
                }).catch(error => {
                    console.error('WHOIS search error:', error);
                });
            }
            
            // Check OSINT results if we started that search
            if (osintPromise) {
                osintPromise.then(result => {
                    console.log('OSINT search completed (no DeHashed results)');
                }).catch(error => {
                    console.error('OSINT search error:', error);
                });
            }
            
            searchBtn.textContent = originalText;
            searchBtn.disabled = false;
            
            // Add visual feedback for no results
            const statusElement = document.getElementById('status');
            statusElement.style.color = '#ff6600';
            setTimeout(() => {
                statusElement.style.color = '#666666';
            }, 3000);
            return false;
        }
        
    } catch (error) {
        console.error('Search error:', error);
        updateStatus(`❌ Error: ${error.message}`);
        searchBtn.textContent = originalText;
        searchBtn.disabled = false;
        return false;
    }
}

// Process cached results
function processCachedResults(results, parentNodeId) {
    results.forEach(breach => {
        const breachInfo = breach.database_name || 'Unknown Database';
        const breachNodes = []; // Track all nodes from this breach
        
        // Add nodes for ALL data types - same as in performSearch
        if (breach.email && breach.email.length > 0) {
            breach.email.forEach(email => {
                const nodeId = addNodeSimple({ 
                    value: email, 
                    label: email,
                    breach: breachInfo,
                    breachData: breach
                }, 'email', parentNodeId);
                if (nodeId) breachNodes.push(nodeId);
            });
        }
        
        if (breach.username && breach.username.length > 0) {
            breach.username.forEach(username => {
                const nodeId = addNodeSimple({ 
                    value: username, 
                    label: username,
                    breach: breachInfo,
                    breachData: breach
                }, 'username', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.ip_address && breach.ip_address.length > 0) {
            breach.ip_address.forEach(ip => {
                const nodeId = addNodeSimple({ 
                    value: ip, 
                    label: ip,
                    breach: breachInfo,
                    breachData: breach
                }, 'ip_address', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.password && breach.password.length > 0) {
            breach.password.forEach(password => {
                const nodeId = addNodeSimple({ 
                    value: password, 
                    label: password,
                    breach: breachInfo,
                    breachData: breach
                }, 'password', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (includeHashedPasswords && breach.hashed_password && breach.hashed_password.length > 0) {
            breach.hashed_password.forEach(hash => {
                const nodeId = addNodeSimple({ 
                    value: hash, 
                    label: truncateLabel(hash),
                    breach: breachInfo,
                    breachData: breach
                }, 'hashed_password', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.phone && breach.phone.length > 0) {
            breach.phone.forEach(phone => {
                const nodeId = addNodeSimple({ 
                    value: phone, 
                    label: phone,
                    breach: breachInfo,
                    breachData: breach
                }, 'phone', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.name && breach.name.length > 0) {
            breach.name.forEach(name => {
                const nodeId = addNodeSimple({ 
                    value: name, 
                    label: name,
                    breach: breachInfo,
                    breachData: breach
                }, 'name', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.address && breach.address.length > 0) {
            breach.address.forEach(address => {
                const nodeId = addNodeSimple({ 
                    value: address, 
                    label: truncateLabel(address),
                    breach: breachInfo,
                    breachData: breach
                }, 'address', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.domain && breach.domain.length > 0) {
            breach.domain.forEach(domain => {
                const nodeId = addNodeSimple({ 
                    value: domain, 
                    label: domain,
                    breach: breachInfo,
                    breachData: breach
                }, 'domain', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        if (breach.vin && breach.vin.length > 0) {
            breach.vin.forEach(vin => {
                const nodeId = addNodeSimple({ 
                    value: vin, 
                    label: vin,
                    breach: breachInfo,
                    breachData: breach
                }, 'vin', parentNodeId);
                breachNodes.push(nodeId);
            });
        }
        
        // Create connections based on shared values within this breach
        createValueBasedConnections(breach);
    });
}

// Update status bar
function updateStatus(message = null) {
    if (message) {
        document.getElementById('status').textContent = message;
    }
    document.getElementById('node-count').textContent = `Nodes: ${nodes.get().length}`;
    document.getElementById('edge-count').textContent = `Edges: ${edges.get().length}`;
    
    // Show selected nodes count
    if (network) {
        const selectedNodes = network.getSelectedNodes();
        if (selectedNodes.length > 0) {
            document.getElementById('status').textContent += ` | Selected: ${selectedNodes.length}`;
        }
    }
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
}

// EMERGENCY RESET - CLEAR SAVED STATE AND RESTORE ORIGINAL NODES
window.emergencyReset = function() {
    // Clear all saved state
    localStorage.clear();
    
    // Clear anchored nodes
    anchoredNodes.clear();
    
    const allNodes = nodes.get();
    const updates = [];
    
    allNodes.forEach(node => {
        updates.push({
            id: node.id,
            color: {
                background: '#000000',
                border: getNodeColor(node.type),
                highlight: {
                    background: '#1a1a1a',
                    border: getNodeColor(node.type)
                }
            },
            font: {
                color: '#666666',
                size: 12,
                face: 'monospace'
            },
            borderWidth: 2,
            borderWidthSelected: 3,
            hidden: false
        });
    });
    
    nodes.update(updates);
    
    // Clear server cache too
    fetch('/api/cache/clear', { method: 'POST' }).catch(() => {});
    
    updateStatus('EMERGENCY RESET - ALL STATE CLEARED, ORIGINAL SIZES RESTORED');
}

// Fix stuck focus mode
// Recover any "lost" nodes by ensuring all are visible
function recoverLostNodes() {
    const allNodes = nodes.get();
    let recoveredCount = 0;
    
    allNodes.forEach(node => {
        const pos = network.getPositions([node.id])[node.id];
        
        // Check if position is invalid or node might be hidden
        if (!pos || isNaN(pos.x) || isNaN(pos.y) || 
            Math.abs(pos.x) > 10000 || Math.abs(pos.y) > 10000) {
            
            console.log(`[Recovery] Recovering lost node: ${node.id}`);
            
            // Get viewport center
            const view = network.getViewPosition();
            
            // Place node at a random position near viewport center
            const offsetX = (Math.random() - 0.5) * 200;
            const offsetY = (Math.random() - 0.5) * 200;
            
            nodes.update({
                id: node.id,
                x: view.x + offsetX,
                y: view.y + offsetY,
                hidden: false,
                physics: false,
                fixed: {
                    x: false,
                    y: false
                }
            });
            
            recoveredCount++;
        }
    });
    
    if (recoveredCount > 0) {
        network.redraw();
        updateStatus(`Recovered ${recoveredCount} lost nodes`);
    }
    
    return recoveredCount;
}

function fixStuckFocus() {
    focusedNode = null;
    originalNodeColors.clear();
    
    // FORCE RESET ALL NODES TO ABSOLUTE NORMAL SIZE
    const allNodes = nodes.get();
    const updates = [];
    
    allNodes.forEach(node => {
        // Special handling for query nodes - KEEP THEM RED!
        if (node.id && node.id.startsWith('query_')) {
            updates.push({
                id: node.id,
                color: {
                    background: '#000000',
                    border: '#ff0000',  // RED border for query nodes
                    highlight: {
                        background: '#330000',
                        border: '#ff0000'  // RED highlight for query nodes
                    }
                },
                font: {
                    color: '#ff0000',  // RED text for query nodes
                    size: 12,
                    face: 'monospace',
                    bold: true
                },
                borderWidth: 3,
                borderWidthSelected: 4,
                hidden: false
            });
        } else {
            // ALL OTHER NODES - FORCE TO NORMAL SIZE
            const borderColor = getNodeColor(node.type);
            const isAnchored = anchoredNodes.has(node.id);
            
            updates.push({
                id: node.id,
                color: {
                    background: '#000000',  // Always black background
                    border: borderColor,
                    highlight: {
                        background: '#1a1a1a',
                        border: borderColor
                    }
                },
                font: {
                    color: isAnchored ? '#FFFFFF' : '#666666',  // White for anchored, gray for others
                    size: isAnchored ? 18 : 12,  // 18 for anchored, 12 for normal
                    face: 'monospace',
                    bold: isAnchored  // Only anchored are bold
                },
                borderWidth: 2,  // NORMAL border width
                borderWidthSelected: 3,  // NORMAL selected width
                hidden: false
            });
        }
    });
    
    nodes.update(updates);
    updateStatus('ALL NODES RESET TO NORMAL SIZE');
}

// Remove self-referencing edges (loops)
function removeSelfLoops() {
    const allEdges = edges.get();
    const loopEdges = allEdges.filter(edge => edge.from === edge.to);
    
    if (loopEdges.length > 0) {
        console.log(`Removing ${loopEdges.length} self-referencing edges`);
        edges.remove(loopEdges.map(edge => edge.id));
        saveGraphState();
    }
}

// Handle search button click
document.getElementById('searchBtn').addEventListener('click', () => {
    const query = document.getElementById('searchInput').value;
    const type = document.getElementById('searchType').value || null;
    
    if (query) {
        performSearch(query, type);
    }
});

// Handle enter key in search input
document.getElementById('searchInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        document.getElementById('searchBtn').click();
    }
});

// Show context menu
// Hide context menu
function hideContextMenu() {
    const menu = document.getElementById('context-menu');
    if (menu) menu.remove();
}

function showContextMenu(event, node, position = null) {
    // Remove any existing context menu
    const existingMenu = document.getElementById('context-menu');
    if (existingMenu) existingMenu.remove();
    
    const menu = document.createElement('div');
    menu.id = 'context-menu';
    menu.style.cssText = `
        position: absolute;
        left: ${event.pageX}px;
        top: ${event.pageY}px;
        background: #000;
        border: 1px solid #0f0;
        padding: 5px;
        z-index: 1000;
        font-family: monospace;
        font-size: 12px;
    `;
    
    if (node) {
        const selectedNodes = network.getSelectedNodes();
        if (selectedNodes.length > 1) {
            // Multiple nodes selected
            menu.innerHTML = `
                <div class="menu-item" onclick="deleteSelectedNodes([${selectedNodes.map(id => `'${id}'`).join(',')}])">Delete ${selectedNodes.length} Selected Nodes</div>
                <div class="menu-item" onclick="connectSelectedNodes([${selectedNodes.map(id => `'${id}'`).join(',')}])">Connect Selected Nodes</div>
                <div class="menu-item" onclick="mergeSelectedNodes([${selectedNodes.map(id => `'${id}'`).join(',')}])">Merge ${selectedNodes.length} Selected Nodes</div>
                <div class="menu-item" onclick="createClusterFromSelection()">Create Cluster from ${selectedNodes.length} Nodes</div>
            `;
        } else {
            // Single node context menu
            const isAnchored = anchoredNodes.has(node.id);
            
            // Check if this is an image node
            if (node.shape === 'image' || (node.data && node.data.type === 'image')) {
                // Image node menu
                menu.innerHTML = `
                    <div class="menu-item" onclick="analyzeImageWithClaude('${node.id}')">Analyze Image with Claude</div>
                    <div class="menu-item" onclick="toggleAnchorNode('${node.id}')">${isAnchored ? 'Unanchor' : 'Anchor'} Node</div>
                    <div class="menu-item" onclick="centerNode('${node.id}')">Center Node</div>
                    <div class="menu-item" onclick="startConnectionMode('${node.id}')">Add Connection</div>
                    <div class="menu-item" onclick="deleteNode('${node.id}')">Delete Node</div>
                    <div class="menu-item" onclick="deleteConnections('${node.id}')">Delete Connections</div>
                `;
            } else {
                // Regular node menu
                menu.innerHTML = `
                    <div class="menu-item" onmousedown="event.stopPropagation();" onclick="showChangeTypeMenu('${node.id}', event);">Change Type</div>
                    <div class="menu-item" onclick="toggleAnchorNode('${node.id}')">${isAnchored ? 'Unanchor' : 'Anchor'} Node</div>
                    <div class="menu-item" onclick="centerNode('${node.id}')">Center Node</div>
                    <div class="menu-item" onclick="startConnectionMode('${node.id}')">Add Connection</div>
                    <div class="menu-item" onclick="startHypotheticalLinkMode('${node.id}')">Add Hypothetical Link</div>
                    <div class="menu-item" onclick="duplicateNode('${node.id}')">Duplicate Node</div>
                    <div class="menu-item" onclick="deleteNode('${node.id}')">Delete Node</div>
                    <div class="menu-item" onclick="deleteConnections('${node.id}')">Delete Connections</div>
                `;
            }
            
            // Add cluster-specific menu items
            addClusterContextMenuItems(menu, node.id);
        }
    } else if (position) {
        // Canvas context menu
        menu.innerHTML = `
            <div class="menu-item" onclick="createNewNode(${position.x}, ${position.y})">Create New Node</div>
        `;
    }
    
    document.body.appendChild(menu);
    
    // Remove menu on click outside
    setTimeout(() => {
        document.addEventListener('click', function removeMenu() {
            const menu = document.getElementById('context-menu');
            if (menu) menu.remove();
            document.removeEventListener('click', removeMenu);
        });
    }, 100);
}

// Show change type menu
window.showChangeTypeMenu = function(nodeId, event) {
    console.log('showChangeTypeMenu called with nodeId:', nodeId);
    
    if (event) {
        event.stopPropagation();
    }
    
    const node = nodes.get(nodeId);
    if (!node) {
        console.error('Node not found:', nodeId);
        return;
    }
    
    console.log('Node found:', node);
    
    // Hide the main context menu
    hideContextMenu();
    
    // Create type selection menu
    const typeMenu = document.createElement('div');
    typeMenu.className = 'context-menu';
    // Position the menu - if from context menu, offset it slightly
    const leftPos = event ? (event.clientX + 10) : 200;
    const topPos = event ? (event.clientY - 20) : 200;
    
    typeMenu.style.cssText = `
        position: fixed;
        left: ${leftPos}px;
        top: ${topPos}px;
        z-index: 10001;
        background: #1a1a1a;
        border: 1px solid #00ff00;
        border-radius: 4px;
        padding: 5px 0;
        min-width: 200px;
        box-shadow: 0 2px 10px rgba(0, 255, 0, 0.2);
    `;
    
    const nodeTypes = [
        { type: 'email', label: 'Email', color: '#00CED1' },
        { type: 'username', label: 'Username', color: '#9370DB' },
        { type: 'password', label: 'Password', color: '#FFFF00' },
        { type: 'hashed_password', label: 'Hashed Password', color: '#FFD700' },
        { type: 'ip_address', label: 'IP Address', color: '#FFA500' },
        { type: 'phone', label: 'Phone', color: '#808080' },
        { type: 'domain', label: 'Domain', color: '#32CD32' },
        { type: 'name', label: 'Person Name', color: '#4169E1' },
        { type: 'company', label: 'Company/Organization', color: '#00FF00' },
        { type: 'address', label: 'Address', color: '#8B4513' },
        { type: 'vin', label: 'VIN', color: '#FF1493' },
        { type: 'dob', label: 'Date of Birth', color: '#FF69B4' },
        { type: 'social', label: 'Social/SSN', color: '#FF0000' },
        { type: 'url', label: 'URL', color: '#00FFFF' }
    ];
    
    typeMenu.innerHTML = '<div style="font-weight: bold; padding: 5px 10px; border-bottom: 1px solid #333;">Select Node Type:</div>';
    
    nodeTypes.forEach(typeInfo => {
        const item = document.createElement('div');
        item.className = 'menu-item';
        item.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            cursor: pointer;
            color: #ffffff;
        `;
        item.onmouseover = function() { this.style.background = '#333'; };
        item.onmouseout = function() { this.style.background = 'transparent'; };
        
        item.innerHTML = `
            <span style="display: inline-block; width: 12px; height: 12px; background: ${typeInfo.color}; border-radius: 2px;"></span>
            <span>${typeInfo.label}</span>
            ${node.type === typeInfo.type ? '<span style="color: #00ff00;">✓</span>' : ''}
        `;
        item.onclick = function() {
            console.log('Type item clicked:', typeInfo.type);
            changeNodeType(nodeId, typeInfo.type);
            document.body.removeChild(typeMenu);
        };
        typeMenu.appendChild(item);
    });
    
    // Add click outside handler to close menu
    setTimeout(() => {
        document.addEventListener('click', function closeTypeMenu(e) {
            if (!typeMenu.contains(e.target)) {
                if (document.body.contains(typeMenu)) {
                    document.body.removeChild(typeMenu);
                }
                document.removeEventListener('click', closeTypeMenu);
            }
        });
    }, 100);
    
    document.body.appendChild(typeMenu);
    console.log('Type menu added to body. Menu element:', typeMenu);
};

// Change node type
window.changeNodeType = function(nodeId, newType) {
    console.log('changeNodeType called:', nodeId, newType);
    const node = nodes.get(nodeId);
    if (!node) {
        console.error('Node not found in changeNodeType:', nodeId);
        return;
    }
    
    // Save undo state
    saveUndoState(`Change type of "${node.label}" from ${node.type} to ${newType}`);
    
    // Update node
    const newColor = getNodeColor(newType);
    const updates = {
        id: nodeId,
        type: newType,
        color: {
            background: '#000000',
            border: newColor,
            highlight: {
                background: '#1a1a1a',
                border: newColor
            }
        }
    };
    
    // Update data.type as well
    if (node.data) {
        node.data.type = newType;
        updates.data = node.data;
    }
    
    nodes.update(updates);
    
    // Update node details if it's showing
    if (document.getElementById('node-details').innerHTML.includes(nodeId)) {
        showNodeDetails(nodes.get(nodeId));
    }
    
    updateStatus(`Changed node type to ${newType}`);
    saveGraphState();
};

// Center a node in the arrangement
window.centerNode = function(nodeId) {
    const allNodes = nodes.get();
    if (allNodes.length === 0) return;
    
    // Calculate the center point of all nodes
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    allNodes.forEach(node => {
        const pos = network.getPositions([node.id])[node.id];
        if (pos) {
            minX = Math.min(minX, pos.x);
            maxX = Math.max(maxX, pos.x);
            minY = Math.min(minY, pos.y);
            maxY = Math.max(maxY, pos.y);
        }
    });
    
    // Calculate center point
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Move the selected node to center
    network.moveNode(nodeId, centerX, centerY);
    
    // Update node position in dataset
    nodes.update({
        id: nodeId,
        x: centerX,
        y: centerY
    });
    
    // Focus on the centered node
    network.focus(nodeId, {
        scale: 1.0,
        animation: true
    });
    
    updateStatus(`Node centered in arrangement`);
    saveGraphState();
}

// Duplicate a node
window.duplicateNode = function(nodeId) {
    const node = nodes.get(nodeId);
    if (node) {
        const newNode = {
            ...node.data,
            label: node.data.label || node.data.value || 'Duplicate'
        };
        addNode(newNode, node.type, null, true); // Force duplicate
    }
}

// Delete a node
window.deleteNode = function(nodeId) {
    // Save undo state before deletion
    saveUndoState("Delete Node");
    
    nodes.remove(nodeId);
    updateStatus();
    saveGraphState();
}

// Delete connections to a node
window.deleteConnections = function(nodeId) {
    // Save undo state before deleting connections
    saveUndoState("Delete Connections");
    
    const connectedEdges = edges.get({
        filter: function(edge) {
            return edge.from === nodeId || edge.to === nodeId;
        }
    });
    edges.remove(connectedEdges.map(e => e.id));
    updateStatus();
    saveGraphState();
}

// Show change type menu
window.showChangeTypeMenu = function(nodeId) {
    // Remove any existing context menu
    const existingMenu = document.getElementById('context-menu');
    if (existingMenu) existingMenu.remove();
    
    const node = nodes.get(nodeId);
    if (!node) return;
    
    // Get mouse position from last event
    const event = window.event || {};
    
    const menu = document.createElement('div');
    menu.id = 'context-menu';
    menu.style.cssText = `
        position: absolute;
        left: ${event.pageX || 200}px;
        top: ${event.pageY || 200}px;
        background: #000;
        border: 1px solid #0f0;
        padding: 5px;
        z-index: 1001;
        font-family: monospace;
        font-size: 12px;
        max-height: 400px;
        overflow-y: auto;
    `;
    
    const types = [
        { type: 'email', label: 'Email' },
        { type: 'username', label: 'Username' },
        { type: 'password', label: 'Password' },
        { type: 'hashed_password', label: 'Hashed Password' },
        { type: 'ip_address', label: 'IP Address' },
        { type: 'phone', label: 'Phone' },
        { type: 'domain', label: 'Domain' },
        { type: 'name', label: 'Name' },
        { type: 'address', label: 'Address' },
        { type: 'company', label: 'Company' },
        { type: 'dob', label: 'Date of Birth' },
        { type: 'social', label: 'Social Media' },
        { type: 'url', label: 'URL' },
        { type: 'vin', label: 'VIN' },
        { type: 'ssn', label: 'SSN' },
        { type: 'cc', label: 'Credit Card' },
        { type: 'city', label: 'City' },
        { type: 'state', label: 'State' },
        { type: 'zip', label: 'ZIP Code' },
        { type: 'country', label: 'Country' }
    ];
    
    menu.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #0f0;">Select New Type:</div>';
    
    types.forEach(({ type, label }) => {
        const isCurrentType = node.type === type;
        menu.innerHTML += `
            <div class="menu-item" 
                 onclick="changeNodeType('${nodeId}', '${type}')"
                 style="${isCurrentType ? 'background: #003300; color: #00ff00;' : ''}">
                ${label} ${isCurrentType ? '(current)' : ''}
            </div>
        `;
    });
    
    document.body.appendChild(menu);
    
    // Remove menu on click outside
    setTimeout(() => {
        document.addEventListener('click', function removeMenu(e) {
            const menu = document.getElementById('context-menu');
            if (menu && !menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', removeMenu);
            }
        });
    }, 100);
}


// Start connection mode for creating edges
window.startConnectionMode = function(sourceNodeId) {
    hideContextMenu();
    connectionMode = true;
    connectionSourceNode = sourceNodeId;
    
    updateStatus('Click on target node to create connection (ESC to cancel)');
    
    // Change cursor to crosshair
    document.body.style.cursor = 'crosshair';
    
    // Add visual feedback for source node
    const sourceNode = nodes.get(sourceNodeId);
    if (sourceNode) {
        nodes.update({
            id: sourceNodeId,
            borderWidth: 4,
            color: {
                ...sourceNode.color,
                border: '#00ff00' // Bright green border
            }
        });
    }
    
    // Add overlay canvas for drawing the line
    const container = document.getElementById('network-container');
    const overlay = document.createElement('canvas');
    overlay.id = 'connection-overlay';
    overlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 999;
    `;
    container.appendChild(overlay);
    
    // Start drawing the line
    document.addEventListener('mousemove', handleConnectionDrag);
    
    // Force immediate draw to show line
    const rect = container.getBoundingClientRect();
    handleConnectionDrag({ clientX: rect.left + rect.width/2, clientY: rect.top + rect.height/2 });
}

// Handle mouse movement during connection mode
function handleConnectionDrag(event) {
    if (!connectionMode || !connectionSourceNode) return;
    
    // Get source node position
    const sourcePos = network.getPositions([connectionSourceNode])[connectionSourceNode];
    if (!sourcePos) return;
    
    // Get the overlay canvas
    const overlay = document.getElementById('connection-overlay');
    if (!overlay) return;
    
    const container = document.getElementById('network-container');
    const rect = container.getBoundingClientRect();
    
    // Set overlay canvas size to match container
    overlay.width = rect.width;
    overlay.height = rect.height;
    
    // Get mouse position relative to the container
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    
    // Convert positions to canvas coordinates
    const canvasPos = network.canvasToDOM(sourcePos);
    
    // Draw on overlay
    const ctx = overlay.getContext('2d');
    if (ctx) {
        // Clear the entire overlay
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        
        // Draw line from source to mouse
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(canvasPos.x, canvasPos.y);
        ctx.lineTo(mouseX, mouseY);
        ctx.stroke();
        
        // Draw a small circle at mouse position
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, 5, 0, 2 * Math.PI);
        ctx.fill();
    }
}

// Cancel connection mode
function cancelConnectionMode() {
    if (!connectionMode) return;
    
    connectionMode = false;
    
    // Reset source node appearance
    if (connectionSourceNode) {
        const sourceNode = nodes.get(connectionSourceNode);
        if (sourceNode) {
            const originalColor = getNodeColor(sourceNode.type);
            nodes.update({
                id: connectionSourceNode,
                borderWidth: 2,
                color: {
                    ...sourceNode.color,
                    border: originalColor
                }
            });
        }
    }
    
    connectionSourceNode = null;
    document.body.style.cursor = 'default';
    
    // Remove event listener
    document.removeEventListener('mousemove', handleConnectionDrag);
    
    // Remove overlay canvas
    const overlay = document.getElementById('connection-overlay');
    if (overlay) {
        overlay.remove();
    }
    
    // Redraw to clear any artifacts
    network.redraw();
    updateStatus('Ready');
}

// Create a new node at position
window.createNewNode = function(x, y) {
    const value = prompt('Enter node value:');
    if (value) {
        const type = prompt('Enter node type (email, username, password, ip_address, etc.):') || 'custom';
        
        // Create node with specific position
        const nodeId = `node_${nodeIdCounter++}`;
        const borderColor = getNodeColor(type);
        
        const node = {
            id: nodeId,
            label: value,
            title: value,
            color: {
                background: '#000000',
                border: borderColor,
                highlight: {
                    background: '#1a1a1a',
                    border: borderColor
                }
            },
            data: { value: value, label: value },
            type: type,
            x: x,
            y: y,
            font: {
                color: '#666666',
                multi: 'html',
                size: 12
            }
        };
        
        nodes.add(node);
        updateStatus();
        saveGraphState();
    }
}

// Delete multiple selected nodes
window.deleteSelectedNodes = function(nodeIds) {
    if (confirm(`Delete ${nodeIds.length} selected nodes?`)) {
        // Save undo state before deletion
        saveUndoState(`Delete ${nodeIds.length} nodes`);
        
        nodeIds.forEach(nodeId => {
            nodes.remove(nodeId);
            // Clean up from tracking maps
            valueToNodeMap.forEach((value, key) => {
                if (value === nodeId) {
                    valueToNodeMap.delete(key);
                }
            });
        });
        updateStatus(`Deleted ${nodeIds.length} nodes`);
        saveGraphState();
    }
}

// Connect selected nodes
window.connectSelectedNodes = function(nodeIds) {
    if (nodeIds.length < 2) return;
    
    const connectionName = prompt('Enter connection name/reason:') || 'Manual connection';
    
    // Save undo state before creating connections
    saveUndoState(`Connect ${nodeIds.length} nodes`);
    
    // Connect all selected nodes in a star pattern
    for (let i = 0; i < nodeIds.length - 1; i++) {
        for (let j = i + 1; j < nodeIds.length; j++) {
            if (nodeIds[i] !== nodeIds[j]) { // Prevent self-loops
                edges.add({
                    from: nodeIds[i],
                    to: nodeIds[j],
                    color: {
                        color: '#ff00ff' // Magenta for manual connections
                    },
                    dashes: false,
                    width: 2,
                    title: connectionName,
                    arrows: ''
                });
            }
        }
    }
    
    updateStatus(`Connected ${nodeIds.length} nodes`);
    saveGraphState();
}

// Merge selected nodes into one
window.mergeSelectedNodes = function(nodeIds) {
    if (nodeIds.length < 2) return;
    
    // Save undo state before merging
    saveUndoState(`Merge ${nodeIds.length} nodes`);
    
    // Get the target node (first selected node becomes the main one)
    const targetId = nodeIds[0];
    const targetNode = nodes.get(targetId);
    
    if (!targetNode) return;
    
    // Merge all other nodes into the target
    for (let i = 1; i < nodeIds.length; i++) {
        mergeNodes(nodeIds[i], targetId);
    }
    
    updateStatus(`Merged ${nodeIds.length} nodes into ${targetNode.label}`);
    hideContextMenu();
}

// Connect nodes from the same breach
function connectBreachNodes(nodeIds, breachName) {
    if (nodeIds.length < 2) return;
    
    // Connect all nodes in a star pattern (all connected to each other)
    for (let i = 0; i < nodeIds.length - 1; i++) {
        for (let j = i + 1; j < nodeIds.length; j++) {
            if (nodeIds[i] !== nodeIds[j]) {
                // Check if edge already exists
                const existingEdge = edges.get({
                    filter: edge => 
                        (edge.from === nodeIds[i] && edge.to === nodeIds[j]) ||
                        (edge.from === nodeIds[j] && edge.to === nodeIds[i])
                });
                
                if (existingEdge.length === 0) {
                    edges.add({
                        from: nodeIds[i],
                        to: nodeIds[j],
                        color: {
                            color: '#666666' // Gray for breach connections
                        },
                        dashes: false,
                        width: 1,
                        title: `Same breach: ${breachName}`,
                        arrows: ''
                    });
                }
            }
        }
    }
}

// Merge two nodes
function mergeNodes(sourceId, targetId) {
    const sourceNode = nodes.get(sourceId);
    const targetNode = nodes.get(targetId);
    
    if (!sourceNode || !targetNode) return;
    
    // The target (node being dragged onto) becomes the main entity
    // The source (node being dragged) becomes a variation
    
    // Update target node data with variations
    const targetData = { ...targetNode.data };
    
    // Initialize variations array if it doesn't exist
    if (!targetData.variations) {
        targetData.variations = [];
    }
    
    // Initialize merge history if it doesn't exist
    if (!targetData.mergeHistory) {
        targetData.mergeHistory = [];
    }
    
    // Store complete merge information for reversal
    const mergeInfo = {
        nodeId: sourceId,
        value: sourceNode.data.value || sourceNode.label,
        label: sourceNode.label,
        type: sourceNode.type,
        breach: sourceNode.data.breach,
        breachData: sourceNode.data.breachData,
        notes: sourceNode.data.notes || '',
        position: network.getPositions([sourceId])[sourceId],
        mergedAt: new Date().toISOString(),
        originalConnections: edges.get({
            filter: edge => edge.from === sourceId || edge.to === sourceId
        }).map(edge => ({...edge}))
    };
    
    // Store image properties if it's an image node
    if (sourceNode.shape === 'image' && sourceNode.image) {
        mergeInfo.isImage = true;
        mergeInfo.image = sourceNode.image;
    }
    
    // Add source value as a variation
    const variation = {
        id: sourceId, // Keep original ID for unmerging
        value: sourceNode.data.value || sourceNode.label,
        label: sourceNode.label,
        type: sourceNode.type,
        breach: sourceNode.data.breach,
        notes: sourceNode.data.notes || '',
        mergedAt: mergeInfo.mergedAt
    };
    
    // If source is an image node, include the image data
    if (sourceNode.shape === 'image' && sourceNode.image) {
        variation.dataURL = sourceNode.image;
        variation.isImage = true;
        
        // Also add to mergedImages array for easier access
        if (!targetData.mergedImages) {
            targetData.mergedImages = [];
        }
        targetData.mergedImages.push({
            dataURL: sourceNode.image,
            mergedAt: mergeInfo.mergedAt,
            originalId: sourceId,
            label: sourceNode.label
        });
    }
    
    targetData.variations.push(variation);
    
    // Add to merge history
    targetData.mergeHistory.push(mergeInfo);
    
    // If source had variations, add them too
    if (sourceNode.data.variations) {
        targetData.variations.push(...sourceNode.data.variations);
    }
    
    // Merge notes
    if (sourceNode.data.notes && targetNode.data.notes) {
        targetData.notes = targetNode.data.notes + '\n\n[Merged from ' + sourceNode.label + ']\n' + sourceNode.data.notes;
    } else if (sourceNode.data.notes) {
        targetData.notes = sourceNode.data.notes;
    }
    
    // Update label - NO [+n] numbers, just clean label
    const variationCount = targetData.variations.length;
    // Remove ALL existing [+n] patterns from the label first
    const baseLabel = targetNode.label.replace(/\s*\[\+\d+\]/g, '').replace(/<br>\[\+\d+\]/g, '');
    const newLabel = baseLabel; // Just the clean label, no merge count
    
    // Update target node with type in tooltip
    nodes.update({
        id: targetId,
        data: targetData,
        label: newLabel,
        title: `${targetNode.type.toUpperCase()}: ${targetNode.label}\n${variationCount} variation(s)`,
        borderWidth: 3, // Thicker border for merged nodes
        shapeProperties: {
            borderDashes: false
        }
    });
    
    // NO INDICATORS - DISABLED
    
    // Transfer all edges from source to target
    const sourceEdges = edges.get({
        filter: edge => edge.from === sourceId || edge.to === sourceId
    });
    
    sourceEdges.forEach(edge => {
        const newEdge = { ...edge };
        if (edge.from === sourceId) {
            newEdge.from = targetId;
        }
        if (edge.to === sourceId) {
            newEdge.to = targetId;
        }
        
        // Check if this edge already exists
        const exists = edges.get({
            filter: e => (e.from === newEdge.from && e.to === newEdge.to) || 
                        (e.from === newEdge.to && e.to === newEdge.from)
        }).length > 0;
        
        if (!exists && newEdge.from !== newEdge.to) {
            // Check if both nodes are anchored to apply thick white styling
            const fromNode = nodes.get(newEdge.from);
            const toNode = nodes.get(newEdge.to);
            const bothAnchored = anchoredNodes.has(newEdge.from) && anchoredNodes.has(newEdge.to);
            
            edges.add({
                from: newEdge.from,
                to: newEdge.to,
                color: bothAnchored ? '#ffffff' : newEdge.color,
                dashes: bothAnchored ? false : newEdge.dashes,
                width: bothAnchored ? 3 : newEdge.width,
                title: (newEdge.title || '') + ' [via ' + sourceNode.label + ']',
                arrows: newEdge.arrows
            });
        }
    });
    
    // Remove source node
    nodes.remove(sourceId);
    
    // Update tracking maps
    valueToNodeMap.forEach((nodeId, key) => {
        if (nodeId === sourceId) {
            valueToNodeMap.delete(key);
        }
    });
    
    // Update breach connections
    breachConnections.forEach((nodeIds, breach) => {
        const index = nodeIds.indexOf(sourceId);
        if (index > -1) {
            nodeIds.splice(index, 1);
            if (!nodeIds.includes(targetId)) {
                nodeIds.push(targetId);
            }
        }
    });
    
    saveGraphState();
    updateStatus(`Merged "${sourceNode.label}" into "${targetNode.label}"`);
    
    // Update node details if target node is selected
    if (network.getSelectedNodes().includes(targetId)) {
        showNodeDetails(nodes.get(targetId));
    }
}

// Focus on a node and its connections
function focusNode(nodeId) {
    focusedNode = nodeId;
    
    // Get connected nodes
    const connectedNodes = new Set([nodeId]);
    const connectedEdges = edges.get({
        filter: function(edge) {
            if (edge.from === nodeId || edge.to === nodeId) {
                connectedNodes.add(edge.from);
                connectedNodes.add(edge.to);
                return true;
            }
            return false;
        }
    });
    
    // Store original colors and gray out non-connected nodes
    const allNodes = nodes.get();
    const updates = [];
    
    allNodes.forEach(node => {
        originalNodeColors.set(node.id, node.color);
        
        if (!connectedNodes.has(node.id)) {
            updates.push({
                id: node.id,
                color: {
                    background: '#333333',
                    border: '#222222'
                },
                font: {
                    color: '#555555'
                }
            });
        } else {
            // Make connected nodes brighter
            updates.push({
                id: node.id,
                color: {
                    background: node.color,
                    border: '#ffffff'
                },
                borderWidth: 3
            });
        }
    });
    
    nodes.update(updates);
    
    // Fade non-connected edges
    const allEdges = edges.get();
    const edgeUpdates = [];
    
    allEdges.forEach(edge => {
        if (!connectedEdges.find(e => e.id === edge.id)) {
            edgeUpdates.push({
                id: edge.id,
                color: {
                    color: '#333333'
                },
                font: {
                    color: '#333333'
                }
            });
        }
    });
    
    edges.update(edgeUpdates);
}

// Release focus and restore original colors
function releaseFocus() {
    if (!focusedNode) return;
    
    focusedNode = null;
    
    // Restore node colors
    const updates = [];
    originalNodeColors.forEach((color, nodeId) => {
        updates.push({
            id: nodeId,
            color: color,
            borderWidth: 2,
            font: {
                color: '#000000'
            }
        });
    });
    
    nodes.update(updates);
    originalNodeColors.clear();
    
    // Restore edge colors
    const allEdges = edges.get();
    const edgeUpdates = allEdges.map(edge => ({
        id: edge.id,
        color: {
            color: '#666666'
        },
        font: {
            color: '#666666'
        }
    }));
    
    edges.update(edgeUpdates);
}

// Switch tabs
window.switchTab = function(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById(`${tabName}-tab`).classList.add('active');
    
    if (tabName === 'cache') {
        viewCacheAsMap(); // Default to map view
    }
}

// View cache as map
window.viewCacheAsMap = function() {
    const cacheView = document.getElementById('cache-view');
    let html = '<h3>Cache Map View</h3>';
    
    html += '<div style="margin-bottom: 20px;">';
    html += `<p>Search Cache: ${searchCache.size} entries</p>`;
    html += `<p>Node Expansion Cache: ${nodeExpansionCache.size} entries</p>`;
    html += `<p>Value-to-Node Map: ${valueToNodeMap.size} entries</p>`;
    html += '</div>';
    
    // Show search cache as a tree
    html += '<h4>Search Results by Query:</h4>';
    html += '<div class="cache-map">';
    
    searchCache.forEach((data, key) => {
        const [query, type] = key.split('_');
        html += `<div class="cache-entry" style="cursor: pointer;" 
                     oncontextmenu="loadCacheEntry('${key}'); return false;" 
                     ondblclick="loadCacheEntry('${key}'); switchTab('graph');" 
                     title="Double-click or right-click to load in graph">`;
        html += `<strong>${escapeHtml(query)}</strong> (${type})`;
        if (data.results) {
            html += `<ul>`;
            data.results.forEach(breach => {
                html += `<li>${breach.database_name || 'Unknown'} - `;
                const items = [];
                if (breach.email?.length) items.push(`${breach.email.length} emails`);
                if (breach.username?.length) items.push(`${breach.username.length} usernames`);
                if (breach.password?.length) items.push(`${breach.password.length} passwords`);
                if (breach.ip_address?.length) items.push(`${breach.ip_address.length} IPs`);
                html += items.join(', ');
                html += `</li>`;
            });
            html += `</ul>`;
        }
        html += '</div>';
    });
    
    html += '</div>';
    cacheView.innerHTML = html;
}

// View cache as list
window.viewCacheAsList = function() {
    const cacheView = document.getElementById('cache-view');
    let html = '<h3>Cache List View</h3>';
    
    // Collect all unique values from cache
    const allValues = new Map();
    
    searchCache.forEach((data, key) => {
        if (data.results) {
            data.results.forEach(breach => {
                // Collect emails
                if (breach.email) {
                    breach.email.forEach(email => {
                        if (!allValues.has(email)) {
                            allValues.set(email, { type: 'email', databases: [] });
                        }
                        allValues.get(email).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect usernames
                if (breach.username) {
                    breach.username.forEach(username => {
                        if (!allValues.has(username)) {
                            allValues.set(username, { type: 'username', databases: [] });
                        }
                        allValues.get(username).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect passwords
                if (breach.password) {
                    breach.password.forEach(password => {
                        if (!allValues.has(password)) {
                            allValues.set(password, { type: 'password', databases: [] });
                        }
                        allValues.get(password).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect IPs
                if (breach.ip_address) {
                    breach.ip_address.forEach(ip => {
                        if (!allValues.has(ip)) {
                            allValues.set(ip, { type: 'ip_address', databases: [] });
                        }
                        allValues.get(ip).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect addresses
                if (breach.address) {
                    breach.address.forEach(address => {
                        if (!allValues.has(address)) {
                            allValues.set(address, { type: 'address', databases: [] });
                        }
                        allValues.get(address).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect names
                if (breach.name) {
                    breach.name.forEach(name => {
                        if (!allValues.has(name)) {
                            allValues.set(name, { type: 'name', databases: [] });
                        }
                        allValues.get(name).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect phone numbers
                if (breach.phone) {
                    breach.phone.forEach(phone => {
                        if (!allValues.has(phone)) {
                            allValues.set(phone, { type: 'phone', databases: [] });
                        }
                        allValues.get(phone).databases.push(breach.database_name || 'Unknown');
                    });
                }
                
                // Collect ALL OTHER FIELDS
                const additionalFields = ['company', 'dob', 'hashed_password', 'social', 'url'];
                additionalFields.forEach(fieldName => {
                    if (breach[fieldName]) {
                        const values = Array.isArray(breach[fieldName]) ? breach[fieldName] : [breach[fieldName]];
                        values.forEach(val => {
                            if (val && !allValues.has(val)) {
                                allValues.set(val, { type: fieldName, databases: [] });
                            }
                            if (val) {
                                allValues.get(val).databases.push(breach.database_name || 'Unknown');
                            }
                        });
                    }
                });
            });
        }
    });
    
    // Display as sorted list
    html += '<table style="width: 100%; border-collapse: collapse;">';
    html += '<tr><th>Type</th><th>Value</th><th>Found In</th></tr>';
    
    const sortedValues = Array.from(allValues.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    
    sortedValues.forEach(([value, info]) => {
        const escapedValue = escapeHtml(value);
        html += `<tr style="border-bottom: 1px solid #003300; cursor: pointer;" 
                     oncontextmenu="loadValueIntoGraph('${escapedValue}', '${info.type}'); return false;" 
                     ondblclick="loadValueIntoGraph('${escapedValue}', '${info.type}'); switchTab('graph');" 
                     title="Double-click or right-click to load in graph">`;
        html += `<td style="color: ${getNodeColor(info.type)}; padding: 5px;">${info.type}</td>`;
        html += `<td style="padding: 5px;">${escapedValue}</td>`;
        html += `<td style="padding: 5px;">${[...new Set(info.databases)].join(', ')}</td>`;
        html += '</tr>';
    });
    
    html += '</table>';
    html += `<p style="margin-top: 10px;">Total unique values: ${allValues.size}</p>`;
    
    cacheView.innerHTML = html;
}

// Load a value from cache into the graph
window.loadValueIntoGraph = function(value, type) {
    console.log(`Loading ${type}: ${value} into graph`);
    
    // Check if node already exists
    const existingNode = Array.from(valueToNodeMap.entries()).find(([val, nodeId]) => val === value);
    
    if (existingNode) {
        // Node exists - focus on it
        const nodeId = existingNode[1];
        network.selectNodes([nodeId]);
        network.focus(nodeId, {
            scale: 1.5,
            animation: {
                duration: 500,
                easingFunction: 'easeInOutQuad'
            }
        });
        updateStatus(`Focused on existing ${type}: ${value}`);
    } else {
        // Create new node from cache data
        let nodeData = null;
        let breach = null;
        
        // Find the data in cache
        searchCache.forEach((data, key) => {
            if (data.results && !nodeData) {
                data.results.forEach(result => {
                    if (!nodeData) {
                        // Check if this breach contains the value - CHECK ALL POSSIBLE FIELDS
                        let found = false;
                        
                        // Check array fields
                        const arrayFields = ['email', 'username', 'password', 'ip_address', 'address', 'name', 'phone', 
                                           'company', 'dob', 'hashed_password', 'social', 'url'];
                        
                        for (const field of arrayFields) {
                            if (type === field && result[field]) {
                                const fieldValues = Array.isArray(result[field]) ? result[field] : [result[field]];
                                if (fieldValues.includes(value)) {
                                    found = true;
                                    break;
                                }
                            }
                        }
                        
                        if (found) {
                            nodeData = result;
                            breach = result.database_name || 'Unknown';
                        }
                    }
                });
            }
        });
        
        if (nodeData) {
            // Create the node
            const nodeId = `node_${nodeIdCounter++}`;
            const nodeColor = getNodeColor(type);
            
            const newNode = {
                id: nodeId,
                label: value,
                type: type,
                color: {
                    background: '#000000',
                    border: nodeColor,
                    highlight: {
                        background: '#1a1a1a',
                        border: nodeColor
                    }
                },
                borderWidth: 2,
                borderWidthSelected: 3,
                font: {
                    color: '#666666',
                    size: 12,
                    face: 'monospace',
                    bold: false
                },
                data: {
                    value: value,
                    label: value,
                    breach: breach,
                    breachData: nodeData,
                    addedAt: Date.now()
                },
                title: `${type.toUpperCase()}: ${value}\n\nFound in: ${breach}`,
                physics: true,
                shadow: false
            };
            
            // Add to graph
            nodes.add(newNode);
            valueToNodeMap.set(value, nodeId);
            
            // Position near center
            const viewPosition = network.getViewPosition();
            network.moveNode(nodeId, viewPosition.x, viewPosition.y);
            
            // Select and focus
            network.selectNodes([nodeId]);
            network.focus(nodeId, {
                scale: 1.5,
                animation: {
                    duration: 500,
                    easingFunction: 'easeInOutQuad'
                }
            });
            
            updateStatus(`Added ${type}: ${value} from ${breach}`);
            saveGraphState();
        } else {
            updateStatus(`No data found for ${type}: ${value}`);
        }
    }
}

// Clear cache
window.clearCache = async function() {
    if (confirm('Clear all cached data? This will permanently delete all stored search results from disk.')) {
        try {
            const response = await fetch('/api/cache/clear', {
                method: 'POST'
            });
            
            const result = await response.json();
            if (result.success) {
                searchCache.clear();
                nodeExpansionCache.clear();
                updateStatus('Cache cleared from disk');
                
                // Refresh cache view
                if (document.getElementById('cache-tab').classList.contains('active')) {
                    viewCacheAsMap();
                }
            } else {
                updateStatus('Error clearing cache');
            }
        } catch (e) {
            console.error('Error clearing cache:', e);
            updateStatus('Error clearing cache');
        }
    }
}

// Load cache entry into graph
window.loadCacheEntry = function(cacheKey) {
    const data = searchCache.get(cacheKey);
    if (!data || !data.results) return;
    
    // Switch to graph tab
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector('.tab-button').classList.add('active');
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById('graph-tab').classList.add('active');
    
    // Process the cached results
    processCachedResults(data.results, null);
    updateStatus(`Loaded ${data.results.length} cached results into graph`);
}

// Load specific value into graph
window.loadValueIntoGraph = function(value, type) {
    // Switch to graph tab
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector('.tab-button').classList.add('active');
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById('graph-tab').classList.add('active');
    
    // Search for this value in the cache
    let found = false;
    searchCache.forEach((data, key) => {
        if (data.results) {
            data.results.forEach(breach => {
                // Check if this breach contains the value
                let hasValue = false;
                if (type === 'email' && breach.email?.includes(value)) hasValue = true;
                else if (type === 'username' && breach.username?.includes(value)) hasValue = true;
                else if (type === 'password' && breach.password?.includes(value)) hasValue = true;
                else if (type === 'ip_address' && breach.ip_address?.includes(value)) hasValue = true;
                else if (type === 'phone' && breach.phone?.includes(value)) hasValue = true;
                else if (type === 'name' && breach.name?.includes(value)) hasValue = true;
                else if (type === 'address' && breach.address?.includes(value)) hasValue = true;
                else if (type === 'domain' && breach.domain?.includes(value)) hasValue = true;
                
                if (hasValue) {
                    // Process just this breach for this value
                    processCachedResults([breach], null);
                    found = true;
                }
            });
        }
    });
    
    if (found) {
        updateStatus(`Loaded "${value}" into graph`);
        
        // Focus on the loaded node
        const nodeId = valueToNodeMap.get(`${type}_${value}`);
        if (nodeId) {
            network.focus(nodeId, {
                scale: 1.5,
                animation: {
                    duration: 500,
                    easingFunction: 'easeInOutQuad'
                }
            });
            
            // Select the node
            network.selectNodes([nodeId]);
        }
    } else {
        updateStatus(`Value "${value}" not found in cache`);
    }
}

// Save node notes
window.saveNodeNotes = function() {
    if (!currentProfileNode) return;
    
    const notes = document.getElementById('node-notes').value;
    
    // Update node data
    const updatedData = {
        ...currentProfileNode.data,
        notes: notes
    };
    
    nodes.update({
        id: currentProfileNode.id,
        data: updatedData
    });
    
    // Save to storage
    saveGraphState();
    updateStatus('Notes saved');
}

// Open node profile for editing (deprecated - keeping for compatibility)
window.openProfile = function(nodeId) {
    const node = nodes.get(nodeId);
    if (!node) return;
    
    currentProfileNode = node;
    
    // Show profile panel
    document.getElementById('node-details').style.display = 'none';
    document.getElementById('node-profile').style.display = 'block';
    
    // Build editable form
    let html = '<form id="profile-form">';
    html += `<h4>${node.type.toUpperCase()} - ${node.data.value || node.label}</h4>`;
    
    // Core fields (read-only)
    html += '<fieldset><legend>Core Data</legend>';
    html += `<label>Value: <input type="text" name="value" value="${escapeHtml(node.data.value || '')}" readonly style="background: #333;"></label><br>`;
    html += `<label>Type: <input type="text" value="${node.type}" readonly style="background: #333;"></label><br>`;
    if (node.data.breach) {
        html += `<label>Breach: <input type="text" value="${escapeHtml(node.data.breach)}" readonly style="background: #333;"></label><br>`;
    }
    html += '</fieldset>';
    
    // Editable metadata
    html += '<fieldset><legend>Custom Metadata</legend>';
    html += `<label>Label: <input type="text" name="label" value="${escapeHtml(node.label || '')}"></label><br>`;
    html += `<label>Notes: <textarea name="notes" rows="3">${escapeHtml(node.data.notes || '')}</textarea></label><br>`;
    html += `<label>Tags: <input type="text" name="tags" value="${escapeHtml(node.data.tags || '')}" placeholder="tag1, tag2, tag3"></label><br>`;
    html += `<label>Real Name: <input type="text" name="realName" value="${escapeHtml(node.data.realName || '')}"></label><br>`;
    html += `<label>Organization: <input type="text" name="organization" value="${escapeHtml(node.data.organization || '')}"></label><br>`;
    html += `<label>Location: <input type="text" name="location" value="${escapeHtml(node.data.location || '')}"></label><br>`;
    html += '</fieldset>';
    
    // Connections info
    html += '<fieldset><legend>Connections</legend>';
    const connectedEdges = edges.get({
        filter: edge => edge.from === nodeId || edge.to === nodeId
    });
    html += `<p>Connected to ${connectedEdges.length} nodes</p>`;
    
    // List connected nodes
    const connectedNodes = new Set();
    connectedEdges.forEach(edge => {
        connectedNodes.add(edge.from === nodeId ? edge.to : edge.from);
    });
    
    html += '<ul>';
    connectedNodes.forEach(connId => {
        const connNode = nodes.get(connId);
        if (connNode) {
            html += `<li>${connNode.type}: ${escapeHtml(connNode.label)}</li>`;
        }
    });
    html += '</ul>';
    html += '</fieldset>';
    
    html += '</form>';
    
    document.getElementById('profile-content').innerHTML = html;
}

// Save profile changes
window.saveProfile = function() {
    if (!currentProfileNode) return;
    
    const form = document.getElementById('profile-form');
    const formData = new FormData(form);
    
    // Update node data object first
    const updatedData = {
        ...currentProfileNode.data,
        notes: formData.get('notes') || '',
        tags: formData.get('tags') || '',
        realName: formData.get('realName') || '',
        organization: formData.get('organization') || '',
        location: formData.get('location') || ''
    };
    
    // Update node with new data
    const updates = {
        id: currentProfileNode.id,
        label: formData.get('label') || currentProfileNode.label,
        data: updatedData
    };
    
    nodes.update(updates);
    
    // Get the updated node
    currentProfileNode = nodes.get(currentProfileNode.id);
    
    // Update display
    updateStatus('Profile saved');
    saveGraphState(); // Save to localStorage
    closeProfile();
    showNodeDetails(currentProfileNode);
    
    // Update node list if it's visible
    if (document.getElementById('panel-nodes').classList.contains('active')) {
        updateNodeList();
    }
}

// Close profile
window.closeProfile = function() {
    document.getElementById('node-profile').style.display = 'none';
    document.getElementById('node-details').style.display = 'block';
    currentProfileNode = null;
}

// Toggle hashed passwords inclusion
window.toggleHashedPasswords = function(include) {
    includeHashedPasswords = include;
    updateStatus(include ? 'Hashed passwords will be included' : 'Hashed passwords will be excluded');
    
    // Save preference
    localStorage.setItem('includeHashedPasswords', include);
}

// AI Suggestions toggle
let aiSuggestionsEnabled = true;
window.toggleAISuggestions = function(enabled) {
    aiSuggestionsEnabled = enabled;
    localStorage.setItem('aiSuggestionsEnabled', enabled.toString());
    updateStatus(enabled ? 'AI suggestions enabled' : 'AI suggestions disabled');
}

// Toggle arrow display on edges
window.toggleArrows = function(show) {
    showArrows = show;
    
    // Update all existing edges
    const allEdges = edges.get();
    const updates = allEdges.map(edge => ({
        id: edge.id,
        arrows: {
            to: {
                enabled: showArrows,
                scaleFactor: 0.8
            }
        }
    }));
    
    edges.update(updates);
    updateStatus(showArrows ? 'Arrows enabled' : 'Arrows disabled');
}

// Toggle image source connection display
window.toggleImageSourceDisplay = function(show) {
    showImageSources = show;
    
    // Update visibility of image source edges
    const allEdges = edges.get();
    const updates = [];
    
    allEdges.forEach(edge => {
        if (edge.edgeType === 'image_source') {
            updates.push({
                id: edge.id,
                hidden: !show
            });
        }
    });
    
    if (updates.length > 0) {
        edges.update(updates);
        updateStatus(show ? 'Image source connections visible' : 'Image source connections hidden');
    }
}

// Toggle source display (for the Sources checkbox)
window.toggleSourceDisplay = function(show) {
    // This appears to be a different feature - maybe for showing source breaches?
    // For now, just log it
    console.log('Source display toggled:', show);
    updateStatus(show ? 'Sources visible' : 'Sources hidden');
}

// Toggle query node display
let autoShowQueries = false;

window.toggleQueryDisplay = function(show) {
    autoShowQueries = show;
    
    if (show) {
        // Show search indicators (not query nodes by default)
        drawSearchIndicators();
        updateStatus('Query indicators enabled');
    } else {
        // Hide all query nodes AND search indicators
        activeQueryNodes.forEach((searchData, queryNodeId) => {
            hideQueryNode(queryNodeId, false);
        });
        clearSearchIndicators();
        updateStatus('Query indicators disabled');
    }
}

// Toggle highlighting of unsearched nodes
let unsearchedHighlightActive = false;
window.toggleUnsearchedHighlight = function(highlight) {
    unsearchedHighlightActive = highlight;
    
    if (highlight) {
        // Gray out everything except unsearched nodes
        const allNodes = nodes.get();
        const updates = [];
        let unsearchedCount = 0;
        
        allNodes.forEach(node => {
            const nodeKey = `${node.id}_${node.type}_${node.data?.value || node.data?.label || node.label}`;
            const hasBeenSearched = nodeExpansionCache.has(nodeKey);
            
            if (hasBeenSearched) {
                // Gray out searched nodes
                updates.push({
                    id: node.id,
                    color: {
                        background: '#222222',
                        border: '#444444',
                        highlight: {
                            background: '#333333',
                            border: '#555555'
                        }
                    },
                    font: {
                        color: '#666666',
                        size: 12,
                        face: 'monospace'
                    }
                });
            } else {
                // Keep unsearched nodes bright
                const borderColor = getNodeColor(node.type);
                updates.push({
                    id: node.id,
                    color: {
                        background: '#000000',
                        border: borderColor,
                        highlight: {
                            background: '#1a1a1a',
                            border: borderColor
                        }
                    },
                    font: {
                        color: '#666666',
                        size: 12,
                        face: 'monospace'
                    }
                });
                unsearchedCount++;
            }
        });
        
        nodes.update(updates);
        updateStatus(`Highlighting ${unsearchedCount} unsearched nodes (${allNodes.length - unsearchedCount} searched)`);
    } else {
        // Restore normal colors
        fixStuckFocus();
        updateStatus('Normal view restored');
    }
}

// Generate phone number variations for OSINT Industries search
async function generatePhoneVariations(phoneNumber) {
    const prompt = `You are a phone number analysis expert. Given a phone number, generate ALL possible variations that might be used on social platforms or online services for OSINT Industries search.

Phone Number: "${phoneNumber}"

Generate comprehensive variations including:
1. WITH and WITHOUT country codes (+1, +44, +33, +49, etc.)
2. WITH and WITHOUT the + symbol
3. WITH and WITHOUT leading 0 for local numbers
4. ALL common country codes (US +1, UK +44, France +33, Germany +49, Italy +39, Spain +34, Netherlands +31, Belgium +32, Switzerland +41, Austria +43, Denmark +45, Sweden +46, Norway +47, Poland +48, Czech +420, Slovakia +421)
5. Different formatting (spaces, dashes, dots, parentheses, no formatting)
6. Both 00XX and +XX international prefixes

IMPORTANT: For each phone number, try:
- Original format
- With/without +
- With/without leading 0
- With every major country code
- Multiple formatting styles

Generate 15-25 variations to maximize OSINT search coverage.

Format as JSON array of strings:
["variation1", "variation2", "variation3", ...]`;

    try {
        const response = await fetch('/api/ai-suggestions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: 500,
                temperature: 0.3,
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            })
        });

        if (!response.ok) {
            throw new Error('AI service unavailable for phone variations');
        }

        const data = await response.json();
        const content = data.content?.[0]?.text || data.response;
        
        try {
            // Parse the JSON array from Claude's response
            const variations = JSON.parse(content);
            if (Array.isArray(variations)) {
                return variations;
            }
        } catch (parseError) {
            console.warn('Failed to parse phone variations JSON:', content);
        }
        
        // Fallback: generate basic variations manually
        return generateBasicPhoneVariations(phoneNumber);
        
    } catch (error) {
        console.warn('AI phone variation generation failed:', error);
        // Fallback to basic variations
        return generateBasicPhoneVariations(phoneNumber);
    }
}

// Generate comprehensive phone variations as fallback
function generateBasicPhoneVariations(phoneNumber) {
    const variations = [];
    let cleanNumber = phoneNumber.replace(/[^\d+]/g, '');
    
    // Add original
    variations.push(phoneNumber);
    variations.push(cleanNumber);
    
    // Extract digits only for processing
    const digitsOnly = cleanNumber.replace(/[^\d]/g, '');
    
    // Common country codes to try
    const countryCodes = ['1', '44', '33', '49', '39', '34', '31', '32', '41', '43', '45', '46', '47', '48', '420', '421'];
    
    if (cleanNumber.startsWith('+')) {
        // Has + prefix - generate variations without +
        const withoutPlus = cleanNumber.substring(1);
        variations.push(withoutPlus);
        
        // Find the country code and generate local variations
        for (const cc of countryCodes) {
            if (cleanNumber.startsWith(`+${cc}`)) {
                const localNumber = cleanNumber.substring(cc.length + 1);
                
                // Add local number variations
                variations.push(localNumber);
                variations.push('0' + localNumber); // With leading 0
                
                // Add without country code but keep original format
                if (phoneNumber.includes(' ') || phoneNumber.includes('-') || phoneNumber.includes('.')) {
                    const formattedLocal = phoneNumber.substring(phoneNumber.indexOf(cc) + cc.length);
                    variations.push(formattedLocal);
                    variations.push('0' + formattedLocal);
                }
                break;
            }
        }
    } else if (cleanNumber.startsWith('0')) {
        // Has leading 0 - try with country codes and without 0
        const withoutZero = cleanNumber.substring(1);
        variations.push(withoutZero);
        
        // Try common country codes
        countryCodes.forEach(cc => {
            variations.push(`+${cc}${withoutZero}`);
            variations.push(`${cc}${withoutZero}`);
        });
        
        // Special handling for common patterns
        if (digitsOnly.length === 11) { // UK format
            variations.push(`+44${withoutZero}`);
            variations.push(`0044${withoutZero}`);
        }
    } else {
        // No + or leading 0 - try both
        variations.push('0' + cleanNumber);
        variations.push('+' + cleanNumber);
        
        // Try as local number with country codes
        countryCodes.forEach(cc => {
            variations.push(`+${cc}${cleanNumber}`);
            variations.push(`${cc}${cleanNumber}`);
        });
        
        // If it looks like a number with country code already
        if (digitsOnly.length >= 10) {
            for (const cc of countryCodes) {
                if (digitsOnly.startsWith(cc)) {
                    const localPart = digitsOnly.substring(cc.length);
                    variations.push(`+${cc}${localPart}`);
                    variations.push(`0${localPart}`);
                    variations.push(localPart);
                    break;
                }
            }
        }
    }
    
    // Add formatted variations (with spaces, dashes, dots, parentheses)
    const baseVariations = [...variations];
    baseVariations.forEach(variant => {
        const digits = variant.replace(/[^\d+]/g, '');
        if (digits.length >= 10) {
            // Add common formatting patterns
            if (digits.startsWith('+1') || digits.startsWith('1')) {
                // US format: +1 (XXX) XXX-XXXX
                const d = digits.replace(/^\+?1/, '');
                if (d.length === 10) {
                    variations.push(`+1 (${d.slice(0,3)}) ${d.slice(3,6)}-${d.slice(6)}`);
                    variations.push(`(${d.slice(0,3)}) ${d.slice(3,6)}-${d.slice(6)}`);
                    variations.push(`${d.slice(0,3)}-${d.slice(3,6)}-${d.slice(6)}`);
                    variations.push(`${d.slice(0,3)}.${d.slice(3,6)}.${d.slice(6)}`);
                }
            }
            // Add space formatting for any number
            if (digits.length >= 10) {
                const d = digits.replace(/^\+/, '');
                variations.push(d.replace(/(\d{3})(\d{3})(\d{4})/, '$1 $2 $3'));
                variations.push(d.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3'));
                variations.push(d.replace(/(\d{3})(\d{3})(\d{4})/, '$1.$2.$3'));
            }
        }
    });
    
    // Remove duplicates and empty strings
    return [...new Set(variations.filter(v => v && v.length > 5))];
}

// Generate AI search suggestions for a node
async function generateAISuggestions(nodeValue, nodeType) {
    const prompt = `You are a cybersecurity investigator assistant. Given a piece of data from a breach, suggest search variations that might find related information in other breaches.

Data: "${nodeValue}"
Type: ${nodeType}

Generate realistic variations that investigators commonly search for. For each suggestion, provide:
1. The search query
2. Brief reason why this variant might exist

Rules:
- For names: try firstname lastname, lastname firstname, no spaces, dots, underscores, nicknames, initials, middle names
- For emails: Extract the username part, try it alone, with numbers, common variations. DO NOT suggest common domain names like yahoo.com, gmail.com etc as standalone searches - focus on the username part and unique patterns
- For usernames: try with numbers, without numbers, common variations, email formats, year suffixes, prefixes
- For phones: try different formats, country codes, without formatting, area codes only, last 4 digits
- For passwords: try common patterns, year variations, similar strings, l33t speak variations
- Generate EXACTLY 10 suggestions (be generous with variations)
- Focus on practical variations that actually occur in breaches
- Include both likely and creative variations
- Be concise with explanations
- IMPORTANT: Never suggest common email domains (gmail.com, yahoo.com, hotmail.com, etc.) as standalone searches

Format as JSON array:
[{"query": "search_term", "reason": "brief explanation", "type": "suggested_search_type"}]`;

    try {
        // Using Anthropic API with Claude Sonnet 4
        const response = await fetch('/api/ai-suggestions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'claude-sonnet-4-20250514', // Claude Sonnet 4
                max_tokens: 1000,
                temperature: 0.7,
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            })
        });

        if (!response.ok) {
            if (response.status === 503) {
                throw new Error('Claude API is temporarily overloaded. Please try again in a few moments.');
            } else {
                throw new Error(`AI service error: ${response.status} ${response.statusText}`);
            }
        }

        const data = await response.json();
        
        // Parse the response content as JSON
        const content = data.content?.[0]?.text || data.response;
        return JSON.parse(content);
    } catch (error) {
        console.error('AI suggestion error:', error);
        
        // Fallback: Generate basic suggestions locally
        return generateFallbackSuggestions(nodeValue, nodeType);
    }
}

// Fallback suggestions when AI is unavailable
function generateFallbackSuggestions(value, type) {
    const suggestions = [];
    
    switch (type) {
        case 'name':
            const nameParts = value.split(' ');
            if (nameParts.length >= 2) {
                const first = nameParts[0];
                const last = nameParts[nameParts.length - 1];
                suggestions.push(
                    { query: nameParts.reverse().join(' '), reason: 'Last name first format', type: 'name' },
                    { query: nameParts.join(''), reason: 'No spaces', type: 'username' },
                    { query: nameParts.join('.'), reason: 'Dot separated', type: 'username' },
                    { query: nameParts.join('_'), reason: 'Underscore separated', type: 'username' },
                    { query: nameParts.join('-'), reason: 'Hyphen separated', type: 'username' },
                    { query: first.toLowerCase() + last.toLowerCase(), reason: 'Lowercase concatenated', type: 'username' },
                    { query: first[0] + last, reason: 'First initial + last name', type: 'username' },
                    { query: first + last[0], reason: 'First name + last initial', type: 'username' },
                    { query: last + first, reason: 'Reversed no space', type: 'username' },
                    { query: first + '.' + last + '@gmail.com', reason: 'Common email pattern', type: 'email' }
                );
            }
            break;
            
        case 'email':
            const [username, domain] = value.split('@');
            if (username && domain) {
                // Only suggest domain if it's not a common one
                const commonDomains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'aol.com', 'msn.com'];
                const shouldSuggestDomain = !commonDomains.includes(domain.toLowerCase());
                
                suggestions.push(
                    { query: username, reason: 'Username part only', type: 'username' },
                    { query: username.replace(/[._]/g, ''), reason: 'Username without separators', type: 'username' },
                    { query: username + '123', reason: 'Username with numbers', type: 'username' },
                    { query: username + '2024', reason: 'Username with current year', type: 'username' },
                    { query: username + '2023', reason: 'Username with last year', type: 'username' },
                    { query: username + '_', reason: 'Username with underscore', type: 'username' },
                    { query: username.toLowerCase(), reason: 'Lowercase username', type: 'username' },
                    { query: username.charAt(0) + username.slice(1).toLowerCase(), reason: 'Capitalized username', type: 'username' },
                    { query: value.replace('@', ''), reason: 'Email without @ symbol', type: 'username' }
                );
                
                // Only add domain suggestion if it's unique/interesting
                if (shouldSuggestDomain) {
                    suggestions.push({ query: domain, reason: 'Unique domain', type: 'domain' });
                } else {
                    // Add another username variation instead
                    suggestions.push({ query: username + '1', reason: 'Username with single digit', type: 'username' });
                }
            }
            break;
            
        case 'username':
            suggestions.push(
                { query: value + '@gmail.com', reason: 'Gmail format', type: 'email' },
                { query: value + '@yahoo.com', reason: 'Yahoo format', type: 'email' },
                { query: value + '@hotmail.com', reason: 'Hotmail format', type: 'email' },
                { query: value + '@outlook.com', reason: 'Outlook format', type: 'email' },
                { query: value.replace(/\d+$/, ''), reason: 'Without trailing numbers', type: 'username' },
                { query: value + '123', reason: 'Common number suffix', type: 'username' },
                { query: value + '2024', reason: 'Current year suffix', type: 'username' },
                { query: value + '_', reason: 'With underscore suffix', type: 'username' },
                { query: value.toLowerCase(), reason: 'Lowercase variant', type: 'username' },
                { query: value.toUpperCase(), reason: 'Uppercase variant', type: 'username' }
            );
            break;
            
        case 'phone':
            const digits = value.replace(/\D/g, '');
            if (digits.length >= 10) {
                suggestions.push(
                    { query: digits, reason: 'Digits only', type: 'phone' },
                    { query: `+1${digits}`, reason: 'With country code', type: 'phone' },
                    { query: digits.slice(-10), reason: 'Last 10 digits', type: 'phone' }
                );
            }
            break;
    }
    
    return suggestions.slice(0, 8); // Limit to 8 suggestions
}

// Toggle anchor state for a single node
window.toggleAnchorNode = function(nodeId) {
    selectedNodes.clear();
    selectedNodes.add(nodeId);
    anchorSelectedNodes();
}

// Anchor selected nodes
window.anchorSelectedNodes = function() {
    if (selectedNodes.size === 0) return;
    
    // Toggle anchor state for selected nodes
    const allNodes = nodes.get();
    const updates = [];
    let anchorCount = 0;
    let unanchorCount = 0;
    
    // Check if ALL selected nodes are already anchored
    let allAlreadyAnchored = true;
    selectedNodes.forEach(nodeId => {
        if (!anchoredNodes.has(nodeId)) {
            allAlreadyAnchored = false;
        }
    });
    
    if (allAlreadyAnchored) {
        // If ALL are anchored, unanchor them all
        selectedNodes.forEach(nodeId => {
            anchoredNodes.delete(nodeId);
            unanchorCount++;
            
            const node = nodes.get(nodeId);
            if (node) {
                const color = getNodeColor(node.type);
                updates.push({
                    id: nodeId,
                    color: {
                        background: '#000000',  // Back to black
                        border: color,
                        highlight: {
                            background: '#1a1a1a',
                            border: color
                        }
                    },
                    font: {
                        color: '#666666',  // Back to green text
                        size: 12,  // FORCE back to normal size
                        bold: false,  // Remove bold
                        face: 'monospace'  // Ensure monospace
                    }
                });
            }
        });
    } else {
        // If ANY are not anchored, anchor ALL of them (keep already anchored ones anchored)
        selectedNodes.forEach(nodeId => {
            if (!anchoredNodes.has(nodeId)) {
                // Only anchor the ones that aren't already anchored
                anchoredNodes.add(nodeId);
                anchorCount++;
                
                const node = nodes.get(nodeId);
                if (node) {
                    const typeColor = getNodeColor(node.type);
                    updates.push({
                        id: nodeId,
                        color: {
                            background: '#000000',  // Black background
                            border: typeColor,
                            highlight: {
                                background: '#1a1a1a',
                                border: typeColor
                            }
                        },
                        font: {
                            color: '#FFFFFF',  // White text only
                            size: 18,  // 1.5x bigger font ONLY
                            bold: true  // THICK/BOLD text only
                        }
                    });
                }
            }
            // Already anchored nodes stay anchored - no changes needed
        });
    }
    
    // Apply updates
    if (updates.length > 0) {
        nodes.update(updates);
        
        // Update edges between anchored nodes
        const allEdges = edges.get();
        const edgeUpdates = [];
        
        allEdges.forEach(edge => {
            // Get the original edge data
            const originalEdge = edges.get(edge.id);
            
            if (anchoredNodes.has(edge.from) && anchoredNodes.has(edge.to)) {
                // Both nodes are anchored - make edge thick white
                edgeUpdates.push({
                    id: edge.id,
                    color: {
                        color: '#FFFFFF',
                        highlight: '#FFFFFF'
                    },
                    width: 4,
                    dashes: false
                });
            } else if ((anchoredNodes.has(edge.from) || anchoredNodes.has(edge.to)) && 
                       (selectedNodes.has(edge.from) || selectedNodes.has(edge.to))) {
                // One node was just unanchored - restore to dotted grey
                edgeUpdates.push({
                    id: edge.id,
                    color: {
                        color: '#666666',
                        highlight: '#666666'
                    },
                    width: originalEdge.title && originalEdge.title.includes('Same breach') ? 2 : 1,
                    dashes: [5, 5]
                });
            }
        });
        
        if (edgeUpdates.length > 0) {
            edges.update(edgeUpdates);
        }
        
        // Force refresh to ensure changes take effect
        setTimeout(() => {
            network.redraw();
        }, 100);
    }
    
    // Update button text
    const anchorBtn = document.getElementById('anchorSelectedBtn');
    if (anchorCount > 0) {
        updateStatus(`Anchored ${anchorCount} node${anchorCount > 1 ? 's' : ''}`);
        anchorBtn.textContent = `Unanchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
    } else if (unanchorCount > 0) {
        updateStatus(`Unanchored ${unanchorCount} node${unanchorCount > 1 ? 's' : ''}`);
        anchorBtn.textContent = `Anchor ${selectedNodes.size} Node${selectedNodes.size > 1 ? 's' : ''}`;
    }
    
    // Save state
    saveGraphState();
    
    // Update anchored highlight if active
    const highlightCheckbox = document.getElementById('highlightAnchored');
    if (highlightCheckbox && highlightCheckbox.checked) {
        toggleAnchoredHighlight(true);
    }
}

// Toggle highlighting of anchored nodes
window.toggleAnchoredHighlight = function(highlight) {
    if (highlight) {
        // Fade all non-anchored nodes and highlight anchored connections
        const allNodes = nodes.get();
        const nodeUpdates = [];
        let anchoredCount = 0;
        
        allNodes.forEach(node => {
            if (anchoredNodes.has(node.id)) {
                // Anchored nodes in highlight mode - still just background change
                anchoredCount++;
                const typeColor = getNodeColor(node.type);
                nodeUpdates.push({
                    id: node.id,
                    borderWidth: 2,  // NORMAL border even in highlight
                    borderWidthSelected: 3,  // NORMAL selected border
                    color: {
                        background: '#000000',  // Black background
                        border: typeColor,
                        highlight: {
                            background: '#1a1a1a',
                            border: typeColor
                        }
                    },
                    font: {
                        color: '#FFFFFF'  // White text
                    }
                });
            } else {
                // Fade non-anchored nodes
                nodeUpdates.push({
                    id: node.id,
                    borderWidth: 1,
                    color: {
                        background: '#0a0a0a',
                        border: '#222222',
                        highlight: {
                            background: '#1a1a1a',
                            border: '#333333'
                        }
                    },
                    font: {
                        color: '#333333',
                        size: 10
                    },
                    shadow: false
                });
            }
        });
        
        nodes.update(nodeUpdates);
        
        // Highlight edges between anchored nodes
        const allEdges = edges.get();
        const edgeUpdates = [];
        
        allEdges.forEach(edge => {
            if (anchoredNodes.has(edge.from) && anchoredNodes.has(edge.to)) {
                // Keep normal appearance for edges between anchored nodes
                edgeUpdates.push({
                    id: edge.id,
                    width: edge.title && edge.title.includes('Same breach') ? 3 : 2,
                    color: {
                        color: '#00FF00',  // Keep normal green
                        highlight: '#FF0000'
                    },
                    shadow: false
                });
            } else {
                // Fade other edges
                edgeUpdates.push({
                    id: edge.id,
                    width: 1,
                    color: {
                        color: '#222222',
                        highlight: '#333333'
                    },
                    shadow: false
                });
            }
        });
        
        edges.update(edgeUpdates);
        updateStatus(`Highlighting ${anchoredCount} anchored nodes and their connections`);
    } else {
        // Restore normal view
        fixStuckFocus();
        
        // Restore anchored nodes with ONLY background color changed
        const updates = [];
        anchoredNodes.forEach(nodeId => {
            const node = nodes.get(nodeId);
            if (node) {
                const typeColor = getNodeColor(node.type);
                updates.push({
                    id: nodeId,
                    color: {
                        background: '#000000',  // Black background
                        border: typeColor,
                        highlight: {
                            background: '#1a1a1a',
                            border: typeColor
                        }
                    },
                    font: {
                        color: '#FFFFFF',  // White text only
                        size: 18,  // 1.5x bigger font ONLY
                        bold: true  // THICK/BOLD text only
                    }
                });
            }
        });
        
        if (updates.length > 0) {
            nodes.update(updates);
        }
        
        // Restore normal edge appearance
        const allEdges = edges.get();
        const edgeUpdates = allEdges.map(edge => ({
            id: edge.id,
            width: edge.title && edge.title.includes('Same breach') ? 3 : 2,
            color: edge.color || { color: '#666666', highlight: '#ff0000' },
            shadow: { enabled: false }
        }));
        
        edges.update(edgeUpdates);
        
        updateStatus('Normal view restored');
    }
}

// Show AI suggestions modal
function showAISuggestionsModal(suggestions, originalNode) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
        background: #000;
        border: 2px solid #0f0;
        padding: 20px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: #0f0;
        font-family: monospace;
    `;
    
    // Get previously run searches for this node
    const previousSearches = [];
    nodeSearchQueries.forEach((searchData, searchKey) => {
        if (searchData.sourceNode === originalNode.id) {
            previousSearches.push({
                query: searchData.query,
                timestamp: searchData.timestamp,
                results: searchData.results.length
            });
        }
    });
    
    let html = `
        <h3 style="color: #0f0; margin-bottom: 15px;">Search Variations for: ${escapeHtml(originalNode.label)}</h3>
        <p style="color: #888; margin-bottom: 20px;">Select variations to search for:</p>
    `;
    
    // Show previously run searches
    if (previousSearches.length > 0) {
        html += `
            <div style="margin-bottom: 20px; padding: 10px; background: #001100; border: 1px solid #003300;">
                <h4 style="color: #ffff00; margin: 0 0 10px 0;">Previously Run Searches:</h4>
        `;
        previousSearches.forEach(search => {
            const date = new Date(search.timestamp).toLocaleString();
            html += `
                <div style="margin: 5px 0; padding: 5px; background: #000; border-left: 3px solid #666;">
                    <span style="color: #888;">${escapeHtml(search.query)}</span> 
                    <small style="color: #666;">(${search.results} results on ${date})</small>
                </div>
            `;
        });
        html += `</div>`;
    }
    
    // Add WHOIS search as first option if applicable
    const allSuggestions = [];
    const whoisQuery = originalNode.data.value || originalNode.label;
    const isWhoisEligible = isWhoisCandidate(whoisQuery, originalNode.type);
    console.log('WHOIS check:', {
        query: whoisQuery,
        type: originalNode.type,
        isEligible: isWhoisEligible
    });
    
    // Special options for domain nodes
    if (originalNode.type === 'domain') {
        allSuggestions.push({
            query: whoisQuery,
            reason: '🌐 Full WHOIS history search - Extract all contacts, emails, phones, addresses from historical records',
            type: 'domain_whois',
            isDomainWhois: true
        });
        allSuggestions.push({
            query: `@${whoisQuery}`,
            reason: '📧 Search for all email addresses using this domain in breach databases',
            type: 'email',
            isDomainEmailSearch: true
        });
    } else if (isWhoisEligible) {
        allSuggestions.push({
            query: whoisQuery,
            reason: 'Search WHOIS database for domain registrations and contact info',
            type: 'whois',
            isWhois: true
        });
    }
    
    // Add OSINT Industries search for email and phone nodes
    if (originalNode.type === 'email' || originalNode.type === 'phone') {
        allSuggestions.push({
            query: whoisQuery,
            reason: `🔍 OSINT Industries search - Find social profiles, accounts, and additional data for this ${originalNode.type}`,
            type: 'osint',
            isOSINT: true
        });
    }
    
    allSuggestions.push(...suggestions);
    
    // AI suggestions
    if (allSuggestions.length > 0) {
        html += `<h4 style="color: #00ff00; margin: 10px 0;">Search Suggestions:</h4>`;
        html += `
            <div style="margin-bottom: 10px;">
                <button onclick="selectAllSuggestions(true)" style="background: #444; color: white; border: none; padding: 5px 15px; margin-right: 10px; border-radius: 3px; cursor: pointer;">Select All</button>
                <button onclick="selectAllSuggestions(false)" style="background: #444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">Deselect All</button>
            </div>
        `;
        allSuggestions.forEach((suggestion, index) => {
            const nodeColor = suggestion.isWhois ? '#20B2AA' : suggestion.isOSINT ? '#ff6600' : getNodeColor(suggestion.type);
            const icon = suggestion.isWhois ? '🌐 ' : suggestion.isOSINT ? '🔍 ' : '';
            html += `
                <label style="display: block; margin: 10px 0; padding: 10px; border: 1px solid #333; cursor: pointer; ${suggestion.isWhois ? 'background: #002222;' : suggestion.isOSINT ? 'background: #221100;' : ''}">
                    <input type="checkbox" id="suggestion-${index}" checked style="margin-right: 10px;" data-is-whois="${suggestion.isWhois || false}" data-is-osint="${suggestion.isOSINT || false}">
                    <strong style="color: ${nodeColor}">${icon}${escapeHtml(suggestion.query)}</strong>
                    <span style="color: #888; margin-left: 10px;">(${suggestion.type})</span>
                    <br>
                    <small style="color: #666; margin-left: 25px;">${escapeHtml(suggestion.reason)}</small>
                </label>
            `;
        });
    }
    
    // Custom variations section
    html += `
        <div style="margin-top: 20px; padding: 10px; background: #000011; border: 1px solid #000033;">
            <h4 style="color: #66ff66; margin: 0 0 10px 0;">Add Custom Variations:</h4>
            <div id="custom-variations">
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input type="text" id="custom-query-0" placeholder="Enter search variation..." style="flex: 1; background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; font-family: monospace;">
                    <select id="custom-type-0" style="background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px;">
                        <option value="">Auto</option>
                        <option value="email">Email</option>
                        <option value="username">Username</option>
                        <option value="password">Password</option>
                        <option value="phone">Phone</option>
                        <option value="ip_address">IP</option>
                        <option value="domain">Domain</option>
                        <option value="name">Name</option>
                    </select>
                </div>
            </div>
            <button onclick="addCustomVariation()" style="padding: 5px 10px; margin-right: 10px;">Add Another</button>
        </div>
        
        <div style="margin-top: 20px; display: flex; gap: 10px;">
            <button onclick="executeAISuggestions()" style="flex: 1;">Search Selected</button>
            <button onclick="cancelAISuggestions()" style="flex: 1;">Cancel</button>
        </div>
    `;
    
    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Store suggestions for execution
    window.currentAISuggestions = suggestions;
    window.currentAllSuggestions = allSuggestions; // Store the complete list including WHOIS
    window.currentOriginalNode = originalNode;
}

// Add custom variation input
window.addCustomVariation = function() {
    const container = document.getElementById('custom-variations');
    const count = container.children.length;
    
    const newVariation = document.createElement('div');
    newVariation.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px;';
    newVariation.innerHTML = `
        <input type="text" id="custom-query-${count}" placeholder="Enter search variation..." style="flex: 1; background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; font-family: monospace;">
        <select id="custom-type-${count}" style="background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px;">
            <option value="">Auto</option>
            <option value="email">Email</option>
            <option value="username">Username</option>
            <option value="password">Password</option>
            <option value="phone">Phone</option>
            <option value="ip_address">IP</option>
            <option value="domain">Domain</option>
            <option value="name">Name</option>
        </select>
        <button onclick="this.parentElement.remove()" style="background: #660000; color: #ff0000; border: 1px solid #ff0000; padding: 5px;">×</button>
    `;
    
    container.appendChild(newVariation);
}

// Cancel AI suggestions modal
window.cancelAISuggestions = function() {
    const modal = document.querySelector('[style*="position: fixed"]');
    if (modal) {
        modal.remove();
    }
    updateStatus('AI suggestions cancelled');
}

// Execute selected AI suggestions
window.executeAISuggestions = function() {
    const modal = document.querySelector('[style*="position: fixed"]');
    const selectedSuggestions = [];
    
    // Build the complete suggestions list (same as in showAISuggestionsModal)
    const allSuggestions = [];
    const whoisQuery = window.currentOriginalNode.data.value || window.currentOriginalNode.label;
    
    // Special options for domain nodes
    if (window.currentOriginalNode.type === 'domain') {
        allSuggestions.push({
            query: whoisQuery,
            reason: '🌐 Full WHOIS history search - Extract all contacts, emails, phones, addresses from historical records',
            type: 'domain_whois',
            isDomainWhois: true
        });
        allSuggestions.push({
            query: `@${whoisQuery}`,
            reason: '📧 Search for all email addresses using this domain in breach databases',
            type: 'email',
            isDomainEmailSearch: true
        });
    } else if (isWhoisCandidate(whoisQuery, window.currentOriginalNode.type)) {
        allSuggestions.push({
            query: whoisQuery,
            reason: 'Search WHOIS database for domain registrations and contact info',
            type: 'whois',
            isWhois: true
        });
    }
    
    // Add OSINT Industries search for email and phone nodes
    if (window.currentOriginalNode.type === 'email' || window.currentOriginalNode.type === 'phone') {
        allSuggestions.push({
            query: whoisQuery,
            reason: `🔍 OSINT Industries search - Find social profiles, accounts, and additional data for this ${window.currentOriginalNode.type}`,
            type: 'osint',
            isOSINT: true
        });
    }
    
    allSuggestions.push(...(window.currentAISuggestions || []));
    
    // Get selected suggestions
    allSuggestions.forEach((suggestion, index) => {
        const checkbox = document.getElementById(`suggestion-${index}`);
        if (checkbox && checkbox.checked) {
            selectedSuggestions.push(suggestion);
        }
    });
    
    // Get custom variations
    const customContainer = document.getElementById('custom-variations');
    if (customContainer) {
        for (let i = 0; i < customContainer.children.length; i++) {
            const queryInput = document.getElementById(`custom-query-${i}`);
            const typeSelect = document.getElementById(`custom-type-${i}`);
            
            if (queryInput && queryInput.value.trim()) {
                selectedSuggestions.push({
                    query: queryInput.value.trim(),
                    type: typeSelect ? typeSelect.value : '',
                    reason: 'Custom user variation'
                });
            }
        }
    }
    
    modal.remove();
    
    if (selectedSuggestions.length === 0) {
        updateStatus('No variations selected');
        return;
    }
    
    updateStatus(`Searching for ${selectedSuggestions.length} AI suggestions...`);
    
    // Execute searches sequentially with delay
    let searchIndex = 0;
    const executeNext = async () => {
        if (searchIndex >= selectedSuggestions.length) {
            updateStatus(`Completed ${selectedSuggestions.length} AI-suggested searches`);
            return;
        }
        
        const suggestion = selectedSuggestions[searchIndex];
        updateStatus(`AI Search ${searchIndex + 1}/${selectedSuggestions.length}: ${suggestion.query}`);
        
        // Check search type
        if (suggestion.isDomainWhois) {
            // Full domain WHOIS history search
            console.log('Performing full WHOIS history search for domain:', suggestion.query);
            updateStatus(`🌐 Searching WHOIS history for ${suggestion.query}...`);
            try {
                const whoisData = await performWhoisSearch(suggestion.query, 'domain');
                console.log('WHOIS search result:', whoisData);
                if (whoisData && whoisData.results && whoisData.results.length > 0) {
                    await showWhoisResultsDialog(whoisData, suggestion.query, window.currentOriginalNode.id);
                } else {
                    updateStatus('No WHOIS history found');
                }
            } catch (error) {
                console.error('WHOIS search error:', error);
                updateStatus('WHOIS search failed: ' + error.message);
            }
        } else if (suggestion.isDomainEmailSearch) {
            // Search for emails with this domain
            console.log('Searching for emails with domain:', suggestion.query);
            await performSearch(suggestion.query, 'email', window.currentOriginalNode.id);
        } else if (suggestion.isWhois) {
            // Regular WHOIS search
            console.log('Performing WHOIS search for:', suggestion.query, 'with type:', window.currentOriginalNode.type);
            updateStatus(`🌐 Searching WHOIS for ${suggestion.query}...`);
            try {
                const whoisData = await performWhoisSearch(suggestion.query, window.currentOriginalNode.type);
                console.log('WHOIS search result:', whoisData);
                if (whoisData && whoisData.results && whoisData.results.length > 0) {
                    await showWhoisResultsDialog(whoisData, suggestion.query, window.currentOriginalNode.id);
                } else {
                    updateStatus('No WHOIS results found');
                    console.log('No WHOIS results in data:', whoisData);
                }
            } catch (error) {
                console.error('WHOIS search error:', error);
                updateStatus('WHOIS search failed: ' + error.message);
            }
        } else {
            await performSearch(suggestion.query, suggestion.type, window.currentOriginalNode.id);
        }
        
        searchIndex++;
        setTimeout(executeNext, 1000); // 1 second delay between searches
    };
    
    executeNext();
}

// Chat interface functionality
let chatHistory = [];
// Update chat input to show selected nodes
function updateChatInputWithSelection() {
    const chatInput = document.getElementById('chat-input');
    if (!chatInput) return;
    
    if (selectedNodes.size === 0) {
        chatInput.placeholder = "Ask AI about connections, patterns, or observations...";
        chatInput.value = chatInput.value.replace(/^Selected: [^:]+: /, '');
    } else {
        const selectedLabels = Array.from(selectedNodes).map(nodeId => {
            const node = nodes.get(nodeId);
            return node ? node.label : nodeId;
        });
        
        const selectionText = selectedLabels.length === 1 
            ? selectedLabels[0] 
            : `${selectedLabels.length} nodes (${selectedLabels.slice(0, 2).join(', ')}${selectedLabels.length > 2 ? '...' : ''})`;
            
        chatInput.placeholder = `Ask about selected: ${selectionText}`;
        
        // Add selection prefix to input if user hasn't typed yet
        if (!chatInput.value || chatInput.value.startsWith('Selected: ')) {
            chatInput.value = `Selected: ${selectionText}: `;
        }
    }
}

// Toggle chat visibility
window.toggleChatVisibility = function() {
    const chatContainer = document.getElementById('ai-chat-container');
    const minimizedBar = document.getElementById('ai-chat-minimized');
    const toggleButton = document.getElementById('toggle-chat');
    
    if (chatContainer.style.display === 'none') {
        // Show the full chat
        chatContainer.style.display = 'flex';
        minimizedBar.style.display = 'none';
        if (toggleButton) toggleButton.textContent = 'Hide';
    } else {
        // Hide the full chat and show minimized bar
        chatContainer.style.display = 'none';
        minimizedBar.style.display = 'block';
        if (toggleButton) toggleButton.textContent = 'Show';
    }
}

// Toggle select all nodes for AI context
window.toggleSelectAllNodes = function(selectAll) {
    const allNodes = nodes.get();
    const visibleNodes = allNodes.filter(node => !node.hidden);
    
    if (selectAll) {
        // Select all visible nodes
        selectedNodes.clear();
        visibleNodes.forEach(node => {
            selectedNodes.add(node.id);
        });
        network.setSelection({ nodes: Array.from(selectedNodes) });
        updateStatus(`Selected all ${selectedNodes.size} visible nodes for AI context`);
    } else {
        // Deselect all nodes
        selectedNodes.clear();
        network.setSelection({ nodes: [] });
        updateStatus('Deselected all nodes');
    }
    
    // Update chat input to reflect selection
    updateChatInputWithSelection();
    
    // Update the checkbox state if it doesn't match
    const checkbox = document.getElementById('selectAllNodes');
    if (checkbox && checkbox.checked !== selectAll) {
        checkbox.checked = selectAll;
    }
}

// Send chat message
window.sendChatMessage = async function() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Add user message to chat
    addChatMessage('user', message);
    input.value = '';
    
    // Show typing indicator
    addChatMessage('ai', 'Analyzing graph data...', true);
    
    try {
        // Generate graph context for AI
        const graphContext = generateGraphContext();
        
        // Send to AI
        const response = await getChatResponse(message, graphContext);
        
        // Remove typing indicator and add AI response
        removeChatMessage();
        addChatMessage('ai', response);
        
        // Auto-extract entities if an image is selected
        const selectedNodeIds = Array.from(selectedNodes);
        let imageNodeId = null;
        
        for (const nodeId of selectedNodeIds) {
            const node = nodes.get(nodeId);
            if (node && node.shape === 'image') {
                imageNodeId = nodeId;
                break;
            }
        }
        
        if (imageNodeId) {
            console.log('Image selected, auto-extracting entities from response');
            autoExtractEntitiesFromResponse(response, imageNodeId);
        }
        
    } catch (error) {
        removeChatMessage();
        addChatMessage('ai', `Error: ${error.message}. Please check the console for details.`);
        console.error('Chat error:', error);
    }
}

// Add message to chat
function addChatMessage(sender, message, isTyping = false) {
    const chatMessages = document.getElementById('chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        margin-bottom: 10px;
        padding: 8px;
        border-radius: 4px;
        ${sender === 'user' ? 
            'background-color: #001100; border-left: 3px solid #00ff00; margin-left: 20px;' : 
            'background-color: #000011; border-left: 3px solid #0088ff; margin-right: 20px;'
        }
        ${isTyping ? 'opacity: 0.7; font-style: italic;' : ''}
    `;
    
    const senderSpan = document.createElement('span');
    senderSpan.style.cssText = `
        font-weight: bold;
        color: ${sender === 'user' ? '#00ff00' : '#0088ff'};
        font-size: 10px;
        display: block;
        margin-bottom: 5px;
    `;
    senderSpan.textContent = sender === 'user' ? 'YOU' : 'AI ASSISTANT';
    
    const messageSpan = document.createElement('span');
    messageSpan.style.color = '#cccccc';
    
    // Convert basic markdown to HTML
    let formattedMessage = message
        .replace(/\*\*(.*?)\*\*/g, '<strong style="color: #ffffff; font-weight: bold;">$1</strong>') // **bold**
        .replace(/\*(.*?)\*/g, '<em style="font-style: italic;">$1</em>') // *italic*
        .replace(/`(.*?)`/g, '<code style="background: #333; padding: 1px 3px; border-radius: 2px;">$1</code>') // `code`
        .replace(/\n/g, '<br>'); // line breaks
    
    messageSpan.innerHTML = formattedMessage;
    
    messageDiv.appendChild(senderSpan);
    messageDiv.appendChild(messageSpan);
    
    if (isTyping) {
        messageDiv.id = 'typing-indicator';
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Remove last message (for typing indicator)
function removeChatMessage() {
    const typingIndicator = document.getElementById('typing-indicator');
    if (typingIndicator) {
        typingIndicator.remove();
    }
}

// Generate graph context for AI
function generateGraphContext() {
    const allNodes = nodes.get();
    const allEdges = edges.get();
    
    // Filter to only visible (non-hidden) nodes
    const visibleNodes = allNodes.filter(node => !node.hidden);
    const visibleEdges = allEdges.filter(edge => !edge.hidden);
    
    // Summarize visible nodes by type
    const nodesByType = {};
    visibleNodes.forEach(node => {
        if (!nodesByType[node.type]) {
            nodesByType[node.type] = [];
        }
        nodesByType[node.type].push({
            label: node.label,
            breach: node.data?.breach,
            hasBeenSearched: nodeExpansionCache.has(`${node.id}_${node.type}_${node.data?.value || node.data?.label}`)
        });
    });
    
    // Summarize connections by breach (only for visible nodes)
    const breachSummary = {};
    breachConnections.forEach((nodeIds, breachName) => {
        const visibleNodeIds = nodeIds.filter(nodeId => {
            const node = nodes.get(nodeId);
            return node && !node.hidden;
        });
        
        if (visibleNodeIds.length > 0) {
            const nodeTypes = new Set();
            visibleNodeIds.forEach(nodeId => {
                const node = nodes.get(nodeId);
                if (node) nodeTypes.add(node.type);
            });
            breachSummary[breachName] = {
                nodeCount: visibleNodeIds.length,
                types: Array.from(nodeTypes)
            };
        }
    });
    
    // Add selected node details if any nodes are selected
    const selectedNodeDetails = [];
    if (selectedNodes.size > 0) {
        Array.from(selectedNodes).forEach(nodeId => {
            const node = nodes.get(nodeId);
            if (node && !node.hidden) {
                // Get connected nodes
                const connectedEdges = edges.get({
                    filter: edge => (edge.from === nodeId || edge.to === nodeId) && !edge.hidden
                });
                
                const connectedLabels = [];
                connectedEdges.forEach(edge => {
                    const connectedId = edge.from === nodeId ? edge.to : edge.from;
                    const connectedNode = nodes.get(connectedId);
                    if (connectedNode && !connectedNode.hidden) {
                        connectedLabels.push(`${connectedNode.type}: ${connectedNode.label}`);
                    }
                });
                
                selectedNodeDetails.push({
                    id: nodeId,
                    type: node.type,
                    label: node.label,
                    value: node.data?.value || node.label,
                    breach: node.data?.breach,
                    notes: node.data?.notes,
                    variations: node.data?.variations || [],
                    connections: connectedLabels,
                    hasBeenSearched: nodeExpansionCache.has(`${node.id}_${node.type}_${node.data?.value || node.data?.label}`)
                });
            }
        });
    }
    
    return {
        totalNodes: visibleNodes.length,
        totalEdges: visibleEdges.length,
        nodesByType: nodesByType,
        breachSummary: breachSummary,
        searchedNodeCount: nodeExpansionCache.size,
        selectedNodes: selectedNodeDetails
    };
}

// Auto-extract entities from Claude's response when an image is selected
function autoExtractEntitiesFromResponse(response, imageNodeId) {
    console.log('Auto-extracting entities from response for image:', imageNodeId);
    
    const createdNodes = new Map();
    const entities = [];
    const relationships = [];
    
    // Common patterns in how Claude describes entities
    const patterns = {
        // Companies/Organizations - be VERY aggressive about detecting these
        companies: [
            /\b([A-Z][A-Za-z\s&]+(?:Inc|LLC|Corp|Corporation|Ltd|Limited|Company|Co\.|Group|Industries|Services|Solutions|Technologies|Tech|Agency|Department|Bureau|Foundation|Institute|Association|Partners|Consulting|Systems|Software|Hardware|Enterprises|Ventures|Capital|Holdings|International|Global|Labs?|Studio|Network|Media|Bank|Financial|Insurance|Healthcare|Medical|Clinic|Hospital|University|College|School|Academy|Center|Centre)\.?)\b/g,
            /\b((?:The\s+)?[A-Z][A-Za-z]+(?:\s+[A-Z][A-Za-z]+)*)\s+(?:is\s+a|are\s+a|is\s+an|provides|offers|specializes|develops|manufactures|sells)/g,
            /(?:company|organization|firm|business|corporation|enterprise)(?:\s+called|\s+named)?\s*[:\s]+([A-Za-z\s&]+)/gi
        ],
        
        // Person names
        people: [
            /\b([A-Z][a-z]+(?:\s+[A-Z]\.)?(?:\s+[A-Z][a-z]+)+)\b(?=\s*(?:,?\s*(?:CEO|CTO|CFO|President|Director|Manager|Engineer|Developer|Designer|Analyst|Consultant|Sr\.|Jr\.|Dr\.|Mr\.|Ms\.|Mrs\.|Prof\.)|\s+works?\s+|\s+is\s+(?:a|an|the)\s+))/g,
            /(?:Mr\.|Ms\.|Mrs\.|Dr\.|Prof\.)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/g,
            /\b([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)\b(?=\s*['']s\s+)/g
        ],
        
        // Emails
        emails: [
            /\b([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\b/g
        ],
        
        // Phones
        phones: [
            /\b(\+?1?[-.\s]?\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4})\b/g,
            /\b(\+[0-9]{1,3}[-.\s]?[0-9]{1,4}[-.\s]?[0-9]{1,4}[-.\s]?[0-9]{1,9})\b/g
        ],
        
        // Addresses
        addresses: [
            /\b(\d+\s+[A-Za-z\s]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Plaza|Place|Pl|Circle|Cir|Square|Sq|Parkway|Pkwy|Highway|Hwy)(?:\s*[,.]?\s*(?:Suite|Ste|Apt|Apartment|Unit|#)\s*\d+)?)\b/gi,
            /\b([A-Za-z\s]+,\s*[A-Z]{2}\s+\d{5}(?:-\d{4})?)\b/g
        ],
        
        // URLs/Websites
        urls: [
            /\b((?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\.[a-zA-Z]{2,})?(?:\/[^\s]*)?)\b/g
        ]
    };
    
    // Extract entities
    for (const [type, patternList] of Object.entries(patterns)) {
        for (const pattern of patternList) {
            const matches = [...response.matchAll(pattern)];
            for (const match of matches) {
                const value = match[1].trim();
                if (value && value.length > 2) {
                    // Determine node type
                    let nodeType = type === 'companies' ? 'company' : 
                                  type === 'people' ? 'name' :
                                  type === 'emails' ? 'email' :
                                  type === 'phones' ? 'phone' :
                                  type === 'addresses' ? 'address' :
                                  type === 'urls' ? 'url' : 'unknown';
                    
                    // Double-check: if it has company keywords, it's a company
                    if (/\b(?:Inc|LLC|Corp|Corporation|Ltd|Company|Agency|Department)\b/i.test(value)) {
                        nodeType = 'company';
                    }
                    
                    entities.push({ value, type: nodeType });
                }
            }
        }
    }
    
    // Deduplicate entities
    const uniqueEntities = [];
    const seen = new Set();
    for (const entity of entities) {
        const key = `${entity.type}:${entity.value.toLowerCase()}`;
        if (!seen.has(key)) {
            seen.add(key);
            uniqueEntities.push(entity);
        }
    }
    
    console.log('Found entities:', uniqueEntities);
    
    // Create nodes
    for (const entity of uniqueEntities) {
        const result = addNode({
            value: entity.value,
            label: entity.value,
            source: 'AI Image Extract'
        }, entity.type);
        
        if (result && result.nodeId) {
            createdNodes.set(entity.value, result.nodeId);
            
            // Create purple SOURCE edge from image
            const edgeId = `edge_${imageNodeId}_${result.nodeId}_source`;
            if (!edges.get(edgeId)) {
                edges.add({
                    id: edgeId,
                    from: imageNodeId,
                    to: result.nodeId,
                    color: {
                        color: '#9932CC',
                        highlight: '#9932CC',
                        hover: '#9932CC'
                    },
                    width: 2,
                    arrows: {
                        to: { enabled: true, scaleFactor: 0.8 }
                    },
                    label: 'SOURCE',
                    font: { color: '#9932CC', size: 10 },
                    edgeType: 'image_source',
                    hidden: !showImageSources,
                    smooth: {
                        type: 'curvedCW',
                        roundness: 0.2
                    }
                });
            }
        }
    }
    
    // Extract relationships
    const relPatterns = [
        // Person to Company relationships
        /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)\s+(?:is\s+(?:the\s+)?|works?\s+(?:as\s+)?(?:a\s+)?|serves?\s+as\s+)?(CEO|CTO|CFO|President|Director|Manager|Engineer|Developer|Designer|Analyst|Consultant|Employee|Founder|Co-founder|Head|Lead|Senior|Junior|VP|Vice President)(?:\s+(?:of|at|for)\s+)?([A-Z][A-Za-z\s&]+(?:Inc|LLC|Corp|Company|Co\.|Group|Industries|Services|Solutions|Technologies)?\.?)/gi,
        /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)\s+(?:works?\s+at|employed\s+by|with)\s+([A-Z][A-Za-z\s&]+(?:Inc|LLC|Corp|Company|Co\.|Group|Industries|Services|Solutions|Technologies)?\.?)/gi,
        
        // Email/Phone to Person relationships
        /\b([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\s+(?:belongs?\s+to|is\s+(?:the\s+)?(?:email|contact)\s+(?:for|of))\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/gi,
        /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)(?:'s)?\s+(?:email|contact)\s+(?:is|:)\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi,
        
        // Address relationships
        /\b([A-Z][A-Za-z\s&]+(?:Inc|LLC|Corp|Company|Co\.|Group)?\.?)\s+(?:is\s+)?(?:located|headquartered|based)\s+(?:at|in)\s+([^,.]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd)[^,.]*)/gi
    ];
    
    for (const pattern of relPatterns) {
        const matches = [...response.matchAll(pattern)];
        for (const match of matches) {
            // Extract source, target, and relationship type
            let source, target, relType;
            
            if (match[2] && match[2].match(/CEO|CTO|CFO|President|Director|Manager|Engineer/i)) {
                // Person -> Company with role
                source = match[1].trim();
                relType = match[2].trim();
                target = match[3].trim();
            } else {
                // Other relationships
                source = match[1].trim();
                target = match[2].trim();
                relType = 'Associated';
            }
            
            // Find node IDs
            let sourceId = createdNodes.get(source);
            let targetId = createdNodes.get(target);
            
            // Try to find in existing nodes
            if (!sourceId) {
                const sourceNodes = nodes.get({
                    filter: n => n.label && n.label.toLowerCase() === source.toLowerCase()
                });
                if (sourceNodes.length > 0) sourceId = sourceNodes[0].id;
            }
            
            if (!targetId) {
                const targetNodes = nodes.get({
                    filter: n => n.label && n.label.toLowerCase() === target.toLowerCase()
                });
                if (targetNodes.length > 0) targetId = targetNodes[0].id;
            }
            
            // Create relationship edge
            if (sourceId && targetId && sourceId !== targetId) {
                const edgeId = `edge_${sourceId}_${targetId}_rel`;
                if (!edges.get(edgeId)) {
                    edges.add({
                        id: edgeId,
                        from: sourceId,
                        to: targetId,
                        label: relType,
                        title: `Relationship: ${relType}`,
                        color: { color: '#00CED1' },
                        width: 2,
                        arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                        font: { color: '#00CED1', size: 12 },
                        smooth: { type: 'dynamic' }
                    });
                    console.log(`Created relationship: ${source} -> ${target} [${relType}]`);
                }
            }
        }
    }
    
    if (createdNodes.size > 0) {
        saveGraphState();
        updateStatus(`Auto-extracted ${createdNodes.size} entities from image`);
    }
}
    
    // Map to store created nodes by their label for connection creation
    const createdNodes = new Map();
    
    // Parse entity suggestions from the response
    const entityRegex = /- \[(Company|Name|Email|Phone|Username|Address|URL|Domain)\]\s*(.+)/gi;
    const matches = Array.from(response.matchAll(entityRegex));
    
    console.log('Found entity matches:', matches.length);
    
    for (const match of matches) {
        const entityType = match[1].toLowerCase();
        const entityValue = match[2].trim();
        
        // Map entity types to node types
        const typeMap = {
            'company': 'company',
            'name': 'name',
            'email': 'email',
            'phone': 'phone',
            'username': 'username',
            'address': 'address',
            'url': 'url',
            'domain': 'domain'
        };
        
        const nodeType = typeMap[entityType] || 'unknown';
        
        // Add the node
        const result = addNode({
            value: entityValue,
            label: entityValue,
            source: 'AI Image Extract'
        }, nodeType);
        
        if (result && result.nodeId) {
            // Store for connection creation
            createdNodes.set(entityValue, result.nodeId);
            
            if (imageNodeId) {
                // Create purple SOURCE edge from image to extracted entity
                const edgeId = `edge_${imageNodeId}_${result.nodeId}_source`;
                
                if (!edges.get(edgeId)) {
                    edges.add({
                        id: edgeId,
                        from: imageNodeId,
                        to: result.nodeId,
                        color: {
                            color: '#9932CC', // Purple color
                            highlight: '#9932CC',
                            hover: '#9932CC'
                        },
                        width: 2,
                        arrows: {
                            to: {
                                enabled: true,
                                scaleFactor: 0.8
                            }
                        },
                        label: 'SOURCE',
                        font: {
                            color: '#9932CC',
                            size: 10
                        },
                        edgeType: 'image_source',
                        hidden: !showImageSources,
                        smooth: {
                            type: 'curvedCW',
                            roundness: 0.2
                        }
                    });
                }
            }
        }
    }
    
    // Parse and create connections between entities
    const connectionRegex = /- (.+?)\s*->\s*(.+?)\s*\[(.+?)\]/gi;
    const connectionMatches = response.matchAll(connectionRegex);
    
    for (const match of connectionMatches) {
        const sourceLabel = match[1].trim();
        const targetLabel = match[2].trim();
        const relationshipLabel = match[3].trim();
        
        // Find node IDs for source and target
        let sourceId = createdNodes.get(sourceLabel);
        let targetId = createdNodes.get(targetLabel);
        
        // If not in created nodes, search existing nodes
        if (!sourceId) {
            const sourceNodes = nodes.get({
                filter: node => node.label === sourceLabel
            });
            if (sourceNodes.length > 0) {
                sourceId = sourceNodes[0].id;
            }
        }
        
        if (!targetId) {
            const targetNodes = nodes.get({
                filter: node => node.label === targetLabel
            });
            if (targetNodes.length > 0) {
                targetId = targetNodes[0].id;
            }
        }
        
        // Create connection if both nodes exist
        if (sourceId && targetId) {
            const edgeId = `edge_${sourceId}_${targetId}_${relationshipLabel.replace(/\s+/g, '_')}`;
            
            if (!edges.get(edgeId)) {
                edges.add({
                    id: edgeId,
                    from: sourceId,
                    to: targetId,
                    label: relationshipLabel,
                    title: `Relationship: ${relationshipLabel}`,
                    color: {
                        color: '#00CED1', // Turquoise for relationships
                        highlight: '#00CED1',
                        hover: '#00CED1'
                    },
                    width: 2,
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 0.8
                        }
                    },
                    font: {
                        color: '#00CED1',
                        size: 12,
                        strokeWidth: 3,
                        strokeColor: '#000000'
                    },
                    smooth: {
                        type: 'dynamic'
                    }
                });
                
                console.log(`Created connection: ${sourceLabel} -> ${targetLabel} [${relationshipLabel}]`);
            }
        }
    }
    
    saveGraphState();
    updateStatus(`Extracted ${createdNodes.size} entities and created connections from image`);
}

// Get AI chat response
async function getChatResponse(userMessage, graphContext) {
    let systemPrompt = `You are a cybersecurity investigator's AI assistant analyzing breach data connections.

IMPORTANT: When extracting entities from any content (including images), carefully distinguish between:
- "name" type: Individual person names (John Doe, Jane Smith, etc.)
- "company" type: Organization/company names (Microsoft, Apple Inc, FBI, etc.)

Always use "company" type for organizations, businesses, agencies, not "name".

Current graph state (visible nodes only):
- Total visible nodes: ${graphContext.totalNodes || 0}
- Total visible connections: ${graphContext.totalEdges || 0}
- Nodes searched/expanded: ${graphContext.searchedNodeCount || 0}

Node types and counts:
${graphContext.nodesByType ? Object.entries(graphContext.nodesByType).map(([type, nodes]) => 
    `- ${type}: ${nodes.length} (${nodes.filter(n => n.hasBeenSearched).length} searched)`
).join('\n') : '- No nodes in graph'}

Breach data summary:
${graphContext.breachSummary ? Object.entries(graphContext.breachSummary).map(([breach, info]) => 
    `- ${breach}: ${info.nodeCount} items (${info.types.join(', ')})`
).join('\n') : '- No breach data available'}`;

    // Add selected node details if any are selected
    if (graphContext.selectedNodes && graphContext.selectedNodes.length > 0) {
        systemPrompt += `\n\nCURRENTLY SELECTED NODES (${graphContext.selectedNodes.length}):`;
        graphContext.selectedNodes.forEach((node, index) => {
            const nodeType = (node.type || 'unknown').toUpperCase();
            const nodeLabel = node.label || node.value || 'unlabeled';
            systemPrompt += `\n${index + 1}. ${nodeType}: "${nodeLabel}"`;
            if (node.breach) systemPrompt += `\n   - Found in breach: ${node.breach}`;
            if (node.notes) systemPrompt += `\n   - Notes: ${node.notes}`;
            if (node.variations && node.variations.length > 0) {
                systemPrompt += `\n   - Has ${node.variations.length} merged variation(s)`;
            }
            if (node.connections && node.connections.length > 0) {
                systemPrompt += `\n   - Connected to: ${node.connections.slice(0, 5).join(', ')}${node.connections.length > 5 ? '...' : ''}`;
            }
            systemPrompt += `\n   - Searched: ${node.hasBeenSearched ? 'Yes' : 'No'}`;
        });
        
        systemPrompt += `\n\nThe user is asking about these selected nodes. Focus your analysis on them and their relationships.`;
    }

    systemPrompt += `\n\nProvide insights about:
- Patterns you notice in the data
- Potential investigation leads
- Relationships between different data types
- Anomalies or interesting connections
- Suggested next steps for investigation

Be concise but insightful. Focus on actionable intelligence.

When the user asks you to extract entities or analyze content (especially from images), provide suggestions in this format:
"I found these entities that could be added as nodes:
- [Company] Microsoft Corporation
- [Name] John Smith  
- [Email] john@example.com
- [Phone] +1-555-1234

And these connections between them:
- John Smith -> Microsoft Corporation [Employee/CEO]
- john@example.com -> John Smith [Personal email]
- +1-555-1234 -> John Smith [Mobile phone]"

Always use [Company] for organizations and [Name] for individual people.
For connections, use the format: Source -> Target [Relationship]`;

    if (graphContext.selectedNodes && graphContext.selectedNodes.length > 0) {
        systemPrompt += ` Pay special attention to the selected nodes and their significance.`;
    }

    try {
        const response = await fetch('/api/ai-chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'claude-opus-4-20250514',
                max_tokens: 800,
                temperature: 0.7,
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt
                    },
                    ...chatHistory,
                    {
                        role: 'user',
                        content: userMessage
                    }
                ]
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error Response:', errorText);
            throw new Error(`AI service error (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        console.log('AI Response Data:', data);
        const aiResponse = data.content?.[0]?.text || 'Sorry, I could not generate a response.';
        
        // Update chat history
        chatHistory.push(
            { role: 'user', content: userMessage },
            { role: 'assistant', content: aiResponse }
        );
        
        // Keep chat history manageable (last 10 exchanges)
        if (chatHistory.length > 20) {
            chatHistory = chatHistory.slice(-20);
        }
        
        return aiResponse;
        
    } catch (error) {
        throw error;
    }
}

// Handle Enter key in chat input - moved to window load event
function initializeChatInput() {
    const chatInput = document.getElementById('chat-input');
    if (chatInput) {
        chatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
        console.log('Chat input initialized');
    } else {
        console.error('Chat input not found');
    }
}

// Recreate breach connections manually
window.recreateBreachConnections = function() {
    // Clear existing breach connections
    const existingBreachEdges = edges.get({
        filter: edge => edge.title && edge.title.includes('Same breach:')
    });
    edges.remove(existingBreachEdges.map(e => e.id));
    
    // Rebuild from node data
    const nodesByBreach = new Map();
    const allNodes = nodes.get();
    
    allNodes.forEach(node => {
        if (node.data && node.data.breach) {
            const breach = node.data.breach;
            if (!nodesByBreach.has(breach)) {
                nodesByBreach.set(breach, []);
            }
            nodesByBreach.get(breach).push(node.id);
        }
    });
    
    // Clear and rebuild breachConnections map
    breachConnections.clear();
    
    // Connect nodes from same breach
    let totalConnections = 0;
    nodesByBreach.forEach((nodeIds, breachName) => {
        if (nodeIds.length >= 2) {
            connectBreachNodes(nodeIds, breachName);
            totalConnections += (nodeIds.length * (nodeIds.length - 1)) / 2;
        }
    });
    
    saveGraphState();
    updateStatus(`Recreated connections for ${nodesByBreach.size} breaches`);
    console.log(`Created ${totalConnections} potential connections across ${nodesByBreach.size} breaches`);
}

// Debug connections
window.debugConnections = function() {
    console.log('=== BREACH CONNECTIONS DEBUG ===');
    console.log('Breach connections map:', breachConnections);
    console.log('Total breaches tracked:', breachConnections.size);
    
    breachConnections.forEach((nodes, breach) => {
        console.log(`Breach: ${breach} has ${nodes.length} nodes:`, nodes);
    });
    
    console.log('Total edges:', edges.get().length);
    const breachEdges = edges.get({
        filter: edge => edge.title && edge.title.includes('Same breach')
    });
    console.log('Breach connection edges:', breachEdges.length);
    
    // Make all edges more visible temporarily
    const allEdges = edges.get();
    const updates = allEdges.map(edge => ({
        id: edge.id,
        width: 5,
        color: {
            color: '#ffff00',
            inherit: false
        }
    }));
    edges.update(updates);
    
    setTimeout(() => {
        // Restore original colors
        const restore = allEdges.map(edge => ({
            id: edge.id,
            width: edge.title && edge.title.includes('Same breach') ? 3 : 2,
            color: edge.color
        }));
        edges.update(restore);
    }, 3000);
    
    updateStatus(`Highlighting ${edges.get().length} edges for 3 seconds`);
}

// Switch panel tabs
window.switchPanelTab = function(tabName) {
    // Update tab buttons
    document.querySelectorAll('.panel-tab').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Update tab content
    document.querySelectorAll('.panel-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById(`panel-${tabName}`).classList.add('active');
    
    if (tabName === 'nodes') {
        updateNodeList();
    }
}

// Update node list
let currentNodeFilter = 'all';
function updateNodeList() {
    const nodeList = document.getElementById('node-list');
    const allNodes = nodes.get();
    
    // Filter nodes by type
    const filteredNodes = currentNodeFilter === 'all' 
        ? allNodes 
        : allNodes.filter(node => node.type === currentNodeFilter);
    
    // Sort by label
    filteredNodes.sort((a, b) => (a.label || '').localeCompare(b.label || ''));
    
    let html = '';
    filteredNodes.forEach(node => {
        const isVisible = !node.hidden;
        const color = getNodeColor(node.type);
        const fullValue = node.label || node.data?.value || '';
        const isLong = fullValue.length > 100;
        
        html += `
            <div class="node-item" onclick="selectNodeInGraph('${node.id}')">
                <input type="checkbox" 
                    ${isVisible ? 'checked' : ''} 
                    onclick="toggleNodeVisibility('${node.id}', this.checked); event.stopPropagation();">
                <div class="node-item-content">
                    <span class="node-item-label ${isLong ? 'expandable' : ''}" 
                          onclick="${isLong ? `toggleExpand(this); event.stopPropagation();` : ''}">
                        ${escapeHtml(fullValue)}
                    </span>
                    ${isLong ? '<span class="expand-hint">[Click to toggle]</span>' : ''}
                    <span class="node-item-type" style="background-color: ${color}; color: #000;">
                        ${node.type}
                    </span>
                </div>
            </div>
        `;
    });
    
    nodeList.innerHTML = html || '<p>No nodes to display</p>';
}

// Filter node list
window.filterNodeList = function(type) {
    currentNodeFilter = type;
    
    // Update active button
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    updateNodeList();
}

// Toggle node visibility
window.toggleNodeVisibility = function(nodeId, visible) {
    const node = nodes.get(nodeId);
    if (node) {
        nodes.update({
            id: nodeId,
            hidden: !visible
        });
        
        // Also hide/show connected edges
        const connectedEdges = edges.get({
            filter: edge => edge.from === nodeId || edge.to === nodeId
        });
        
        connectedEdges.forEach(edge => {
            edges.update({
                id: edge.id,
                hidden: !visible
            });
        });
    }
}

// Toggle all nodes (filtered by current type selection)
window.toggleAllNodes = function(visible) {
    const allNodes = nodes.get();
    
    // Filter nodes by current filter selection
    const filteredNodes = currentNodeFilter === 'all' 
        ? allNodes 
        : allNodes.filter(node => node.type === currentNodeFilter);
    
    // Update only the filtered nodes
    const updates = filteredNodes.map(node => ({
        id: node.id,
        hidden: !visible
    }));
    
    nodes.update(updates);
    
    // Hide/show edges connected to these nodes
    const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
    const connectedEdges = edges.get({
        filter: edge => filteredNodeIds.has(edge.from) || filteredNodeIds.has(edge.to)
    });
    
    const edgeUpdates = connectedEdges.map(edge => ({
        id: edge.id,
        hidden: !visible
    }));
    
    edges.update(edgeUpdates);
    
    const action = visible ? 'Showing' : 'Hiding';
    const typeText = currentNodeFilter === 'all' ? 'all nodes' : `all ${currentNodeFilter} nodes`;
    updateStatus(`${action} ${filteredNodes.length} ${typeText}`);
    
    updateNodeList();
}

// Select node in graph
window.selectNodeInGraph = function(nodeId) {
    network.selectNodes([nodeId]);
    network.focus(nodeId, {
        scale: 1.5,
        animation: true
    });
    
    // Switch to details tab and show node details
    document.querySelectorAll('.panel-tab')[0].click();
    const node = nodes.get(nodeId);
    if (node) {
        showNodeDetails(node);
    }
}

// Toggle expand/collapse for long values
window.toggleExpand = function(element) {
    element.classList.toggle('collapsed');
}

// Show visual feedback when a node has already been searched
function showNodeSearchedFeedback(nodeId) {
    const nodePosition = network.getPositions([nodeId])[nodeId];
    if (!nodePosition) return;
    
    // Convert network coordinates to DOM coordinates
    const domPosition = network.canvasToDOM(nodePosition);
    
    // Create checkmark element
    const checkmark = document.createElement('div');
    checkmark.innerHTML = '✅';
    checkmark.style.cssText = `
        position: absolute;
        left: ${domPosition.x}px;
        top: ${domPosition.y - 30}px;
        font-size: 24px;
        z-index: 1000;
        animation: fadeInOut 2s ease-in-out;
        pointer-events: none;
    `;
    
    // Add to the network container
    const networkContainer = document.getElementById('network');
    networkContainer.appendChild(checkmark);
    
    // Remove after animation
    setTimeout(() => {
        checkmark.remove();
    }, 2000);
}

// Initialize header auto-hide functionality
function initializeHeaderAutoHide() {
    const header = document.getElementById('header');
    let hideTimeout;
    let isMouseOverHeader = false;
    
    // Auto-hide after 3 seconds of inactivity
    function startHideTimer() {
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
            if (!isMouseOverHeader) {
                header.classList.add('minimized');
            }
        }, 3000);
    }
    
    // Show header when mouse is at top of screen
    document.addEventListener('mousemove', (e) => {
        if (e.clientY <= 50) {
            header.classList.remove('minimized');
            startHideTimer();
        }
    });
    
    // Keep header visible when mouse is over it
    header.addEventListener('mouseenter', () => {
        isMouseOverHeader = true;
        header.classList.remove('minimized');
        clearTimeout(hideTimeout);
    });
    
    header.addEventListener('mouseleave', () => {
        isMouseOverHeader = false;
        startHideTimer();
    });
    
    // Keep header visible when typing in search
    const searchInput = document.getElementById('searchInput');
    searchInput.addEventListener('focus', () => {
        header.classList.remove('minimized');
        clearTimeout(hideTimeout);
    });
    
    searchInput.addEventListener('blur', () => {
        startHideTimer();
    });
    
    // Start the timer initially
    startHideTimer();
}

// Initialize sidebar resizing
function initializeSidebarResize() {
    const infoPanel = document.getElementById('info-panel');
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    // Create resize handle
    const resizeHandle = document.createElement('div');
    resizeHandle.style.cssText = `
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 6px;
        cursor: ew-resize;
        z-index: 10;
    `;
    
    infoPanel.style.position = 'relative';
    infoPanel.appendChild(resizeHandle);
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = parseInt(document.defaultView.getComputedStyle(infoPanel).width, 10);
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = startWidth - (e.clientX - startX);
        infoPanel.style.width = Math.min(Math.max(newWidth, 200), window.innerWidth * 0.5) + 'px';
    });
    
    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
            // Save the width preference
            localStorage.setItem('infoPanelWidth', infoPanel.style.width);
        }
    });
    
    // Restore saved width
    const savedWidth = localStorage.getItem('infoPanelWidth');
    if (savedWidth) {
        infoPanel.style.width = savedWidth;
    }
}

// Force load graph data
function forceLoadGraph() {
    console.log('FORCE LOAD CLICKED!');
    fetch('/api/cache/load')
        .then(r => {
            console.log('Got response:', r);
            return r.json();
        })
        .then(data => {
            console.log('Force loading data:', data);
            if (data.data && data.data.graph_state && data.data.graph_state.nodes) {
                const nodeCount = data.data.graph_state.nodes.length;
                console.log('Found nodes:', nodeCount);
                if (nodeCount > 0) {
                    console.log('Calling loadGraphState...');
                    loadGraphState(data.data.graph_state);
                    console.log('Nodes after load:', nodes.get().length);
                    
                    // REBUILD CONNECTIONS!
                    rebuildAllConnections();
                    
                    network.fit();
                    updateStatus(`Force loaded ${nodeCount} nodes and rebuilt connections`);
                } else {
                    updateStatus('No nodes found in saved state');
                }
            } else {
                console.log('No graph state in data:', data);
                updateStatus('No graph state found');
            }
        })
        .catch(err => {
            console.error('Force load error:', err);
            updateStatus('Error loading graph: ' + err);
        });
}

// Rebuild all connections based on node data
function rebuildAllConnections() {
    console.log('Rebuilding all connections...');
    
    // Clear existing edges first
    edges.clear();
    
    const allNodes = nodes.get();
    console.log('Total nodes:', allNodes.length);
    
    // Simple breach grouping ONLY
    const breaches = {};
    allNodes.forEach(node => {
        if (node.data && node.data.breach) {
            const breach = node.data.breach;
            if (!breaches[breach]) {
                breaches[breach] = [];
            }
            breaches[breach].push(node.id);
        }
    });
    
    // Add edges for breaches - SIMPLE VERSION
    let edgeCount = 0;
    Object.keys(breaches).forEach(breach => {
        const nodeIds = breaches[breach];
        if (nodeIds.length >= 2 && nodeIds.length <= 50) { // LIMIT TO SMALLER BREACHES
            console.log(`Breach ${breach}: ${nodeIds.length} nodes`);
            
            // Simple hub connection - connect all to first node only
            const hubNode = nodeIds[0];
            for (let i = 1; i < nodeIds.length; i++) {
                if (hubNode !== nodeIds[i]) {
                    edges.add({
                        from: hubNode,
                        to: nodeIds[i],
                        color: { color: '#666666' },
                        width: 1,
                        title: `Same breach: ${breach}`,
                        arrows: { to: { enabled: false } }
                    });
                }
            }
            edgeCount++;
        }
    });
    
    console.log(`Added ${edgeCount} connections`);
    updateStatus(`Added ${edgeCount} connections`);
    saveGraphState();
}

// Initialize when page loads
window.addEventListener('load', async () => {
    // Load hashed password preference
    const savedHashPref = localStorage.getItem('includeHashedPasswords');
    if (savedHashPref !== null) {
        includeHashedPasswords = savedHashPref === 'true';
        document.getElementById('includeHashes').checked = includeHashedPasswords;
    }
    
    // Load AI suggestions preference
    const savedAIPref = localStorage.getItem('aiSuggestionsEnabled');
    if (savedAIPref !== null) {
        aiSuggestionsEnabled = savedAIPref === 'true';
        document.getElementById('aiSuggestions').checked = aiSuggestionsEnabled;
    }
    
    initializeGraph();
    initializeChatInput();
    
    // Load projects after initializing graph
    await loadProjects();
    
    // Initialize sidebar resizing
    initializeSidebarResize();
    
    // Initialize header auto-hide
    initializeHeaderAutoHide();
    
    // Initialize paste handler for images
    initializePasteHandler();
    
    // Graph state is now loaded through the project system in loadProjects()
    
    // Draw search indicators if queries are enabled
    if (autoShowQueries) {
        setTimeout(() => {
            drawSearchIndicators();
        }, 500); // Wait for network to stabilize
    }
    
    // Fix any stuck gray nodes after loading
    setTimeout(() => {
        fixStuckFocus();
        removeSelfLoops();
    }, 500);
    
    // Add CSS for context menu and cache view
    const style = document.createElement('style');
    style.textContent = `
        .menu-item {
            padding: 5px 10px;
            cursor: pointer;
            color: #0f0;
        }
        .menu-item:hover {
            background: #0f0;
            color: #000;
        }
        .cache-entry {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #003300;
            background-color: #001100;
            cursor: context-menu;
        }
        .cache-entry:hover {
            border-color: #00ff00;
        }
        .cache-entry strong {
            color: #ffff00;
        }
        .cache-entry ul {
            margin-top: 5px;
            margin-left: 20px;
        }
        .cache-entry li {
            color: #00ff00;
            margin: 2px 0;
        }
        #cache-view h3 {
            color: #ffff00;
            margin-bottom: 10px;
        }
        #cache-view h4 {
            color: #00ffff;
            margin: 15px 0 10px 0;
        }
        #cache-view table th {
            text-align: left;
            padding: 5px;
            border-bottom: 2px solid #00ff00;
            color: #ffff00;
        }
        #cache-view table tr {
            cursor: context-menu;
        }
        #cache-view table tr:hover {
            background-color: #002200;
        }
        .node-item-label.expandable {
            cursor: pointer;
            max-height: 200px;
            overflow-y: auto;
        }
        .node-item-label.expandable.collapsed {
            max-height: 40px;
            overflow: hidden;
            position: relative;
        }
        .node-item-label.expandable.collapsed::after {
            content: '...';
            position: absolute;
            bottom: 0;
            right: 0;
            background: #050505;
            padding: 0 5px;
        }
        .expand-hint {
            font-size: 9px;
            color: #888;
            margin-left: 5px;
        }
    `;
    document.head.appendChild(style);
});

// Switch between tabs
window.switchTab = function(tabName) {
    // Hide all tabs
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected tab
    document.getElementById(`${tabName}-tab`).classList.add('active');
    
    // Update button
    document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`).classList.add('active');
}

// Analyze image with Claude
window.analyzeImageWithClaude = async function(nodeId) {
    const node = nodes.get(nodeId);
    if (!node || !node.image) {
        updateStatus('No image found for analysis');
        return;
    }
    
    // Hide context menu
    const menu = document.getElementById('context-menu');
    if (menu) menu.remove();
    
    updateStatus('Sending image to Claude for analysis...');
    
    try {
        console.log('Sending image to API...');
        const response = await fetch('/api/vision', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                image_data: node.image,
                context: node.label || 'Pasted image'
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('API Response:', result);
        
        // Handle both 'nodes' and 'suggestions' in response
        const suggestions = result.nodes || result.suggestions || [];
        
        if (result && result.success && suggestions && suggestions.length > 0) {
            updateStatus(`Claude suggested ${suggestions.length} nodes`);
            
            // Create suggested nodes
            const createdNodeIds = [];
            suggestions.forEach(suggestedNode => {
                const newNodeId = `node_${nodeIdCounter++}`;
                const nodeColor = getNodeColor(suggestedNode.type);
                
                const newNode = {
                    id: newNodeId,
                    label: suggestedNode.value || suggestedNode.label,
                    type: suggestedNode.type,
                    color: {
                        background: '#000000',
                        border: nodeColor,
                        highlight: {
                            background: '#1a1a1a',
                            border: nodeColor
                        }
                    },
                    borderWidth: 2,
                    borderWidthSelected: 3,
                    font: {
                        color: '#666666',
                        size: 12,
                        face: 'monospace',
                        bold: false
                    },
                    data: {
                        value: suggestedNode.value || suggestedNode.label,
                        label: suggestedNode.value || suggestedNode.label,
                        source: 'Claude image analysis',
                        sourceImage: nodeId,
                        context: suggestedNode.context || '',
                        confidence: suggestedNode.confidence || 'medium',
                        addedAt: Date.now()
                    },
                    title: `${suggestedNode.type.toUpperCase()}: ${suggestedNode.value || suggestedNode.label}\n\nSource: Claude image analysis\nConfidence: ${suggestedNode.confidence || 'medium'}\nContext: ${suggestedNode.context || ''}`,
                    physics: true,
                    shadow: false
                };
                
                // Position around the image node
                const angle = (createdNodeIds.length / suggestions.length) * 2 * Math.PI;
                const radius = 200;
                const imagePos = network.getPositions([nodeId])[nodeId];
                if (imagePos) {
                    newNode.x = imagePos.x + radius * Math.cos(angle);
                    newNode.y = imagePos.y + radius * Math.sin(angle);
                }
                
                nodes.add(newNode);
                createdNodeIds.push(newNodeId);
                
                // Connect to source image
                if (nodeId !== newNodeId) {
                    edges.add({
                        from: nodeId,
                        to: newNodeId,
                    color: { color: '#00FF00' },
                    width: 2,
                    dashes: [5, 5],
                    title: 'Generated from image analysis',
                    arrows: { to: { enabled: true, scaleFactor: 0.5 } }
                    });
                }
            });
            
            // If Claude suggested connections between the new nodes
            if (result && result.connections && Array.isArray(result.connections)) {
                result.connections.forEach(conn => {
                    if (conn.from < createdNodeIds.length && conn.to < createdNodeIds.length && 
                        createdNodeIds[conn.from] !== createdNodeIds[conn.to]) {
                        edges.add({
                            from: createdNodeIds[conn.from],
                            to: createdNodeIds[conn.to],
                            color: { color: '#0088FF' },
                            width: 1,
                            title: conn.reason || 'Related',
                            arrows: { to: { enabled: false } }
                        });
                    }
                });
            }
            
            // Add analysis notes to the image node
            if (result && result.analysis) {
                const currentData = node.data || {};
                nodes.update({
                    id: nodeId,
                    data: {
                        ...currentData,
                        claudeAnalysis: result.analysis,
                        analyzedAt: new Date().toISOString()
                    }
                });
            }
            
            saveGraphState();
            network.fit();
            
        } else {
            console.log('API Response did not contain nodes:', result);
            if (result && result.error) {
                updateStatus('Error: ' + result.error);
            } else if (result && suggestions.length === 0) {
                updateStatus('Claude found no information in the image');
            } else {
                updateStatus('Claude could not analyze the image');
            }
        }
        
    } catch (error) {
        console.error('Error analyzing image:', error);
        updateStatus('Error: ' + error.message);
    }
}

// Initialize paste handler for images
function initializePasteHandler() {
    document.addEventListener('paste', async (e) => {
        // Check if we're in the graph tab
        if (!document.getElementById('graph-tab').classList.contains('active')) {
            return;
        }
        
        const items = e.clipboardData.items;
        
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                e.preventDefault();
                
                const blob = items[i].getAsFile();
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    const dataURL = event.target.result;
                    
                    // Create image node
                    const nodeId = `node_${nodeIdCounter++}`;
                    const timestamp = new Date().toLocaleString();
                    
                    const imageNode = {
                        id: nodeId,
                        label: `Image ${timestamp}`,
                        shape: 'image',
                        image: dataURL,
                        size: 50,
                        borderWidth: 2,
                        borderWidthSelected: 3,
                        color: {
                            border: '#00FF00',
                            highlight: {
                                border: '#00FF00'
                            }
                        },
                        font: {
                            color: '#00FF00',
                            size: 10,
                            face: 'monospace'
                        },
                        data: {
                            type: 'image',
                            timestamp: timestamp,
                            dataURL: dataURL
                        },
                        physics: true
                    };
                    
                    // Add to graph at current view position
                    nodes.add(imageNode);
                    
                    // Position safely without overlap
                    const viewPosition = network.getViewPosition();
                    let x = viewPosition.x;
                    let y = viewPosition.y;
                    
                    // Check for collisions and adjust position
                    const allPositions = network.getPositions();
                    const minDistance = 400;
                    let attempts = 0;
                    
                    while (attempts < 30) {
                        let tooClose = false;
                        for (let existingId in allPositions) {
                            const existingPos = allPositions[existingId];
                            const dx = x - existingPos.x;
                            const dy = y - existingPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose) break;
                        
                        // Move to a different position
                        x = viewPosition.x + (Math.random() - 0.5) * 800;
                        y = viewPosition.y + (Math.random() - 0.5) * 800;
                        attempts++;
                    }
                    
                    network.moveNode(nodeId, x, y);
                    
                    // Select the new node
                    network.selectNodes([nodeId]);
                    
                    updateStatus(`Pasted image as node ${nodeId}`);
                    saveGraphState();
                };
                
                reader.readAsDataURL(blob);
                break;
            }
        }
    });
    
    console.log('Paste handler initialized - images can be pasted into graph');
}

// Save node notes (keeping for backwards compatibility)
window.saveNodeNotes = function() {
    if (currentProfileNode) {
        saveNodeDetails(currentProfileNode.id);
    }
}

// Save all node details including primary value and variations
window.saveNodeDetails = function(nodeId) {
    const node = nodes.get(nodeId);
    if (!node) return;
    
    const primaryValue = document.getElementById('node-primary-value')?.value;
    const notes = document.getElementById('node-notes')?.value;
    
    const nodeData = { ...node.data };
    
    // Update primary value
    if (primaryValue) {
        nodeData.value = primaryValue;
    }
    
    // Update variations if they exist
    if (nodeData.variations) {
        nodeData.variations.forEach((v, idx) => {
            const variationInput = document.getElementById(`variation-${idx}`);
            if (variationInput) {
                v.value = variationInput.value;
            }
        });
    }
    
    // Update notes
    nodeData.notes = notes || '';
    
    // Update the node
    nodes.update({
        id: nodeId,
        data: nodeData,
        label: primaryValue || node.label
    });
    
    saveGraphState();
    updateStatus('Changes saved');
}

// Show unmerge options
window.showUnmergeOptions = function(nodeId) {
    const node = nodes.get(nodeId);
    if (!node || !node.data.mergeHistory) return;
    
    const menu = document.createElement('div');
    menu.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #000;
        border: 2px solid #0f0;
        padding: 20px;
        z-index: 2000;
        max-width: 400px;
        max-height: 400px;
        overflow-y: auto;
    `;
    
    let html = `
        <h3 style="color: #0f0; margin-bottom: 10px;">Unmerge Variations</h3>
        <p style="color: #0f0; margin-bottom: 15px;">Select variations to unmerge:</p>
    `;
    
    node.data.mergeHistory.forEach((merge, idx) => {
        html += `
            <label style="display: block; margin: 5px 0; color: #0f0;">
                <input type="checkbox" id="unmerge-${idx}" value="${idx}">
                ${escapeHtml(merge.label)} (${merge.type}) - ${merge.breach || 'Unknown'}
            </label>
        `;
    });
    
    html += `
        <div style="margin-top: 15px;">
            <button onclick="performUnmerge('${nodeId}')">Unmerge Selected</button>
            <button onclick="this.parentElement.parentElement.remove()">Cancel</button>
        </div>
    `;
    
    menu.innerHTML = html;
    document.body.appendChild(menu);
}

// Perform unmerge
window.performUnmerge = function(nodeId) {
    const node = nodes.get(nodeId);
    if (!node || !node.data.mergeHistory) return;
    
    const selectedIndices = [];
    node.data.mergeHistory.forEach((merge, idx) => {
        const checkbox = document.getElementById(`unmerge-${idx}`);
        if (checkbox && checkbox.checked) {
            selectedIndices.push(idx);
        }
    });
    
    if (selectedIndices.length === 0) {
        alert('No variations selected');
        return;
    }
    
    // Process unmerges in reverse order to maintain indices
    selectedIndices.sort((a, b) => b - a);
    
    selectedIndices.forEach(idx => {
        const mergeInfo = node.data.mergeHistory[idx];
        
        // Check if this was an image node
        const variation = node.data.variations.find(v => v.id === mergeInfo.nodeId);
        const isImageNode = variation && variation.isImage;
        
        // Recreate the original node
        const restoredNode = {
            id: mergeInfo.nodeId,
            label: mergeInfo.label,
            type: mergeInfo.type,
            x: mergeInfo.position.x,
            y: mergeInfo.position.y,
            data: {
                value: mergeInfo.value,
                label: mergeInfo.label,
                breach: mergeInfo.breach,
                breachData: mergeInfo.breachData,
                notes: mergeInfo.notes
            }
        };
        
        // Set up as image node if it was one
        if (isImageNode && variation.dataURL) {
            restoredNode.shape = 'image';
            restoredNode.image = variation.dataURL;
            restoredNode.size = 50;
            restoredNode.borderWidth = 2;
            restoredNode.borderWidthSelected = 3;
            restoredNode.color = {
                border: '#00FF00',
                highlight: {
                    border: '#00FF00'
                }
            };
            restoredNode.font = {
                color: '#00FF00',
                size: 10,
                face: 'monospace'
            };
            restoredNode.data.type = 'image';
            restoredNode.data.dataURL = variation.dataURL;
        } else {
            // Regular node
            restoredNode.title = `${mergeInfo.type.toUpperCase()}: ${mergeInfo.value}`;
            restoredNode.color = getNodeColor(mergeInfo.type);
            restoredNode.font = {
                multi: 'html',
                size: 12
            };
        }
        
        nodes.add(restoredNode);
        
        // Restore original connections
        mergeInfo.originalConnections.forEach(edge => {
            // Skip if it would create a connection to the merged node
            if ((edge.from === nodeId && edge.to === mergeInfo.nodeId) ||
                (edge.to === nodeId && edge.from === mergeInfo.nodeId)) {
                return;
            }
            
            // Check if edge already exists
            const exists = edges.get({
                filter: e => e.from === edge.from && e.to === edge.to
            }).length > 0;
            
            if (!exists) {
                edges.add(edge);
            }
        });
        
        // Remove from variations and merge history
        const nodeData = { ...node.data };
        nodeData.variations = nodeData.variations.filter(v => v.id !== mergeInfo.nodeId);
        nodeData.mergeHistory.splice(idx, 1);
        
        // Also remove from mergedImages array if it exists
        if (nodeData.mergedImages) {
            nodeData.mergedImages = nodeData.mergedImages.filter(img => img.originalId !== mergeInfo.nodeId);
        }
        
        // Update the node
        const variationCount = nodeData.variations.length;
        nodes.update({
            id: nodeId,
            data: nodeData,
            label: node.label.replace(/ \[\+\d+\]/, '') + (variationCount > 0 ? ` [+${variationCount}]` : ''),
            title: `${node.label}\n${variationCount} variation(s)`,
            borderWidth: variationCount > 0 ? 3 : 1
        });
    });
    
    // Close the menu
    document.querySelector('div[style*="position: fixed"]').remove();
    
    saveGraphState();
    updateStatus(`Unmerged ${selectedIndices.length} variation(s)`);
    
    // Refresh node details if still selected
    if (network.getSelectedNodes().includes(nodeId)) {
        showNodeDetails(nodes.get(nodeId));
    }
}

// Force load graph from server
window.forceLoadGraph = function() {
    if (!network || !nodes || !edges) {
        alert('Graph not initialized! Reloading page...');
        location.reload();
        return;
    }
    
    fetch('/api/cache/load')
        .then(r => r.json())
        .then(data => {
            if (data.data && data.data.graph_state && data.data.graph_state.nodes) {
                alert('Loading ' + data.data.graph_state.nodes.length + ' nodes...');
                
                // Clear existing data
                nodes.clear();
                edges.clear();
                
                // Add nodes directly
                nodes.add(data.data.graph_state.nodes);
                
                // Add edges if any
                if (data.data.graph_state.edges) {
                    edges.add(data.data.graph_state.edges);
                }
                
                // Fit view
                setTimeout(() => {
                    network.fit();
                    updateStatus('Force loaded ' + nodes.length + ' nodes');
                }, 100);
            } else {
                alert('No data found in cache!');
            }
        })
        .catch(err => {
            alert('Error loading: ' + err);
        });
}

// Restore all data from cache
window.restoreAllData = function() {
    const majorSearches = [
        'sy.hishan@gmail.com_email',
        'Sarah Hishan_name',
        'Sarah Hishan_blanket_search', 
        'SarahH_username',
        'SE16 2XG, GB_address',
        '447717575654_phone'
    ];
    
    let totalRestored = 0;
    majorSearches.forEach(cacheKey => {
        if (searchCache.has(cacheKey)) {
            const data = searchCache.get(cacheKey);
            if (data && data.results && data.results.length > 0) {
                processCachedResults(data.results, null);
                totalRestored += data.results.length;
            }
        }
    });
    
    if (totalRestored > 0) {
        updateStatus(`Restored ${totalRestored} items from cache`);
        saveGraphState();
        // Focus on network
        network.fit({ animation: { duration: 500 } });
    } else {
        updateStatus('No cached data found to restore');
    }
}

// Create hypothetical link between two nodes
function createHypotheticalLink(nodeId1, nodeId2, reason = "Hypothetical connection") {
    // Check if link already exists
    const existingEdge = edges.get({
        filter: edge => (edge.from === nodeId1 && edge.to === nodeId2) ||
                       (edge.from === nodeId2 && edge.to === nodeId1)
    });
    
    if (existingEdge.length === 0 && nodeId1 !== nodeId2) {
        const edgeId = `hypothetical_${nodeId1}_${nodeId2}`;
        edges.add({
            id: edgeId,
            from: nodeId1,
            to: nodeId2,
            color: { color: "#0066ff" }, // Blue color
            dashes: [3, 3], // Dotted line
            width: 2,
            title: `Hypothetical: ${reason}`,
            arrows: { to: { enabled: false } },
            hypothetical: true
        });
        
        console.log(`Created hypothetical link between ${nodeId1} and ${nodeId2}`);
        return true;
    }
    return false;
}

// Add manual hypothetical link creation to context menu
function addHypotheticalLinkOption(menu, nodeId) {
    menu.innerHTML += `
        <div class="menu-item" onclick="startHypotheticalLinkMode(${nodeId})">
            Create Hypothetical Link
        </div>
    `;
}

// Start hypothetical link creation mode
window.startHypotheticalLinkMode = function(nodeId) {
    // Hide context menu
    const menu = document.getElementById("context-menu");
    if (menu) menu.remove();
    
    window.hypotheticalLinkSourceNode = nodeId;
    window.hypotheticalLinkMode = true;
    
    updateStatus("Click on another node to create a hypothetical link");
    
    // Change cursor to indicate linking mode
    document.body.style.cursor = "crosshair";
}

// Handle hypothetical link mode clicks
function handleHypotheticalLinkClick(targetNodeId) {
    if (window.hypotheticalLinkMode && window.hypotheticalLinkSourceNode) {
        const reason = prompt("Enter reason for hypothetical connection:", "Similar pattern detected");
        if (reason) {
            createHypotheticalLink(window.hypotheticalLinkSourceNode, targetNodeId, reason);
            updateStatus(`Created hypothetical link: ${reason}`);
            saveGraphState();
        }
        
        // Exit hypothetical link mode
        window.hypotheticalLinkMode = false;
        window.hypotheticalLinkSourceNode = null;
        document.body.style.cursor = "default";
    }
}



// Generate comprehensive report using Claude AI
window.generateReport = async function(scope) {
    updateStatus(`Generating ${scope} report with Claude AI...`);
    
    // Determine which nodes to include
    let targetNodes = [];
    let reportTitle = "";
    
    switch(scope) {
        case "selected":
            targetNodes = network.getSelectedNodes();
            reportTitle = "Selected Nodes Analysis Report";
            if (targetNodes.length === 0) {
                updateStatus("No nodes selected for report");
                return;
            }
            break;
        case "anchored":
            targetNodes = Array.from(anchoredNodes);
            reportTitle = "Anchored Nodes Analysis Report";
            if (targetNodes.length === 0) {
                updateStatus("No anchored nodes for report");
                return;
            }
            break;
        case "all":
            targetNodes = nodes.get().map(n => n.id);
            reportTitle = "Complete Graph Analysis Report";
            if (targetNodes.length === 0) {
                updateStatus("No nodes on board for report");
                return;
            }
            break;
    }
    
    // Collect detailed node and connection data
    const reportData = {
        title: reportTitle,
        scope: scope,
        nodeCount: targetNodes.length,
        nodes: [],
        connections: [],
        breaches: new Set(),
        dataTypes: new Set(),
        sources: new Set()
    };
    
    // Gather node information
    targetNodes.forEach(nodeId => {
        const node = nodes.get(nodeId);
        if (node) {
            const nodeInfo = {
                id: nodeId,
                type: node.type || "unknown",
                value: node.data?.value || node.label || "Unknown",
                label: node.label,
                breach: node.data?.breach || "Unknown",
                source: node.data?.source || "DeHashed",
                breachDate: node.data?.breachData?.breach_date || null,
                addedDate: node.data?.breachData?.added_date || null,
                notes: node.data?.notes || "",
                isAnchored: anchoredNodes.has(nodeId),
                variations: node.data?.variations?.length || 0,
                mergedImages: node.data?.mergedImages?.length || 0
            };
            
            reportData.nodes.push(nodeInfo);
            reportData.breaches.add(nodeInfo.breach);
            reportData.dataTypes.add(nodeInfo.type);
            reportData.sources.add(nodeInfo.source);
        }
    });
    
    // Gather connection information
    const allEdges = edges.get();
    const relevantEdges = allEdges.filter(edge => 
        targetNodes.includes(edge.from) && targetNodes.includes(edge.to)
    );
    
    relevantEdges.forEach(edge => {
        const fromNode = nodes.get(edge.from);
        const toNode = nodes.get(edge.to);
        
        if (fromNode && toNode) {
            const connectionInfo = {
                from: fromNode.label || fromNode.id,
                fromType: fromNode.type || "unknown", 
                to: toNode.label || toNode.id,
                toType: toNode.type || "unknown",
                type: edge.hypothetical ? "hypothetical" : 
                      edge.color?.color === "#ffffff" ? "anchored" :
                      edge.color?.color === "#ff00ff" ? "manual" :
                      edge.color?.color === "#00BFFF" ? "OSINT" :
                      edge.color?.color === "#20B2AA" ? "WHOIS" : "breach-related",
                reason: edge.title || "Related data",
                dashed: edge.dashes ? true : false
            };
            
            reportData.connections.push(connectionInfo);
        }
    });
    
    // Convert sets to arrays for JSON
    reportData.breaches = Array.from(reportData.breaches);
    reportData.dataTypes = Array.from(reportData.dataTypes);
    reportData.sources = Array.from(reportData.sources);
    
    // Generate Claude AI report with retry logic
    let retryCount = 0;
    const maxRetries = 3;
    
    while (retryCount < maxRetries) {
        try {
            updateStatus(`Generating ${scope} report... (attempt ${retryCount + 1}/${maxRetries})`);
            
            const response = await fetch("/api/ai-suggestions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    model: "claude-sonnet-4-20250514",
                    max_tokens: 4000,
                    temperature: 0.3,
                    messages: [
                        {
                            role: "user",
                            content: `You are a cybersecurity analyst. Create a comprehensive intelligence report based on the following breach investigation data.

REPORT DATA:
${JSON.stringify(reportData, null, 2)}

Create a professional intelligence report with the following structure:

# ${reportData.title}

## Executive Summary
Provide a high-level overview of the key findings, scope, and significance.

## Data Overview  
- Total entities analyzed: ${reportData.nodeCount}
- Data types found: ${reportData.dataTypes.join(", ")}
- Breaches involved: ${reportData.breaches.length}
- Sources: ${reportData.sources.join(", ")}
- Connections identified: ${reportData.connections.length}

## Detailed Findings

### Entities by Type
Break down the data by type (emails, usernames, passwords, phones, etc.) and highlight patterns.

### Breach Analysis
Analyze which breaches are represented and their significance.

### Connection Analysis  
Describe the relationships between entities and what they reveal.

### Notable Patterns
Identify any significant patterns, clusters, or anomalies.

## Individual Entity Details
List key entities with their context and connections.

## Risk Assessment
Assess the security implications and potential impact.

## Recommendations
Provide actionable recommendations based on the findings.

## Conclusion
Summarize the key takeaways and next steps.

---
*Report generated on ${new Date().toLocaleString()} using Claude AI analysis*

Format the report in clear, professional markdown with proper headings, bullet points, and emphasis where appropriate. Be thorough but concise. Focus on actionable intelligence.`
                        }
                    ]
                })
            });

            if (response.ok) {
                const data = await response.json();
                const reportContent = data.content?.[0]?.text || data.response;
                
                if (reportContent) {
                    // Display the report in a modal
                    showReportModal(reportContent, reportTitle);
                    updateStatus(`${scope} report generated successfully`);
                    return; // Success, exit the retry loop
                } else {
                    throw new Error("No report content received");
                }
            } else if (response.status === 503) {
                // Service unavailable - Claude API overloaded
                retryCount++;
                if (retryCount < maxRetries) {
                    const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                    updateStatus(`Claude API busy (503), retrying in ${delay/1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                } else {
                    throw new Error("Claude API service unavailable after multiple attempts");
                }
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
        } catch (error) {
            retryCount++;
            if (retryCount < maxRetries && (error.message.includes("503") || error.message.includes("network"))) {
                const delay = Math.pow(2, retryCount) * 1000;
                updateStatus(`Network error, retrying in ${delay/1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            } else {
                console.error("Report generation error:", error);
                console.log("Generating fallback report without Claude API...");
                generateFallbackReport(reportData, reportTitle, scope);
                break;
            }
        }
    }
};

// Generate fallback report without Claude API
function generateFallbackReport(reportData, reportTitle, scope) {
    const report = `# ${reportData.title}

## Executive Summary
This intelligence report analyzes ${reportData.nodeCount} data entities across ${reportData.breaches.length} breach sources. The analysis reveals ${reportData.connections.length} connections between entities, providing insights into data exposure patterns and potential security implications.

## Data Overview
- **Total entities analyzed:** ${reportData.nodeCount}
- **Data types found:** ${reportData.dataTypes.join(", ")}
- **Breaches involved:** ${reportData.breaches.length} (${reportData.breaches.join(", ")})
- **Sources:** ${reportData.sources.join(", ")}
- **Connections identified:** ${reportData.connections.length}
- **Anchored entities:** ${reportData.nodes.filter(n => n.isAnchored).length}

## Detailed Findings

### Entities by Type
${generateEntityBreakdown(reportData)}

### Breach Analysis
${generateBreachAnalysis(reportData)}

### Connection Analysis
The analysis identified ${reportData.connections.length} relationships between entities:
${generateConnectionAnalysis(reportData)}

### Notable Patterns
${generatePatternAnalysis(reportData)}

## Individual Entity Details
${generateEntityDetails(reportData)}

## Risk Assessment
Based on the data analysis:
- **Exposure Level:** ${assessExposureLevel(reportData)}
- **Data Sensitivity:** Multiple PII types exposed including ${reportData.dataTypes.filter(t => ['email', 'phone', 'name', 'password'].includes(t)).join(", ")}
- **Breach Scope:** ${reportData.breaches.length} different breach${reportData.breaches.length > 1 ? 'es' : ''} affecting the analyzed entities

## Recommendations
1. **Immediate Actions:**
   - Monitor all exposed email addresses for suspicious activity
   - Change passwords for all affected accounts
   - Enable two-factor authentication where possible

2. **Long-term Security:**
   - Implement breach monitoring for identified entities
   - Review and strengthen authentication mechanisms
   - Consider identity protection services

## Conclusion
This analysis of ${reportData.nodeCount} entities reveals a complex web of data exposures across ${reportData.breaches.length} breach incidents. The ${reportData.connections.length} identified connections highlight the interconnected nature of the exposed data and underscore the importance of comprehensive security monitoring.

---
*Report generated on ${new Date().toLocaleString()} using automated analysis (Claude API unavailable)*`;

    showReportModal(report, reportTitle);
    updateStatus(`${scope} report generated (fallback mode)`);
}

// Helper functions for fallback report generation
function generateEntityBreakdown(reportData) {
    const typeGroups = {};
    reportData.nodes.forEach(node => {
        if (!typeGroups[node.type]) typeGroups[node.type] = 0;
        typeGroups[node.type]++;
    });
    
    let breakdown = "";
    Object.entries(typeGroups).forEach(([type, count]) => {
        breakdown += `- **${type.charAt(0).toUpperCase() + type.slice(1)}:** ${count} entities\n`;
    });
    return breakdown;
}

function generateBreachAnalysis(reportData) {
    if (reportData.breaches.length === 0) return "No specific breach information available.";
    
    let analysis = `The following ${reportData.breaches.length} breach${reportData.breaches.length > 1 ? 'es were' : ' was'} identified:\n`;
    reportData.breaches.forEach(breach => {
        const breachNodes = reportData.nodes.filter(n => n.breach === breach);
        analysis += `- **${breach}:** ${breachNodes.length} entities\n`;
    });
    return analysis;
}

function generateConnectionAnalysis(reportData) {
    if (reportData.connections.length === 0) return "- No direct connections identified between entities.";
    
    const connectionTypes = {};
    reportData.connections.forEach(conn => {
        if (!connectionTypes[conn.type]) connectionTypes[conn.type] = 0;
        connectionTypes[conn.type]++;
    });
    
    let analysis = "";
    Object.entries(connectionTypes).forEach(([type, count]) => {
        analysis += `- **${type.charAt(0).toUpperCase() + type.slice(1)} connections:** ${count}\n`;
    });
    return analysis;
}

function generatePatternAnalysis(reportData) {
    const patterns = [];
    
    // Check for multiple data types per entity
    const multiTypeEntities = reportData.nodes.filter(n => n.variations > 0).length;
    if (multiTypeEntities > 0) {
        patterns.push(`${multiTypeEntities} entities have multiple data variations`);
    }
    
    // Check for entities across multiple breaches
    const entityBreaches = {};
    reportData.nodes.forEach(node => {
        if (!entityBreaches[node.value]) entityBreaches[node.value] = new Set();
        entityBreaches[node.value].add(node.breach);
    });
    
    const multiBreachEntities = Object.values(entityBreaches).filter(breaches => breaches.size > 1).length;
    if (multiBreachEntities > 0) {
        patterns.push(`${multiBreachEntities} entities appear across multiple breaches`);
    }
    
    // Check for high-connectivity nodes
    const highConnectivity = reportData.connections.length > reportData.nodeCount;
    if (highConnectivity) {
        patterns.push("High connectivity detected - entities are highly interconnected");
    }
    
    return patterns.length > 0 ? patterns.map(p => `- ${p}`).join("\n") : "- No significant patterns detected in current dataset";
}

function generateEntityDetails(reportData) {
    const importantEntities = reportData.nodes.filter(n => n.isAnchored || n.variations > 0 || n.mergedImages > 0);
    
    if (importantEntities.length === 0) {
        return "No entities marked as particularly significant.";
    }
    
    let details = "";
    importantEntities.slice(0, 10).forEach(entity => { // Limit to first 10
        details += `**${entity.value}** (${entity.type})\n`;
        details += `- Source: ${entity.source} (${entity.breach})\n`;
        if (entity.isAnchored) details += `- Status: Anchored for investigation\n`;
        if (entity.variations > 0) details += `- Variations: ${entity.variations} related entries\n`;
        if (entity.mergedImages > 0) details += `- Images: ${entity.mergedImages} attached\n`;
        if (entity.notes) details += `- Notes: ${entity.notes.substring(0, 100)}${entity.notes.length > 100 ? '...' : ''}\n`;
        details += "\n";
    });
    
    return details;
}

function assessExposureLevel(reportData) {
    const sensitiveTypes = ['email', 'phone', 'password', 'name', 'ssn', 'cc'].filter(type => 
        reportData.dataTypes.includes(type)
    ).length;
    
    if (sensitiveTypes >= 4) return "HIGH - Multiple sensitive data types exposed";
    if (sensitiveTypes >= 2) return "MEDIUM - Some sensitive data exposed";
    return "LOW - Limited sensitive data exposure";
}

// Show report in a modal window
function showReportModal(reportContent, title) {
    // Convert markdown to HTML for better display
    const htmlContent = reportContent
        .replace(/^# (.+)$/gm, "<h1>$1</h1>")
        .replace(/^## (.+)$/gm, "<h2>$1</h2>")
        .replace(/^### (.+)$/gm, "<h3>$1</h3>")
        .replace(/^\* (.+)$/gm, "<li>$1</li>")
        .replace(/^- (.+)$/gm, "<li>$1</li>")
        .replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>")
        .replace(/\*(.+?)\*/g, "<em>$1</em>")
        .replace(/\n\n/g, "</p><p>")
        .replace(/^(?!<[hul])/gm, "<p>")
        .replace(/$(?![hul>])/gm, "</p>")
        .replace(/<p><\/p>/g, "")
        .replace(/<p>(<[hul])/g, "$1")
        .replace(/(<\/[hul]>)<\/p>/g, "$1");
    
    const modal = document.createElement("div");
    modal.id = "reportModal";
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 20000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    modal.innerHTML = `
        <div style="
            background: #000;
            border: 2px solid #00ff00;
            width: 90%;
            max-width: 1000px;
            height: 90%;
            padding: 20px;
            overflow-y: auto;
            font-family: monospace;
            color: #00ff00;
            position: relative;
        ">
            <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #00ff00; padding-bottom: 10px;">
                <h2 style="margin: 0; color: #00ff00;">${title}</h2>
                <div style="margin-left: auto; display: flex; gap: 10px;">
                    <button onclick="copyReportToClipboard()" style="background: #004400; color: #00ff00; border: 1px solid #00ff00; padding: 5px 10px; cursor: pointer;">Copy</button>
                    <button onclick="downloadReport()" style="background: #004400; color: #00ff00; border: 1px solid #00ff00; padding: 5px 10px; cursor: pointer;">Download</button>
                    <button onclick="closeReportModal()" style="background: #440000; color: #ff0000; border: 1px solid #ff0000; padding: 5px 10px; cursor: pointer;">Close</button>
                </div>
            </div>
            <div id="reportContent" style="line-height: 1.6; font-size: 12px;">
                ${htmlContent}
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Store report content globally for copy/download
    window.currentReportContent = reportContent;
    window.currentReportTitle = title;
}

// Close report modal
window.closeReportModal = function() {
    const modal = document.getElementById("reportModal");
    if (modal) modal.remove();
}

// Copy report to clipboard
window.copyReportToClipboard = function() {
    if (window.currentReportContent) {
        navigator.clipboard.writeText(window.currentReportContent).then(() => {
            updateStatus("Report copied to clipboard");
        }).catch(err => {
            console.error("Copy failed:", err);
            updateStatus("Copy failed");
        });
    }
}

// Download report as text file
window.downloadReport = function() {
    if (window.currentReportContent && window.currentReportTitle) {
        const blob = new Blob([window.currentReportContent], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${window.currentReportTitle.replace(/[^a-zA-Z0-9]/g, "_")}_${new Date().toISOString().split("T")[0]}.md`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        updateStatus("Report downloaded");
    }
}

// ==================== UNIVERSAL UNDO SYSTEM ====================

// Save current graph state to undo stack
function saveUndoState(actionDescription = "Action") {
    if (isRestoringFromUndo) return; // Don't save undo states when restoring
    
    console.log(`Saving undo state: ${actionDescription}`);
    
    const currentState = {
        timestamp: Date.now(),
        description: actionDescription,
        nodes: nodes.get(),
        edges: edges.get(),
        nodeIdCounter: nodeIdCounter,
        valueToNodeMap: Array.from(valueToNodeMap.entries()),
        breachConnections: Array.from(breachConnections.entries()),
        nodeSearchQueries: Array.from(nodeSearchQueries.entries()),
        anchoredNodes: Array.from(anchoredNodes),
        selectedNodes: Array.from(selectedNodes),
        clusters: Array.from(clusters.entries()).map(([id, cluster]) => [
            id, {
                ...cluster,
                nodeIds: Array.from(cluster.nodeIds)
            }
        ]),
        clusterIdCounter: clusterIdCounter,
        showClusterContents: showClusterContents
    };
    
    // Add to undo stack
    undoStack.push(currentState);
    
    // Limit stack size
    if (undoStack.length > MAX_UNDO_STACK_SIZE) {
        undoStack.shift(); // Remove oldest state
    }
    
    // Update undo button
    const undoBtn = document.getElementById('undoBtn');
    if (undoBtn) {
        undoBtn.disabled = false;
        undoBtn.title = `Undo: ${actionDescription}`;
    }
    
    console.log(`Undo stack now has ${undoStack.length} states`);
}

// Restore previous graph state
function undoLastAction() {
    if (undoStack.length === 0) {
        updateStatus("Nothing to undo");
        return;
    }
    
    const previousState = undoStack.pop();
    isRestoringFromUndo = true;
    
    console.log(`Undoing: ${previousState.description}`);
    
    try {
        // Clear current graph
        nodes.clear();
        edges.clear();
        
        // Restore all data
        nodes.add(previousState.nodes);
        edges.add(previousState.edges);
        
        // Restore global variables
        nodeIdCounter = previousState.nodeIdCounter;
        valueToNodeMap = new Map(previousState.valueToNodeMap);
        breachConnections = new Map(previousState.breachConnections);
        nodeSearchQueries = new Map(previousState.nodeSearchQueries || []);
        anchoredNodes = new Set(previousState.anchoredNodes);
        selectedNodes = new Set(previousState.selectedNodes);
        clusterIdCounter = previousState.clusterIdCounter || 0;
        showClusterContents = previousState.showClusterContents !== undefined ? previousState.showClusterContents : true;
        
        // Restore clusters
        clusters.clear();
        if (previousState.clusters) {
            previousState.clusters.forEach(([id, clusterData]) => {
                clusters.set(id, {
                    ...clusterData,
                    nodeIds: new Set(clusterData.nodeIds)
                });
            });
        }
        
        // Update UI
        network.selectNodes(Array.from(selectedNodes));
        updateClusterButtons();
        updateNodeCount();
        updateEdgeCount();
        
        // Update cluster contents checkbox
        const clusterContentsCheckbox = document.getElementById('showClusterContents');
        if (clusterContentsCheckbox) {
            clusterContentsCheckbox.checked = showClusterContents;
        }
        
        // Update cluster visuals
        updateClusterVisuals();
        
        updateStatus(`Undid: ${previousState.description}`);
        
    } catch (error) {
        console.error("Error during undo:", error);
        updateStatus(`Undo failed: ${error.message}`);
    } finally {
        isRestoringFromUndo = false;
    }
    
    // Update undo button
    const undoBtn = document.getElementById('undoBtn');
    if (undoBtn) {
        if (undoStack.length === 0) {
            undoBtn.disabled = true;
            undoBtn.title = "Nothing to undo";
        } else {
            undoBtn.title = `Undo: ${undoStack[undoStack.length - 1].description}`;
        }
    }
    
    console.log(`Undo stack now has ${undoStack.length} states`);
}

// ==================== CLUSTER SYSTEM ====================

// Create a new cluster with selected nodes
function createCluster(nodeIds, clusterName = null) {
    console.log("createCluster called with:", nodeIds, clusterName);
    
    if (!nodeIds || nodeIds.length === 0) {
        console.log("No nodes provided for cluster creation");
        updateStatus("No nodes selected for cluster creation");
        return null;
    }
    
    console.log("Getting cluster nodes from vis.js dataset");
    const nodesToCluster = nodes.get(nodeIds);
    console.log("Retrieved nodes:", nodesToCluster);
    
    const clusterId = `cluster_${clusterIdCounter++}`;
    const name = clusterName || `Cluster ${clusters.size + 1}`;
    
    // Calculate cluster position (center of contained nodes)
    let centerX = 0, centerY = 0;
    nodesToCluster.forEach(node => {
        centerX += node.x || 0;
        centerY += node.y || 0;
    });
    centerX /= nodesToCluster.length;
    centerY /= nodesToCluster.length;
    
    // Create cluster data structure
    const cluster = {
        id: clusterId,
        label: name,
        nodeIds: new Set(nodeIds),
        x: centerX,
        y: centerY,
        width: 400,
        height: 300,
        color: '#444444',
        borderColor: '#ff6600',
        borderWidth: 4,
        visible: true,
        contentsVisible: showClusterContents
    };
    
    clusters.set(clusterId, cluster);
    
    // Update nodes to be part of cluster
    nodeIds.forEach(nodeId => {
        const node = nodes.get(nodeId);
        if (node) {
            node.clusterId = clusterId;
            node.clusterRelativeX = (node.x || 0) - centerX;
            node.clusterRelativeY = (node.y || 0) - centerY;
            // Show nodes by default since showClusterContents is true
            node.hidden = !showClusterContents;
        }
    });
    
    nodes.update(nodesToCluster);
    
    console.log("Cluster data structure created:", cluster);
    
    // Create cluster visual representation
    console.log("Calling updateClusterVisuals...");
    updateClusterVisuals();
    
    // Rebuild connections to use cluster connections
    console.log("Calling rebuildClusterConnections...");
    rebuildClusterConnections();
    
    console.log("Cluster creation completed successfully");
    updateStatus(`Created cluster "${name}" with ${nodeIds.length} nodes`);
    return clusterId;
}

// Remove a cluster and restore individual nodes
function removeCluster(clusterId) {
    const cluster = clusters.get(clusterId);
    if (!cluster) return;
    
    // First, restore all original edges that were hidden by clustering
    const allEdges = edges.get();
    allEdges.forEach(edge => {
        // Remove cluster-specific edges
        if (edge.id.includes('cluster_') || edge.originalEdgeId) {
            edges.remove(edge.id);
        } else {
            // Restore original edges by making them visible
            edge.hidden = false;
            edges.update(edge);
        }
    });
    
    // Restore nodes
    const clusterNodes = nodes.get(Array.from(cluster.nodeIds));
    clusterNodes.forEach(node => {
        delete node.clusterId;
        delete node.clusterRelativeX;
        delete node.clusterRelativeY;
        node.hidden = false;
    });
    
    nodes.update(clusterNodes);
    clusters.delete(clusterId);
    
    // Remove cluster visual
    updateClusterVisuals();
    
    // Only rebuild if there are still clusters
    if (clusters.size > 0) {
        rebuildClusterConnections();
    }
    
    updateStatus(`Removed cluster "${cluster.label}" - connections restored`);
}

// Toggle visibility of cluster contents
window.toggleClusterContents = function(show = null) {
    showClusterContents = show !== null ? show : !showClusterContents;
    
    // Update all cluster nodes visibility
    clusters.forEach(cluster => {
        const clusterNodes = nodes.get(Array.from(cluster.nodeIds));
        clusterNodes.forEach(node => {
            node.hidden = !showClusterContents;
        });
        nodes.update(clusterNodes);
        cluster.contentsVisible = showClusterContents;
    });
    
    // When showing contents, ensure clusters are large enough
    if (showClusterContents) {
        // Give nodes time to update positions
        setTimeout(() => {
            updateClusterVisuals();
        }, 100);
    } else {
        updateClusterVisuals();
    }
    
    updateStatus(`Cluster contents ${showClusterContents ? 'shown' : 'hidden'}`);
}

// Update cluster visual representation
function updateClusterVisuals() {
    console.log("updateClusterVisuals called");
    console.log("Current clusters:", clusters);
    
    // Remove existing cluster visuals
    const existingClusters = nodes.get().filter(node => node.type === 'cluster' || node.type === 'cluster_inner');
    console.log("Existing cluster visuals to remove:", existingClusters);
    if (existingClusters.length > 0) {
        nodes.remove(existingClusters.map(c => c.id));
    }
    
    // Add cluster visual nodes
    const clusterVisuals = [];
    console.log("Processing", clusters.size, "clusters");
    clusters.forEach(cluster => {
        if (cluster.visible) {
            // Calculate cluster bounds based on contained nodes
            const clusterNodes = nodes.get(Array.from(cluster.nodeIds)).filter(n => n.type !== 'cluster');
            if (clusterNodes.length > 0) {
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                clusterNodes.forEach(node => {
                    minX = Math.min(minX, (node.x || 0) - 25);
                    maxX = Math.max(maxX, (node.x || 0) + 25);
                    minY = Math.min(minY, (node.y || 0) - 25);
                    maxY = Math.max(maxY, (node.y || 0) + 25);
                });
                
                // Add much larger padding for cluster frame
                const padding = 80;
                minX -= padding;
                maxX += padding;
                minY -= padding;
                maxY += padding;
                
                cluster.x = (minX + maxX) / 2;
                cluster.y = (minY + maxY) / 2;
                cluster.width = maxX - minX;
                cluster.height = maxY - minY;
            }
            
            // Create cluster frame visual
            clusterVisuals.push({
                id: cluster.id,
                label: cluster.label,
                x: cluster.x,
                y: cluster.y,
                type: 'cluster',
                shape: 'box',
                color: {
                    background: 'rgba(255, 102, 0, 0.05)',
                    border: cluster.borderColor,
                    highlight: {
                        background: 'rgba(255, 102, 0, 0.1)',
                        border: '#ffaa44'
                    }
                },
                borderWidth: 6,
                borderWidthSelected: 8,
                shapeProperties: {
                    borderDashes: false,
                    borderRadius: 10
                },
                font: {
                    color: '#ff6600',
                    size: 18,
                    face: 'Arial',
                    bold: true
                },
                size: 1, // Size controlled by width/height constraints
                widthConstraint: { minimum: cluster.width, maximum: cluster.width },
                heightConstraint: { minimum: cluster.height, maximum: cluster.height },
                physics: false,
                fixed: false,
                mass: 10 // Heavy mass to prevent movement
            });
            
            // Create inner border for double-line effect
            clusterVisuals.push({
                id: cluster.id + '_inner',
                label: '',
                x: cluster.x,
                y: cluster.y,
                type: 'cluster_inner',
                shape: 'box',
                color: {
                    background: 'transparent',
                    border: cluster.borderColor,
                    highlight: {
                        background: 'transparent',
                        border: '#ffaa44'
                    }
                },
                borderWidth: 2,
                borderWidthSelected: 3,
                shapeProperties: {
                    borderDashes: false,
                    borderRadius: 8
                },
                size: 1,
                widthConstraint: { minimum: cluster.width - 10, maximum: cluster.width - 10 },
                heightConstraint: { minimum: cluster.height - 10, maximum: cluster.height - 10 },
                physics: false,
                fixed: false,
                chosen: false,
                mass: 10
            });
        }
    });
    
    console.log("Generated cluster visuals:", clusterVisuals);
    if (clusterVisuals.length > 0) {
        console.log("Adding", clusterVisuals.length, "cluster visuals to graph");
        nodes.add(clusterVisuals);
        console.log("Cluster visuals added successfully");
    } else {
        console.log("No cluster visuals to add");
    }
}

// Rebuild connections to route through clusters
function rebuildClusterConnections() {
    if (clusters.size === 0) return;
    
    const allEdges = edges.get();
    const newEdges = [];
    const clusteredEdges = new Set(); // Track which edges have been clustered
    
    allEdges.forEach(edge => {
        const fromNode = nodes.get(edge.from);
        const toNode = nodes.get(edge.to);
        
        if (!fromNode || !toNode) return;
        
        const fromCluster = fromNode.clusterId;
        const toCluster = toNode.clusterId;
        
        // If both nodes are in the same cluster, hide the edge when contents are hidden
        if (fromCluster && toCluster && fromCluster === toCluster) {
            edge.hidden = !showClusterContents;
            newEdges.push(edge);
        }
        // If nodes are in different clusters, create cluster-to-cluster connection
        else if (fromCluster && toCluster && fromCluster !== toCluster) {
            const clusterEdgeId = `${fromCluster}_to_${toCluster}`;
            
            if (!clusteredEdges.has(clusterEdgeId)) {
                newEdges.push({
                    id: clusterEdgeId,
                    from: fromCluster,
                    to: toCluster,
                    color: { color: '#ffaa00', opacity: 0.8 },
                    width: 3,
                    dashes: [5, 5],
                    title: `Cluster connection (${Array.from(clusters.get(fromCluster).nodeIds).length} ↔ ${Array.from(clusters.get(toCluster).nodeIds).length} nodes)`,
                    originalEdgeId: edge.id
                });
                clusteredEdges.add(clusterEdgeId);
            }
            
            // Hide original edge unless showing cluster contents
            edge.hidden = !showClusterContents;
            newEdges.push(edge);
        }
        // If one node is in cluster, connect to cluster
        else if (fromCluster && !toCluster) {
            const clusterEdgeId = `${fromCluster}_to_${edge.to}`;
            
            if (!clusteredEdges.has(clusterEdgeId)) {
                newEdges.push({
                    id: clusterEdgeId,
                    from: fromCluster,
                    to: edge.to,
                    color: { color: '#ff8800', opacity: 0.8 },
                    width: 2,
                    dashes: [3, 3],
                    title: `Cluster to node connection`,
                    originalEdgeId: edge.id
                });
                clusteredEdges.add(clusterEdgeId);
            }
            
            edge.hidden = !showClusterContents;
            newEdges.push(edge);
        }
        else if (!fromCluster && toCluster) {
            const clusterEdgeId = `${edge.from}_to_${toCluster}`;
            
            if (!clusteredEdges.has(clusterEdgeId)) {
                newEdges.push({
                    id: clusterEdgeId,
                    from: edge.from,
                    to: toCluster,
                    color: { color: '#ff8800', opacity: 0.8 },
                    width: 2,
                    dashes: [3, 3],
                    title: `Node to cluster connection`,
                    originalEdgeId: edge.id
                });
                clusteredEdges.add(clusterEdgeId);
            }
            
            edge.hidden = !showClusterContents;
            newEdges.push(edge);
        }
        // Normal edge between unclustered nodes
        else {
            newEdges.push(edge);
        }
    });
    
    edges.update(newEdges);
}

// Move cluster and all contained nodes
function moveCluster(clusterId, deltaX, deltaY) {
    const cluster = clusters.get(clusterId);
    if (!cluster) return;
    
    // Update cluster position
    cluster.x += deltaX;
    cluster.y += deltaY;
    
    // Move all contained nodes
    const clusterNodes = nodes.get(Array.from(cluster.nodeIds));
    clusterNodes.forEach(node => {
        node.x = (node.x || 0) + deltaX;
        node.y = (node.y || 0) + deltaY;
    });
    
    nodes.update(clusterNodes);
    updateClusterVisuals();
}

// Add selected nodes to existing cluster
function addNodesToCluster(clusterId, nodeIds) {
    const cluster = clusters.get(clusterId);
    if (!cluster) return;
    
    nodeIds.forEach(nodeId => {
        cluster.nodeIds.add(nodeId);
        const node = nodes.get(nodeId);
        if (node) {
            node.clusterId = clusterId;
            node.clusterRelativeX = (node.x || 0) - cluster.x;
            node.clusterRelativeY = (node.y || 0) - cluster.y;
            if (!showClusterContents) {
                node.hidden = true;
            }
        }
    });
    
    nodes.update(nodes.get(nodeIds));
    updateClusterVisuals();
    rebuildClusterConnections();
    updateStatus(`Added ${nodeIds.length} nodes to cluster "${cluster.label}"`);
}

// Remove nodes from cluster
function removeNodesFromCluster(nodeIds) {
    nodeIds.forEach(nodeId => {
        const node = nodes.get(nodeId);
        if (node && node.clusterId) {
            const cluster = clusters.get(node.clusterId);
            if (cluster) {
                cluster.nodeIds.delete(nodeId);
            }
            delete node.clusterId;
            delete node.clusterRelativeX;
            delete node.clusterRelativeY;
            node.hidden = false;
        }
    });
    
    nodes.update(nodes.get(nodeIds));
    updateClusterVisuals();
    rebuildClusterConnections();
    updateStatus(`Removed ${nodeIds.length} nodes from cluster`);
}

// Get cluster information for a node
function getNodeCluster(nodeId) {
    const node = nodes.get(nodeId);
    return node && node.clusterId ? clusters.get(node.clusterId) : null;
}

// UI functions for cluster management
window.createClusterFromSelection = function() {
    console.log("createClusterFromSelection called");
    console.log("selectedNodes:", selectedNodes);
    
    const selectedNodeIds = Array.from(selectedNodes);
    console.log("selectedNodeIds:", selectedNodeIds);
    
    if (selectedNodeIds.length < 2) {
        console.log("Not enough nodes selected");
        updateStatus("Select at least 2 nodes to create a cluster");
        return;
    }
    
    // Save undo state before creating cluster
    saveUndoState("Create Cluster");
    
    console.log("Prompting for cluster name");
    const clusterName = prompt("Enter cluster name:", `Cluster ${clusters.size + 1}`);
    if (clusterName === null) {
        console.log("User cancelled cluster creation");
        return; // User cancelled
    }
    
    console.log("Creating cluster with name:", clusterName);
    const clusterId = createCluster(selectedNodeIds, clusterName || undefined);
    console.log("Created cluster ID:", clusterId);
    
    if (clusterId) {
        // Clear selection after clustering
        network.selectNodes([]);
        selectedNodes.clear();
        updateClusterButtons();
        console.log("Cluster creation completed");
    } else {
        console.log("Cluster creation failed");
    }
}

window.removeSelectedCluster = function() {
    const selectedNodeIds = Array.from(selectedNodes);
    if (selectedNodeIds.length !== 1) {
        updateStatus("Select exactly one cluster to remove");
        return;
    }
    
    const selectedNode = nodes.get(selectedNodeIds[0]);
    if (!selectedNode || selectedNode.type !== 'cluster') {
        updateStatus("Selected item is not a cluster");
        return;
    }
    
    if (confirm(`Remove cluster "${selectedNode.label}"? All nodes will be restored.`)) {
        // Save undo state before removing cluster
        saveUndoState(`Remove Cluster "${selectedNode.label}"`);
        
        removeCluster(selectedNode.id);
        network.selectNodes([]);
        selectedNodes.clear();
        updateClusterButtons();
    }
}

function updateClusterButtons() {
    console.log("updateClusterButtons called, selectedNodes.size:", selectedNodes.size);
    
    const createBtn = document.getElementById('createClusterBtn');
    const removeBtn = document.getElementById('removeClusterBtn');
    
    console.log("createBtn found:", !!createBtn);
    console.log("removeBtn found:", !!removeBtn);
    
    if (createBtn) {
        const shouldDisable = selectedNodes.size < 2;
        createBtn.disabled = shouldDisable;
        console.log("Create button disabled:", shouldDisable);
    }
    
    if (removeBtn) {
        const selectedNodeIds = Array.from(selectedNodes);
        if (selectedNodeIds.length === 1) {
            const selectedNode = nodes.get(selectedNodeIds[0]);
            removeBtn.disabled = !selectedNode || selectedNode.type !== 'cluster';
        } else {
            removeBtn.disabled = true;
        }
        console.log("Remove button disabled:", removeBtn.disabled);
    }
}

// Add cluster support to existing context menu
function addClusterContextMenuItems(menu, nodeId) {
    const node = nodes.get(nodeId);
    if (!node) return;
    
    menu.innerHTML += '<hr>';
    
    if (node.type === 'cluster') {
        menu.innerHTML += `
            <div class="context-menu-item" onclick="removeCluster('${nodeId}'); hideContextMenu();">
                Remove Cluster
            </div>
            <div class="context-menu-item" onclick="toggleClusterContents(); hideContextMenu();">
                ${showClusterContents ? 'Hide' : 'Show'} Contents
            </div>
        `;
    } else {
        const cluster = getNodeCluster(nodeId);
        if (cluster) {
            menu.innerHTML += `
                <div class="context-menu-item" onclick="removeNodesFromCluster(['${nodeId}']); hideContextMenu();">
                    Remove from Cluster
                </div>
            `;
        } else if (selectedNodes.size >= 2) {
            menu.innerHTML += `
                <div class="context-menu-item" onclick="createClusterFromSelection(); hideContextMenu();">
                    Create Cluster from Selected
                </div>
            `;
        }
    }
}

// Integrate cluster drag handling
function handleClusterDrag(nodeId, event) {
    const node = nodes.get(nodeId);
    if (!node || node.type !== 'cluster') return false;
    
    // This will be called during drag operations
    const cluster = clusters.get(nodeId);
    if (cluster) {
        const newPosition = network.getPositions([nodeId])[nodeId];
        const deltaX = newPosition.x - cluster.x;
        const deltaY = newPosition.y - cluster.y;
        
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
            moveCluster(nodeId, deltaX, deltaY);
        }
    }
    
    return true;
}

// Project Management Functions
let currentProjectId = null;

async function loadProjects() {
    try {
        const response = await fetch('/api/projects');
        const data = await response.json();
        
        const projectSelect = document.getElementById('projectSelect');
        projectSelect.innerHTML = '';
        
        if (data.projects.length === 0) {
            // No projects, create a default one
            await createNewProject('Default Project', 'Initial project');
            return;
        }
        
        data.projects.forEach(project => {
            const option = document.createElement('option');
            option.value = project.id;
            option.textContent = project.name;
            if (project.is_active) {
                option.selected = true;
                currentProjectId = project.id;
            }
            projectSelect.appendChild(option);
        });
        
        // Load active project's graph
        await loadActiveProject();
    } catch (error) {
        console.error('Failed to load projects:', error);
        updateStatus('Failed to load projects');
    }
}

async function loadActiveProject() {
    try {
        const response = await fetch('/api/projects/active');
        const data = await response.json();
        
        if (data.project) {
            currentProjectId = data.project.id;
            
            // Clear current graph
            nodes.clear();
            edges.clear();
            nodeIdCounter = 0;
            valueToNodeMap.clear();
            breachConnections.clear();
            nodeSearchQueries.clear();
            activeQueryNodes.clear();
            anchoredNodes.clear();
            selectedNodes.clear();
            searchCache.clear();
            
            // Load project's graph data if it exists
            if (data.project.graph_data) {
                console.log('Project has graph_data:', data.project.graph_data);
                
                // Parse if it's a string
                let graphData = data.project.graph_data;
                if (typeof graphData === 'string') {
                    try {
                        graphData = JSON.parse(graphData);
                        console.log('Parsed graph data:', graphData);
                    } catch (e) {
                        console.error('Failed to parse graph data:', e);
                        updateStatus('Failed to parse project data');
                        return;
                    }
                }
                
                if (graphData.nodes && graphData.nodes.length > 0) {
                    console.log(`Loading ${graphData.nodes.length} nodes from project`);
                    loadGraphState(graphData);
                    
                    // Fit the view after loading
                    setTimeout(() => {
                        network.fit();
                    }, 500);
                } else {
                    console.log('No nodes in graph data');
                }
            } else {
                console.log('No graph data in project');
            }
            
            updateStatus(`Loaded project: ${data.project.name}`);
        }
    } catch (error) {
        console.error('Failed to load active project:', error);
        updateStatus('Failed to load active project');
    }
}

async function handleProjectSwitch(projectId) {
    if (!projectId || projectId === currentProjectId) return;
    
    // Save current project state before switching
    await saveCurrentProjectState();
    
    try {
        const response = await fetch(`/api/projects/${projectId}/switch`, {
            method: 'POST'
        });
        
        if (response.ok) {
            currentProjectId = projectId;
            await loadActiveProject();
        } else {
            updateStatus('Failed to switch project');
        }
    } catch (error) {
        console.error('Failed to switch project:', error);
        updateStatus('Failed to switch project');
    }
}

async function saveCurrentProjectState() {
    if (!currentProjectId) return;
    
    const graphState = {
        nodes: nodes.get(),
        edges: edges.get(),
        nodeIdCounter: nodeIdCounter,
        valueToNodeMap: Array.from(valueToNodeMap.entries()),
        breachConnections: Array.from(breachConnections.entries()),
        nodeSearchQueries: Array.from(nodeSearchQueries.entries()),
        activeQueryNodes: Array.from(activeQueryNodes.entries()),
        anchoredNodes: Array.from(anchoredNodes),
        clusters: Array.from(clusters.entries()),
        clusterIdCounter: clusterIdCounter
    };
    
    try {
        await fetch(`/api/projects/${currentProjectId}/graph`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ graph_data: graphState })
        });
    } catch (error) {
        console.error('Failed to save project state:', error);
    }
}

function showNewProjectDialog() {
    document.getElementById('projectModal').style.display = 'block';
    document.getElementById('newProjectName').value = '';
    document.getElementById('newProjectDescription').value = '';
    document.getElementById('newProjectName').focus();
}

function hideProjectModal() {
    document.getElementById('projectModal').style.display = 'none';
}

async function createNewProject(name, description) {
    const projectName = name || document.getElementById('newProjectName').value.trim();
    const projectDesc = description || document.getElementById('newProjectDescription').value.trim();
    
    if (!projectName) {
        alert('Please enter a project name');
        return;
    }
    
    // Save current project state before creating new one
    await saveCurrentProjectState();
    
    try {
        const response = await fetch('/api/projects', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                name: projectName,
                description: projectDesc
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            hideProjectModal();
            await loadProjects();
            updateStatus(`Created new project: ${projectName}`);
        } else {
            alert('Failed to create project: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Failed to create project:', error);
        alert('Failed to create project');
    }
}

async function deleteCurrentProject() {
    if (!currentProjectId) return;
    
    const projectSelect = document.getElementById('projectSelect');
    const projectName = projectSelect.options[projectSelect.selectedIndex].text;
    
    if (!confirm(`Are you sure you want to delete project "${projectName}"? This cannot be undone.`)) {
        return;
    }
    
    try {
        const response = await fetch(`/api/projects/${currentProjectId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            await loadProjects();
            updateStatus(`Deleted project: ${projectName}`);
        } else {
            alert('Failed to delete project');
        }
    } catch (error) {
        console.error('Failed to delete project:', error);
        alert('Failed to delete project');
    }
}

// Override the original saveGraphState to also save to project
const originalSaveGraphState = saveGraphState;
saveGraphState = async function() {
    await originalSaveGraphState();
    await saveCurrentProjectState();
};

// Save project state before unload
window.addEventListener('beforeunload', function() {
    saveCurrentProjectState();
});

// Store last AI message globally
let lastAIMessage = '';

// Override addChatMessage to capture AI responses
const originalAddChatMessage = addChatMessage;
addChatMessage = function(sender, message, isTyping) {
    if (sender === 'ai' && !isTyping) {
        lastAIMessage = message;
    }
    originalAddChatMessage(sender, message, isTyping);
};

// Extract entities from last AI message
window.extractEntitiesFromLastMessage = function() {
    if (!lastAIMessage) {
        alert('No AI message to extract from');
        return;
    }
    
    // Check for selected image node
    const selectedNodeIds = Array.from(selectedNodes);
    let imageNodeId = null;
    
    for (const nodeId of selectedNodeIds) {
        const node = nodes.get(nodeId);
        if (node && node.shape === 'image') {  // Check shape instead of data.type
            imageNodeId = nodeId;
            break;
        }
    }
    
    if (!imageNodeId) {
        alert('Please select an image node first');
        return;
    }
    
    console.log('Extracting from image node:', imageNodeId);
    console.log('Last AI message:', lastAIMessage);
    
    const createdNodes = new Map();
    let entityCount = 0;
    let connectionCount = 0;
    
    // More flexible entity extraction patterns
    const patterns = [
        // Companies/Organizations
        /(?:company|organization|corp|corporation|business|agency|firm)[::\s]+([^,\n]+)/gi,
        /([A-Z][A-Za-z\s&]+(?:Inc|LLC|Corp|Corporation|Ltd|Limited|Company|Group|Industries|Services|Solutions|Technologies|Agency|Department|Bureau|Foundation|Institute|Association)\.?)/g,
        
        // People names
        /(?:person|individual|name|contact)[::\s]+([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/gi,
        /(?:Mr\.|Ms\.|Mrs\.|Dr\.|Prof\.)\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/g,
        
        // Emails
        /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g,
        
        // Phone numbers
        /(\+?1?[-.\s]?\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4})/g,
        
        // Addresses
        /(\d+\s+[A-Za-z\s]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Plaza|Place|Pl)(?:\s+#?\d+)?)/gi
    ];
    
    const typeMap = {
        0: 'company', 1: 'company',
        2: 'name', 3: 'name',
        4: 'email',
        5: 'phone',
        6: 'address'
    };
    
    // Extract entities
    patterns.forEach((pattern, index) => {
        const matches = Array.from(lastAIMessage.matchAll(pattern));
        matches.forEach(match => {
            const value = match[1].trim();
            if (value && value.length > 2) {
                let nodeType = typeMap[index] || 'unknown';
                
                // Force company type for anything with company keywords
                if (/(?:Inc|LLC|Corp|Corporation|Ltd|Limited|Company|Group|Industries|Services|Solutions|Technologies|Agency|Department|Bureau|Foundation|Institute|Association)\.?/i.test(value)) {
                    nodeType = 'company';
                    console.log('Detected company:', value);
                } else if (nodeType === 'name') {
                    console.log('Detected person:', value);
                }
                
                const result = addNode({
                    value: value,
                    label: value,
                    source: 'AI Image Extract'
                }, nodeType);
                
                if (result && result.nodeId && !result.isExisting) {
                    createdNodes.set(value, result.nodeId);
                    entityCount++;
                    
                    // Create purple SOURCE edge
                    const edgeId = `edge_${imageNodeId}_${result.nodeId}_source`;
                    if (!edges.get(edgeId)) {
                        edges.add({
                            id: edgeId,
                            from: imageNodeId,
                            to: result.nodeId,
                            color: {
                                color: '#9932CC',
                                highlight: '#9932CC',
                                hover: '#9932CC'
                            },
                            width: 2,
                            arrows: {
                                to: { enabled: true, scaleFactor: 0.8 }
                            },
                            label: 'SOURCE',
                            font: { color: '#9932CC', size: 10 },
                            edgeType: 'image_source',
                            hidden: !showImageSources
                        });
                    }
                }
            }
        });
    });
    
    // Extract relationships
    const relPatterns = [
        /([^-,\n]+?)\s*(?:->|→|works?\s+(?:at|for)|employed\s+by|CEO\s+of|founder\s+of|director\s+of|manager\s+at)\s*([^,\n]+)/gi,
        /([^-,\n]+?)\s*(?:belongs?\s+to|owned\s+by|email\s+of|phone\s+of|contact\s+for)\s*([^,\n]+)/gi
    ];
    
    relPatterns.forEach(pattern => {
        const matches = Array.from(lastAIMessage.matchAll(pattern));
        matches.forEach(match => {
            const source = match[1].trim();
            const target = match[2].trim();
            const relationship = match[0].includes('work') || match[0].includes('employ') ? 'Employee' :
                               match[0].includes('CEO') ? 'CEO' :
                               match[0].includes('founder') ? 'Founder' :
                               match[0].includes('director') ? 'Director' :
                               match[0].includes('manager') ? 'Manager' :
                               match[0].includes('email') ? 'Email' :
                               match[0].includes('phone') ? 'Phone' :
                               match[0].includes('belong') || match[0].includes('owned') ? 'Owns' :
                               'Related';
            
            // Find nodes
            let sourceId = createdNodes.get(source);
            let targetId = createdNodes.get(target);
            
            if (!sourceId) {
                nodes.get().forEach(node => {
                    if (node.label === source || node.label.includes(source)) {
                        sourceId = node.id;
                    }
                });
            }
            
            if (!targetId) {
                nodes.get().forEach(node => {
                    if (node.label === target || node.label.includes(target)) {
                        targetId = node.id;
                    }
                });
            }
            
            if (sourceId && targetId && sourceId !== targetId) {
                const edgeId = `edge_${sourceId}_${targetId}_rel`;
                if (!edges.get(edgeId)) {
                    edges.add({
                        id: edgeId,
                        from: sourceId,
                        to: targetId,
                        label: relationship,
                        color: { color: '#00CED1' },
                        width: 2,
                        arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                        font: { color: '#00CED1', size: 12 }
                    });
                    connectionCount++;
                }
            }
        });
    });
    
    saveGraphState();
    updateStatus(`Extracted ${entityCount} entities and ${connectionCount} connections`);
};

// Quick fix function to change all nodes containing company names to company type
window.fixCompanyNodes = function() {
    const companyKeywords = ['Inc', 'LLC', 'Corp', 'Corporation', 'Ltd', 'Company', 'Group', 'Industries', 'Services', 'Solutions', 'Technologies', 'Microsoft', 'Google', 'Apple', 'Amazon', 'FBI', 'CIA', 'NSA'];
    let fixed = 0;
    
    nodes.get().forEach(node => {
        if (node.type === 'name') {
            const label = node.label || '';
            const hasCompanyKeyword = companyKeywords.some(keyword => 
                label.toLowerCase().includes(keyword.toLowerCase())
            );
            
            if (hasCompanyKeyword) {
                changeNodeType(node.id, 'company');
                fixed++;
            }
        }
    });
    
    updateStatus(`Fixed ${fixed} company nodes`);
    return fixed;
};

// Temporary recovery function for legacy data
window.recoverLegacyData = async function() {
    if (!confirm('This will load the graph_state.json file from cache. Continue?')) return;
    
    try {
        const response = await fetch('/api/cache/load');
        const result = await response.json();
        
        if (result.data && result.data.graph_state) {
            console.log('Loading legacy data:', result.data.graph_state);
            
            // Clear current graph
            nodes.clear();
            edges.clear();
            
            // Load the state
            loadGraphState(result.data.graph_state);
            
            // Fit view
            setTimeout(() => {
                network.fit();
                updateStatus(`Recovered ${nodes.get().length} nodes from cache`);
            }, 500);
            
            // Save to current project
            if (currentProjectId) {
                await saveCurrentProjectState();
                updateStatus('Data saved to current project');
            }
        } else {
            alert('No cached data found');
        }
    } catch (error) {
        console.error('Recovery failed:', error);
        alert('Failed to recover data: ' + error.message);
    }
};

